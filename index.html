<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Checkers</title>
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        /* --- Base Styles --- */
        html, body { height: 100%; margin: 0; padding: 0; }
        body {
            font-family: 'Roboto', 'Cairo', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #321e06;
            color: #e0d6c8;
            box-sizing: border-box;
            position: relative;
            /* touch-action: none; /* Ù‚Ø¯ ÙŠØªØ³Ø¨Ø¨ ÙÙŠ Ù…Ø´Ø§ÙƒÙ„ Ù…Ø¹ Ø§Ù„Ø³Ø­Ø¨ ÙˆØ§Ù„Ø¥ÙÙ„Ø§Øª Ø¹Ù„Ù‰ Ø§Ù„Ù„Ù…Ø³ØŒ Ù‚Ø¯ ØªØ­ØªØ§Ø¬ Ù„Ø§Ø®ØªØ¨Ø§Ø±Ù‡ */ */
            overflow-x: hidden; /* Ù…Ù†Ø¹ Ø§Ù„Ø³Ø­Ø¨ Ø§Ù„Ø£ÙÙ‚ÙŠ ØºÙŠØ± Ø§Ù„Ù…Ø±ØºÙˆØ¨ ÙÙŠÙ‡ */
            padding: 10px; /* Ø¥Ø¶Ø§ÙØ© Ø­Ø´Ùˆ Ø¹Ø§Ù… Ù„Ù„Ø¬Ø³Ù… Ù„Ù…Ù†Ø¹ Ø§Ù„Ø¹Ù†Ø§ØµØ± Ù…Ù† Ø§Ù„Ø§Ù„ØªØµØ§Ù‚ Ø¨Ø§Ù„Ø­ÙˆØ§Ù Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø§Ø´Ø§Øª Ø§Ù„ØµØºÙŠØ±Ø© */
        }

        /* --- Start Screen --- */
        #start-screen {
            position: fixed; /* Ø§Ø³ØªØ®Ø¯Ø§Ù… fixed Ù„Ø¶Ù…Ø§Ù† ØªØºØ·ÙŠØ© Ø§Ù„Ø´Ø§Ø´Ø© Ø¨Ø§Ù„ÙƒØ§Ù…Ù„ */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #4a3b31, #321e06, #4a3b31);
            background-size: 200% 200%;
            animation: gradientBG 15s ease infinite;
            text-align: center;
            z-index: 120;
            box-sizing: border-box;
            padding: clamp(20px, 5vh, 80px) 20px; /* Ø­Ø´Ùˆ ÙŠØªÙƒÙŠÙ Ø¹Ù…ÙˆØ¯ÙŠÙ‹Ø§ */
            transition: opacity 0.3s ease-out, visibility 0s linear 0.3s;
            opacity: 1;
            visibility: visible;
         }
        #start-screen.hidden-completely {
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-out, visibility 0s linear 0.3s;
        }

        @keyframes gradientBG { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } }
        #main-title {
            font-size: clamp(3.5em, 13vh, 7em);
            color: #e8d5b7;
            font-weight: 700;
            margin-bottom: clamp(30px, 7vh, 60px); /* Ù‡ÙˆØ§Ù…Ø´ ØªØªÙƒÙŠÙ */
            text-shadow: 0 0 7px #fff, 0 0 14px #ffd700, 5px 5px 5px rgba(0,0,0,0.6);
            letter-spacing: 2px; /* ØªÙ‚Ù„ÙŠÙ„ ØªØ¨Ø§Ø¹Ø¯ Ø§Ù„Ø£Ø­Ø±Ù Ù‚Ù„ÙŠÙ„Ø§Ù‹ Ù„Ù„Ø´Ø§Ø´Ø§Øª Ø§Ù„ØµØºÙŠØ±Ø© */
            font-family: 'Roboto', 'Cairo', Impact, sans-serif;
            opacity: 0;
            animation: fadeInTitle 1s ease-out 0.5s forwards;
            transition: opacity 0.4s ease-out;
            flex-shrink: 0;
            word-break: break-word; /* Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨ÙƒØ³Ø± Ø§Ù„ÙƒÙ„Ù…Ø© Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø·ÙˆÙŠÙ„Ø© Ø¬Ø¯Ù‹Ø§ */
        }
        @keyframes fadeInTitle { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }
        #start-screen h2#start-subtitle {
            font-size: clamp(1.6em, 5vh, 2.5em);
            color: #f0e5d1;
            margin-top: 0;
            margin-bottom: clamp(25px, 5vh, 40px); /* Ù‡ÙˆØ§Ù…Ø´ ØªØªÙƒÙŠÙ */
            opacity: 0;
            animation: fadeInSubtitle 1s ease-out 1s forwards;
            text-shadow: 1px 1px 4px rgba(0,0,0,0.5);
            transition: opacity 0.4s ease-out;
            flex-shrink: 0;
            word-break: break-word;
            padding: 0 10px; /* Ø¥Ø¶Ø§ÙØ© Ø­Ø´Ùˆ Ù„Ø¶Ù…Ø§Ù† Ø¹Ø¯Ù… Ø§Ù„Ø§Ù„ØªØµØ§Ù‚ Ø¨Ø§Ù„Ø­ÙˆØ§Ù */
        }
        @keyframes fadeInSubtitle { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
        #start-options { display: flex; flex-direction: column; align-items: center; width: 100%; opacity: 1; transition: opacity 0.5s ease-out; flex-shrink: 0; padding: 0 10px; box-sizing: border-box; } /* Ø¥Ø¶Ø§ÙØ© Ø­Ø´Ùˆ ÙˆØ¹Ø±Ø¶ 100% Ù…Ø¹ box-sizing */
        .start-button {
             font-family: 'Roboto', 'Cairo', sans-serif;
             font-size: clamp(1.4em, 4.5vh, 2em);
             padding: clamp(12px, 3vh, 25px) clamp(25px, 6vw, 50px);
             margin: clamp(10px, 2vh, 20px) 0; /* Ù‡ÙˆØ§Ù…Ø´ ØªØªÙƒÙŠÙØŒ 0 ÙŠØ³Ø§Ø±/ÙŠÙ…ÙŠÙ† Ù„ÙŠÙƒÙˆÙ† Ø¹Ø±Ø¶ Ø§Ù„Ø²Ø± Ù…Ø±Ù†Ù‹Ø§ */
             width: 90%; /* Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¹Ø±Ø¶ Ù†Ø³Ø¨ÙŠ */
             max-width: 380px; /* ØªØ­Ø¯ÙŠØ¯ Ø£Ù‚ØµÙ‰ Ø¹Ø±Ø¶ */
             cursor: pointer;
             border: none;
             border-radius: 20px;
             background: linear-gradient(to bottom, #966f4d, #7a542e);
             color: #ffffff;
             text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
             box-shadow: 0 7px 12px rgba(0,0,0,0.45), inset 0 1px 2px rgba(255,255,255,0.2);
             transition: all 0.2s ease;
             opacity: 0;
             transform: translateY(20px);
             animation: fadeInUpButton 0.6s ease-out forwards;
             flex-shrink: 0;
             box-sizing: border-box; /* ØªØ¶Ù…ÙŠÙ† Ø§Ù„Ø­Ø´Ùˆ ÙˆØ§Ù„Ø­Ø¯ÙˆØ¯ ÙÙŠ Ø§Ù„Ø¹Ø±Ø¶ */
             white-space: nowrap; /* Ù…Ù†Ø¹ ÙƒØ³Ø± Ø§Ù„Ù†Øµ Ø¯Ø§Ø®Ù„ Ø§Ù„Ø²Ø± Ø¥Ù„Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø·ÙˆÙŠÙ„Ø§Ù‹ Ø¬Ø¯Ù‹Ø§ */
             overflow: hidden; /* Ø¥Ø®ÙØ§Ø¡ Ø£ÙŠ Ù†Øµ ÙŠØªØ¬Ø§ÙˆØ² Ø§Ù„Ø¹Ø±Ø¶ */
             text-overflow: ellipsis; /* Ø¥Ø¶Ø§ÙØ© Ø¹Ù„Ø§Ù…Ø© Ø§Ù„Ù‚Ø·Ø¹ Ù„Ù„Ù†Øµ Ø§Ù„Ø²Ø§Ø¦Ø¯ */
             display: block; /* Ø¶Ù…Ø§Ù† Ø£Ù† ÙŠØ£Ø®Ø° Ø§Ù„Ø²Ø± Ø§Ù„Ø³Ø·Ø± Ø§Ù„Ø®Ø§Øµ Ø¨Ù‡ */
             text-decoration: none; /* Ø¥Ø²Ø§Ù„Ø© Ø£ÙŠ ØªØ²ÙŠÙŠÙ† Ù†Øµ Ø§ÙØªØ±Ø§Ø¶ÙŠ */
        }
        #vs-human-button { animation-delay: 1.3s; }
        #vs-ai-button { animation-delay: 1.5s; }
        @keyframes fadeInUpButton { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        .start-button:hover { background: linear-gradient(to bottom, #a07551, #8b5e3c); box-shadow: 0 9px 16px rgba(0,0,0,0.55), inset 0 1px 2px rgba(255,255,255,0.2); transform: translateY(-4px) scale(1.04); }
        .start-button:active { transform: translateY(0px) scale(1); box-shadow: 0 5px 8px rgba(0,0,0,0.4), inset 0 1px 2px rgba(0,0,0,0.25); }

        /* --- AI Difficulty Selector --- */
        #ai-difficulty-selector-container {
            display: none; flex-direction: column; align-items: center;
            width: 90%; /* Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¹Ø±Ø¶ Ù†Ø³Ø¨ÙŠ */
            max-width: 480px; /* ØªØ­Ø¯ÙŠØ¯ Ø£Ù‚ØµÙ‰ Ø¹Ø±Ø¶ */
            padding: clamp(20px, 4vw, 30px) clamp(20px, 5vw, 35px); /* Ø­Ø´Ùˆ ÙŠØªÙƒÙŠÙ */
            background-color: #3a281a; border-radius: 15px; border: 1px solid #6b4f3b; z-index: 130; opacity: 0;
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.9);
            transition: opacity 0.3s ease-out 0.1s, transform 0.3s ease-out 0.1s; visibility: hidden;
            box-sizing: border-box; /* ØªØ¶Ù…ÙŠÙ† Ø§Ù„Ø­Ø´Ùˆ ÙÙŠ Ø§Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø£Ù‚ØµÙ‰ */
        }
        #ai-difficulty-selector-container.visible { display: flex; opacity: 1; transform: translate(-50%, -50%) scale(1); visibility: visible; }
        #ai-difficulty-selector-container h3 { color: #f0e5d1; margin-top: 0; margin-bottom: clamp(20px, 4vh, 30px); font-size: clamp(1.4em, 4vh, 1.8em); text-shadow: 1px 1px 2px rgba(0,0,0,0.4); text-align: center; } /* Ø¥Ø¶Ø§ÙØ© text-align */
        .difficulty-control { display: flex; align-items: center; justify-content: center; gap: clamp(15px, 4vw, 30px); width: 100%; margin-bottom: clamp(25px, 5vh, 35px); } /* ØªÙƒÙŠÙŠÙ Ø§Ù„ÙØ¬ÙˆØ© */
        .difficulty-arrow-button { background: linear-gradient(to bottom, #966f4d, #7a542e); border: none; color: white; font-size: clamp(1.4em, 4vw, 1.8em); padding: clamp(8px, 2vw, 10px) clamp(15px, 3vw, 18px); border-radius: 10px; cursor: pointer; box-shadow: 0 4px 6px rgba(0,0,0,0.3); transition: all 0.2s ease; flex-shrink: 0; } /* ØªÙƒÙŠÙŠÙ Ø­Ø¬Ù… Ø§Ù„Ø²Ø± */
        .difficulty-arrow-button:hover { background: linear-gradient(to bottom, #a07551, #8b5e3c); transform: scale(1.05); }
        .difficulty-arrow-button:active { transform: scale(0.98); box-shadow: 0 2px 4px rgba(0,0,0,0.3); }
        #difficulty-display { font-size: clamp(1.6em, 4.5vh, 2.1em); font-weight: bold; color: #fff; text-shadow: 1px 1px 3px rgba(0,0,0,0.6); min-width: clamp(80px, 15vw, 120px); text-align: center; } /* ØªÙƒÙŠÙŠÙ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ù„Ù„Ø¹Ø±Ø¶ */
        #confirm-difficulty-button { font-size: clamp(1.3em, 4vh, 1.9em); padding: clamp(12px, 3vh, 25px) clamp(20px, 5vw, 50px); width: 90%; max-width: 350px; opacity: 1; transform: none; animation: none; margin-top: 15px; box-sizing: border-box; } /* ØªÙƒÙŠÙŠÙ Ø§Ù„Ø¹Ø±Ø¶ */
        #close-difficulty-selector { position: absolute; top: 10px; right: 10px; left: auto; background: none; border: none; font-size: clamp(1.3em, 3vw, 1.6em); color: #e0d6c8; cursor: pointer; padding: 5px; transition: color 0.2s ease, transform 0.2s ease; z-index: 131; } /* ØªÙƒÙŠÙŠÙ Ø­Ø¬Ù… Ø§Ù„Ø£ÙŠÙ‚ÙˆÙ†Ø© */
        #close-difficulty-selector:hover { color: #ffffff; transform: scale(1.1); }
        #difficulty-prev i.fa-chevron-left { transform: none; } #difficulty-next i.fa-chevron-right { transform: none; }

        /* --- Game Container --- */
        #game-container {
            display: none; flex-direction: column; align-items: center;
            justify-content: center; /* ØªØºÙŠÙŠØ± Ø¥Ù„Ù‰ center Ù„ØªØ±Ùƒ Ù…Ø³Ø§Ø­Ø© Ø£ÙƒØ¨Ø± Ù„Ù„ÙˆØ­Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø§Ø´Ø§Øª Ø§Ù„ØµØºÙŠØ±Ø© */
            width: 100%; min-height: 100%; /* Ø§Ø³ØªØ®Ø¯Ø§Ù… min-height Ù„Ø¶Ù…Ø§Ù† Ø§Ø­ØªÙˆØ§Ø¡ Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø¥Ø°Ø§ Ø²Ø§Ø¯ */
            padding: clamp(10px, 2vh, 20px); /* Ø­Ø´Ùˆ ÙŠØªÙƒÙŠÙ */
            gap: clamp(10px, 2vh, 20px); /* ØªÙƒÙŠÙŠÙ Ø§Ù„ÙØ¬ÙˆØ© */
            box-sizing: border-box;
            position: relative;
            overflow: hidden; /* Ù…Ù†Ø¹ Ø§Ù„ØªØ¬Ø§ÙˆØ² */
        }

        /* --- Status Bar --- */
        #status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: var(--board-size, 95vmin); /* Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…ØªØºÙŠØ± Ø­Ø¬Ù… Ø§Ù„Ù„ÙˆØ­Ø© Ø£Ùˆ Ù‚ÙŠÙ…Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© */
            max-width: 95vmin; /* Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ vmin */
            margin: 0 auto;
            padding: clamp(5px, 1vmin, 10px) clamp(8px, 2vmin, 15px); /* Ø­Ø´Ùˆ ÙŠØªÙƒÙŠÙ */
            background-color: rgba(0,0,0,0.2);
            border-radius: 8px;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.3);
            flex-wrap: wrap;
            gap: clamp(5px, 1.5vmin, 10px); /* ØªÙƒÙŠÙŠÙ Ø§Ù„ÙØ¬ÙˆØ© Ø¨ÙŠÙ† Ø§Ù„Ø¹Ù†Ø§ØµØ± */
            flex-shrink: 0; /* Ù…Ù†Ø¹ Ø´Ø±ÙŠØ· Ø§Ù„Ø­Ø§Ù„Ø© Ù…Ù† Ø§Ù„Ø§Ù†ÙƒÙ…Ø§Ø´ */
            box-sizing: border-box;
            font-size: clamp(0.8em, 2.5vh, 1.1em); /* ØªÙƒÙŠÙŠÙ Ø­Ø¬Ù… Ø§Ù„Ø®Ø· */
        }

        .status-section.capture-count {
            flex: 1; /* Ø§Ù„Ø³Ù…Ø§Ø­ Ù„Ù‡Ø°Ù‡ Ø§Ù„Ø£Ù‚Ø³Ø§Ù… Ø¨Ø§Ù„Ù†Ù…Ùˆ */
            min-width: 80px; /* Ø¥Ø¶Ø§ÙØ© Ø­Ø¯ Ø£Ø¯Ù†Ù‰ Ù„Ù„Ø¹Ø±Ø¶ Ù„Ù…Ù†Ø¹Ù‡Ø§ Ù…Ù† Ø£Ù† ØªØµØ¨Ø­ ØµØºÙŠØ±Ø© Ø¬Ø¯Ù‹Ø§ */
        }

        .status-section.capture-count.white { order: 1; text-align: left; }
        .status-section.capture-count.black { order: 3; text-align: right; }

        #turn-indicators {
            order: 2;
            flex-shrink: 0; /* Ù…Ù†Ø¹Ù‡Ø§ Ù…Ù† Ø§Ù„Ø§Ù†ÙƒÙ…Ø§Ø´ */
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0 clamp(5px, 1vw, 8px); /* ØªÙƒÙŠÙŠÙ Ø§Ù„Ù‡ÙˆØ§Ù…Ø´ */
            height: clamp(30px, 4vmin, 40px); /* ØªÙƒÙŠÙŠÙ Ø§Ù„Ø§Ø±ØªÙØ§Ø¹ */
        }

        .status-section {
            display: flex;
            align-items: center;
            gap: clamp(4px, 1vw, 8px); /* ØªÙƒÙŠÙŠÙ Ø§Ù„ÙØ¬ÙˆØ© Ø¯Ø§Ø®Ù„ Ø§Ù„Ø£Ù‚Ø³Ø§Ù… */
            /* flex-shrink: 0; -- ØªÙ… ØªØ·Ø¨ÙŠÙ‚Ù‡Ø§ Ø®ØµÙŠØµÙ‹Ø§ Ø¹Ù„Ù‰ turn-indicators */
        }
        .status-icon { font-size: 1.2em; width: 20px; text-align: center; flex-shrink: 0;} /* Ù…Ù†Ø¹ Ø§Ù„Ø£ÙŠÙ‚ÙˆÙ†Ø© Ù…Ù† Ø§Ù„Ø§Ù†ÙƒÙ…Ø§Ø´ */
        .timer-display {
             min-width: clamp(40px, 8vw, 60px); /* ØªÙƒÙŠÙŠÙ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ù„Ù„Ø¹Ø±Ø¶ */
             text-align: right;
             background-color: rgba(0,0,0,0.3);
             padding: clamp(1px, 0.5vmin, 2px) clamp(4px, 1vw, 6px); /* ØªÙƒÙŠÙŠÙ Ø§Ù„Ø­Ø´Ùˆ */
             border-radius: 4px;
             font-variant-numeric: tabular-nums; /* Ù„Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø¹Ø±Ø¶ Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø«Ø§Ø¨ØªÙ‹Ø§ */
             flex-shrink: 0; /* Ù…Ù†Ø¹ Ø§Ù„Ù…Ø¤Ù‚Øª Ù…Ù† Ø§Ù„Ø§Ù†ÙƒÙ…Ø§Ø´ */
             box-sizing: border-box;
             word-break: keep-all; /* Ù…Ù†Ø¹ ÙƒØ³Ø± Ø§Ù„Ù†Øµ Ø¯Ø§Ø®Ù„ Ø§Ù„Ù…Ø¤Ù‚Øª */
        }
        /* Ø¶Ø¨Ø· Ø§Ù„Ù‡ÙˆØ§Ù…Ø´ Ù„Ù„Ù…Ø¤Ù‚ØªØ§Øª Ù„ØªÙƒÙˆÙ† Ø¨Ø¹ÙŠØ¯Ø© Ø¹Ù† Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø§Ù„Ù…Ø¬Ø§ÙˆØ±Ø© ÙÙŠ Ù†ÙØ³ Ø§Ù„Ù‚Ø³Ù… */
        .status-section.capture-count.white .timer-display { margin-left: clamp(5px, 1vw, 10px); margin-right: 0; }
        .status-section.capture-count.black .timer-display { margin-right: clamp(5px, 1vw, 10px); margin-left: 0; }

        .turn-indicator {
             width: clamp(25px, 4vmin, 30px); /* ØªÙƒÙŠÙŠÙ Ø§Ù„Ø­Ø¬Ù… */
             height: clamp(25px, 4vmin, 30px); /* ØªÙƒÙŠÙŠÙ Ø§Ù„Ø­Ø¬Ù… */
             border-radius: 50%;
             margin: 0 clamp(5px, 1vw, 8px); /* ØªÙƒÙŠÙŠÙ Ø§Ù„Ù‡ÙˆØ§Ù…Ø´ */
             box-sizing: border-box;
             display: flex;
             align-items: center;
             justify-content: center;
             position: relative;
             border: 2px solid rgba(255, 50, 50, 0.6);
             box-shadow: 0 0 4px rgba(255, 50, 50, 0.4);
             transition: border-color 0.3s ease, box-shadow 0.3s ease, transform 0.3s ease;
             flex-shrink: 0; /* Ù…Ù†Ø¹ Ø§Ù„Ù…Ø¤Ø´Ø± Ù…Ù† Ø§Ù„Ø§Ù†ÙƒÙ…Ø§Ø´ */
        }
        .turn-indicator .piece-visual { width: 85%; height: 85%; border-radius: 50%; box-shadow: 0 1px 3px rgba(0,0,0,0.4); }
        .turn-indicator.active-turn { border-color: rgba(50, 255, 50, 0.8); box-shadow: 0 0 8px rgba(50, 255, 50, 0.7); transform: scale(1.1); }

        /* --- Board & Piece Styles --- */
        #board {
            display: grid;
            /* Ù…ØªØºÙŠØ±Ø§Øª Ø­Ø¬Ù… Ø§Ù„Ù…Ø±Ø¨Ø¹ ÙˆØ§Ù„Ù„ÙˆØ­Ø© ØªØªÙƒÙŠÙ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ vmin Ù…Ø¹ Ø­Ø¯ÙˆØ¯ clamp */
            --square-size: clamp(35px, 9.5vmin, 75px);
            --board-size: calc(var(--square-size) * 8);
            grid-template-columns: repeat(8, var(--square-size));
            grid-template-rows: repeat(8, var(--square-size));
            width: var(--board-size);
            height: var(--board-size);
            box-shadow: 0 8px 16px rgba(0,0,0,0.5), inset 0 0 10px rgba(0,0,0,0.4);
            border-radius: 8px;
            position: relative;
            margin: 0 auto;
            max-width: 95vmin; /* Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø¹Ø¯Ù… ØªØ¬Ø§ÙˆØ² 95% Ù…Ù† Ø£ØµØºØ± Ø¨ÙØ¹Ø¯ ÙÙŠ Ø§Ù„Ø´Ø§Ø´Ø© */
            max-height: 95vmin; /* Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø¹Ø¯Ù… ØªØ¬Ø§ÙˆØ² 95% Ù…Ù† Ø£ØµØºØ± Ø¨ÙØ¹Ø¯ ÙÙŠ Ø§Ù„Ø´Ø§Ø´Ø© */
            aspect-ratio: 1 / 1; /* Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ù†Ø³Ø¨Ø© Ø§Ù„Ø¹Ø±Ø¶ Ø¥Ù„Ù‰ Ø§Ù„Ø§Ø±ØªÙØ§Ø¹ 1:1 */
            flex-shrink: 1; /* Ø§Ù„Ø³Ù…Ø§Ø­ Ù„Ù„ÙˆØ­Ø© Ø¨Ø§Ù„Ø§Ù†ÙƒÙ…Ø§Ø´ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø± */
            border: clamp(5px, 1.5vmin, 10px) solid transparent; /* ØªÙƒÙŠÙŠÙ Ø³Ù…Ùƒ Ø§Ù„Ø¥Ø·Ø§Ø± */
            background-color: #4a311c;
            transition: border-color 0.3s ease, background-color 0.3s ease;
            user-select: none;
            touch-action: none; /* Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø³Ø­Ø¨ ÙˆØ§Ù„Ø¥ÙÙ„Ø§Øª Ø¹Ù„Ù‰ Ø§Ù„Ù„Ù…Ø³ */
        }
        .square { width: var(--square-size); height: var(--square-size); display: flex; align-items: center; justify-content: center; position: relative; transition: background-color 0.15s ease, box-shadow 0.2s ease, background 0.2s ease; overflow: visible; }
        .piece { width: 85%; height: 85%; border-radius: 50%; cursor: grab; display: flex; align-items: center; justify-content: center; font-weight: bold; color: white; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 10; transition: transform 0.15s ease, box-shadow 0.2s ease, background 0.3s ease, border-color 0.3s ease, outline-color 0.3s ease; border: clamp(1px, 0.5vmin, 2px) solid rgba(255, 255, 255, 0.1); /* ØªÙƒÙŠÙŠÙ Ø³Ù…Ùƒ Ø§Ù„Ø­Ø¯ÙˆØ¯ */ overflow: hidden; animation: none; outline: 0px solid transparent; outline-offset: 2px; will-change: transform; touch-action: none; /* Ø¶Ø±ÙˆØ±ÙŠ Ù„Ù„Ø³Ø­Ø¨ ÙˆØ§Ù„Ø¥ÙÙ„Ø§Øª */ }
        .piece.dragging { cursor: grabbing; z-index: 1000 !important; transform: translate(-50%, -50%) scale(1.1); box-shadow: 0 10px 25px rgba(0,0,0,0.5) !important; opacity: 0.85; transition: none !important; }
        .piece.ghost { opacity: 0.3 !important; }
        .piece.captured-fade { animation: fadeOutPiece 0.4s ease-out forwards; z-index: 5; }
        @keyframes fadeOutPiece { from { opacity: 1; transform: translate(-50%, -50%) scale(0.9); } to { opacity: 0; transform: translate(-50%, -50%) scale(0.5); } }
        .piece.jump-hint { outline-color: rgba(0, 255, 0, 0.7); outline-width: clamp(2px, 0.8vmin, 3px); animation: hintPulseGreen 1.5s infinite ease-in-out !important; } /* ØªÙƒÙŠÙŠÙ Ø³Ù…Ùƒ Ø§Ù„Ø®Ø· Ø§Ù„Ø®Ø§Ø±Ø¬ÙŠ */
        @keyframes hintPulseGreen { 0%, 100% { outline-color: rgba(0, 255, 0, 0.7); box-shadow: 0 0 8px rgba(0, 255, 0, 0.4); } 50% { outline-color: rgba(150, 255, 150, 0.9); box-shadow: 0 0 15px rgba(150, 255, 150, 0.7); } }

        /* --- King Crown Style --- */
        .piece.king::after { content: 'â™•'; position: absolute; font-size: calc(var(--square-size) * 0.35); top: 50%; left: 50%; transform: translate(-50%, -50%); pointer-events: none; z-index: 11; opacity: 1; line-height: 1; text-align: center; }

        /* --- Piece Style Variations (Styles remain mostly the same, they are cosmetic) --- */
        body.piece-style-classic .piece.black-piece { background: linear-gradient(to bottom right, #444 0%, #111 100%); box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.2), 0 4px 8px rgba(0, 0, 0, 0.7); border-color: rgba(0, 0, 0, 0.2); } body.piece-style-classic .piece.white-piece { background: linear-gradient(to bottom right, #eee 0%, #ccc 100%); box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.2), 0 4px 8px rgba(0, 0, 0, 0.5); border-color: rgba(255, 255, 255, 0.3); } body.piece-style-classic .piece.selected { box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.3), 0 4px 12px rgba(0, 0, 0, 0.9), 0 0 0 5px rgba(52, 152, 219, 0.8) !important; } body.piece-style-classic .piece.white-piece.selected { box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3), 0 4px 12px rgba(0, 0, 0, 0.6), 0 0 0 5px rgba(52, 152, 219, 0.8) !important; } body.piece-style-classic .piece.hoverable:hover { box-shadow: inset 0 0 12px rgba(255, 255, 255, 0.3), 0 6px 15px rgba(0, 0, 0, 0.8); } body.piece-style-classic .piece.white-piece.hoverable:hover { box-shadow: inset 0 0 12px rgba(0, 0, 0, 0.3), 0 6px 15px rgba(0, 0, 0, 0.6); }
        body.piece-style-flat .piece { border: 1px solid rgba(0,0,0,0.3); box-shadow: none; } body.piece-style-flat .piece.black-piece { background: #2c2c2c; } body.piece-style-flat .piece.white-piece { background: #f0f0f0; } body.piece-style-flat .piece.selected { box-shadow: 0 0 0 clamp(3px, 1vmin, 5px) rgba(52, 152, 219, 0.8) !important; } body.piece-style-flat .piece.hoverable:hover { transform: translate(-50%, -50%) translateY(-3px) scale(1.04); opacity: 0.9; } /* ØªÙƒÙŠÙŠÙ Ø­Ø¬Ù… Ø§Ù„ØªØ­Ø¯ÙŠØ¯ */
        body.piece-style-crimson .piece.black-piece { background: linear-gradient(to bottom right, #b71c1c 0%, #7f0000 100%); box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.25), 0 4px 8px rgba(0, 0, 0, 0.7); border-color: rgba(50, 0, 0, 0.3); } body.piece-style-crimson .piece.white-piece { background: linear-gradient(to bottom right, #fffde7 0%, #fff8e1 100%); box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.1), 0 4px 8px rgba(0, 0, 0, 0.4); border-color: rgba(200, 190, 170, 0.4); } body.piece-style-crimson .piece.selected { box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.3), 0 4px 12px rgba(0, 0, 0, 0.9), 0 0 0 clamp(3px, 1vmin, 5px) rgba(255, 82, 82, 0.8) !important; } body.piece-style-crimson .piece.white-piece.selected { box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.2), 0 4px 12px rgba(0, 0, 0, 0.5), 0 0 0 clamp(3px, 1vmin, 5px) rgba(255, 82, 82, 0.8) !important; } body.piece-style-crimson .piece.hoverable:hover { box-shadow: inset 0 0 12px rgba(255, 255, 255, 0.3), 0 6px 15px rgba(0, 0, 0, 0.8); } body.piece-style-crimson .piece.white-piece.hoverable:hover { box-shadow: inset 0 0 12px rgba(0, 0, 0, 0.2), 0 6px 15px rgba(0, 0, 0, 0.5); } /* ØªÙƒÙŠÙŠÙ Ø­Ø¬Ù… Ø§Ù„ØªØ­Ø¯ÙŠØ¯ */
        body.piece-style-azure .piece { border: 1px solid rgba(0,0,0,0.3); box-shadow: none; } body.piece-style-azure .piece.black-piece { background: #1976d2; border-color: #0d47a1; } body.piece-style-azure .piece.white-piece { background: #e3f2fd; border-color: #90caf9; } body.piece-style-azure .piece.selected { box-shadow: 0 0 0 clamp(3px, 1vmin, 5px) rgba(66, 165, 245, 0.8) !important; } body.piece-style-azure .piece.hoverable:hover { transform: translate(-50%, -50%) translateY(-3px) scale(1.04); opacity: 0.9; } /* ØªÙƒÙŠÙŠÙ Ø­Ø¬Ù… Ø§Ù„ØªØ­Ø¯ÙŠØ¯ */
        body.piece-style-forest .piece.black-piece { background: linear-gradient(to bottom right, #388e3c 0%, #1b5e20 100%); box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.2), 0 4px 8px rgba(0, 0, 0, 0.7); border-color: rgba(0, 50, 0, 0.3); } body.piece-style-forest .piece.white-piece { background: linear-gradient(to bottom right, #f5f5dc 0%, #d2b48c 100%); box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.15), 0 4px 8px rgba(0, 0, 0, 0.4); border-color: rgba(180, 160, 130, 0.4); } body.piece-style-forest .piece.selected { box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.3), 0 4px 12px rgba(0, 0, 0, 0.9), 0 0 0 clamp(3px, 1vmin, 5px) rgba(102, 187, 106, 0.8) !important; } body.piece-style-forest .piece.white-piece.selected { box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.2), 0 4px 12px rgba(0, 0, 0, 0.5), 0 0 0 clamp(3px, 1vmin, 5px) rgba(102, 187, 106, 0.8) !important; } body.piece-style-forest .piece.hoverable:hover { box-shadow: inset 0 0 12px rgba(255, 255, 255, 0.3), 0 6px 15px rgba(0, 0, 0, 0.8); } body.piece-style-forest .piece.white-piece.hoverable:hover { box-shadow: inset 0 0 12px rgba(0, 0, 0, 0.2), 0 6px 15px rgba(0, 0, 0, 0.5); } /* ØªÙƒÙŠÙŠÙ Ø­Ø¬Ù… Ø§Ù„ØªØ­Ø¯ÙŠØ¯ */
        body.piece-style-royal .piece.black-piece { background: linear-gradient(to bottom right, #6a1b9a 0%, #4a148c 100%); box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.25), 0 4px 8px rgba(0, 0, 0, 0.7); border-color: rgba(30, 0, 50, 0.4); } body.piece-style-royal .piece.white-piece { background: linear-gradient(to bottom right, #fff59d 0%, #ffee58 100%); box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.1), 0 4px 8px rgba(0, 0, 0, 0.4); border-color: rgba(190, 180, 100, 0.5); } body.piece-style-royal .piece.selected { box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.3), 0 4px 12px rgba(0, 0, 0, 0.9), 0 0 0 clamp(3px, 1vmin, 5px) rgba(255, 238, 88, 0.8) !important; } body.piece-style-royal .piece.white-piece.selected { box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.2), 0 4px 12px rgba(0, 0, 0, 0.5), 0 0 0 clamp(3px, 1vmin, 5px) rgba(255, 238, 88, 0.8) !important; } body.piece-style-royal .piece.hoverable:hover { box-shadow: inset 0 0 12px rgba(255, 255, 255, 0.3), 0 6px 15px rgba(0, 0, 0, 0.8); } body.piece-style-royal .piece.white-piece.hoverable:hover { box-shadow: inset 0 0 12px rgba(0, 0, 0, 0.2), 0 6px 15px rgba(0, 0, 0, 0.5); } /* ØªÙƒÙŠÙŠÙ Ø­Ø¬Ù… Ø§Ù„ØªØ­Ø¯ÙŠØ¯ */

        /* --- General Piece Modifiers --- */
        .selected { z-index: 20; transform: translate(-50%, -50%) scale(1.05); outline-width: 0px !important; animation: none !important; }
        .possible-move::before { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 255, 0, 0.15); border: clamp(1px, 0.5vmin, 2px) solid rgba(0, 255, 0, 0.4); border-radius: 50%; pointer-events: none; z-index: 5; box-sizing: border-box; animation: pulsePossible 1.8s infinite ease-in-out; } /* ØªÙƒÙŠÙŠÙ Ø³Ù…Ùƒ Ø§Ù„Ø­Ø¯ÙˆØ¯ */
        @keyframes pulsePossible { 0% { transform: scale(0.5); opacity: 0.5; } 50% { transform: scale(0.7); opacity: 0.8; } 100% { transform: scale(0.5); opacity: 0.5; } }
        .hint-piece-suggestion { outline: clamp(2px, 0.8vmin, 4px) dashed #ffdd00 !important; outline-offset: 3px; animation: hintPulseYellow 1s infinite !important; z-index: 22 !important; } /* ØªÙƒÙŠÙŠÙ Ø³Ù…Ùƒ Ø§Ù„Ø®Ø· Ø§Ù„Ø®Ø§Ø±Ø¬ÙŠ */
        .hint-move-suggestion::before { background-color: rgba(255, 221, 0, 0.3) !important; border-color: #ffdd00 !important; animation: pulsePossible 1s infinite ease-in-out !important; z-index: 6 !important; }
        @keyframes hintPulseYellow { 0%, 100% { outline-color: #ffdd00; } 50% { outline-color: #fff3a0; } }
        .piece.hoverable:hover { transform: translate(-50%, -50%) translateY(-3px) scale(1.04); }

        /* --- Game Over Screen --- */
        #game-over-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle, rgba(0, 0, 0, 0.7) 0%, rgba(0, 0, 0, 0.9) 100%); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 100; text-align: center; opacity: 0; transition: opacity 0.6s ease-in-out; padding: 20px; box-sizing: border-box; } /* Ø¥Ø¶Ø§ÙØ© Ø­Ø´Ùˆ */
        #game-over-screen.visible { display: flex; opacity: 1; }
        #game-over-content {
            background-color: rgba(60, 40, 20, 0.8);
            padding: clamp(20px, 5vw, 30px) clamp(25px, 6vw, 40px); /* Ø­Ø´Ùˆ ÙŠØªÙƒÙŠÙ */
            border-radius: 15px; box-shadow: 0 5px 20px rgba(0,0,0,0.6);
            transform: scale(0.8); transition: transform 0.4s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            border: 1px solid #a07551;
            width: 90%; /* Ø¹Ø±Ø¶ Ù†Ø³Ø¨ÙŠ */
            max-width: 450px; /* Ø£Ù‚ØµÙ‰ Ø¹Ø±Ø¶ */
            box-sizing: border-box; /* ØªØ¶Ù…ÙŠÙ† Ø§Ù„Ø­Ø´Ùˆ ÙÙŠ Ø§Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø£Ù‚ØµÙ‰ */
        }
        #game-over-screen.visible #game-over-content { transform: scale(1); }
        #game-over-message { font-size: clamp(1.4em, 5vh, 2.2em); color: #fff; text-shadow: 1px 1px 0px #ffeb3b, 3px 3px 5px rgba(0,0,0,0.7); margin-bottom: clamp(20px, 4vh, 25px); font-weight: 700; word-break: break-word; } /* ØªÙƒÙŠÙŠÙ Ø­Ø¬Ù… Ø§Ù„Ø®Ø· ÙˆØ§Ù„Ù‡Ø§Ù…Ø´ ÙˆÙƒØ³Ø± Ø§Ù„ÙƒÙ„Ù…Ø© */
        #game-over-message::before { content: 'ğŸ†'; display: block; font-size: clamp(1.5em, 6vh, 2em); margin-bottom: 10px; text-shadow: 0 0 10px #ffd700; } /* ØªÙƒÙŠÙŠÙ Ø­Ø¬Ù… Ø§Ù„Ø£ÙŠÙ‚ÙˆÙ†Ø© */
        #back-to-menu-button {
             font-family: 'Roboto', 'Cairo', sans-serif;
             font-size: clamp(1em, 3vh, 1.1em); /* ØªÙƒÙŠÙŠÙ Ø­Ø¬Ù… Ø§Ù„Ø®Ø· */
             padding: clamp(8px, 2vh, 10px) clamp(20px, 5vw, 25px); /* ØªÙƒÙŠÙŠÙ Ø§Ù„Ø­Ø´Ùˆ */
             cursor: pointer; border: none; border-radius: 8px;
             background: linear-gradient(to bottom, #e0d6c8, #c1b2a3); color: #321e06; font-weight: bold;
             box-shadow: 0 3px 5px rgba(0,0,0,0.25), inset 0 -2px 1px rgba(0,0,0,0.1);
             transition: all 0.2s ease;
             width: 80%; /* Ø¹Ø±Ø¶ Ù†Ø³Ø¨ÙŠ */
             max-width: 250px; /* Ø£Ù‚ØµÙ‰ Ø¹Ø±Ø¶ */
             margin: 0 auto; /* ØªÙˆØ³ÙŠØ· Ø§Ù„Ø²Ø± */
             display: block; /* Ø¶Ù…Ø§Ù† Ø£Ù†Ù‡ ÙŠØ£Ø®Ø° Ø§Ù„Ø³Ø·Ø± Ø§Ù„Ø®Ø§Øµ Ø¨Ù‡ */
             box-sizing: border-box;
        }
        #back-to-menu-button:hover { background: linear-gradient(to bottom, #f7f2e8, #e8e0d0); box-shadow: 0 4px 7px rgba(0,0,0,0.3), inset 0 -2px 1px rgba(0,0,0,0.1); transform: translateY(-1px); }
        #back-to-menu-button:active { transform: translateY(0px); box-shadow: 0 2px 4px rgba(0,0,0,0.25), inset 0 -1px 1px rgba(0,0,0,0.15); }

        /* --- Settings Button & Panel Styles --- */
        #settings-button { position: fixed; top: clamp(10px, 2vw, 15px); right: clamp(10px, 2vw, 15px); z-index: 110; font-size: clamp(1.5em, 3vw, 1.8em); background: none; border: none; color: rgba(255, 255, 255, 0.7); cursor: pointer; padding: 5px; transition: color 0.2s ease, transform 0.2s ease; } /* ØªÙƒÙŠÙŠÙ Ø§Ù„Ù…ÙˆØ¶Ø¹ ÙˆØ§Ù„Ø­Ø¬Ù… */
        #settings-button:hover { color: rgba(255, 255, 255, 1); transform: rotate(15deg); }
        #settings-panel {
             position: fixed; top: clamp(50px, 8vw, 60px); right: clamp(10px, 2vw, 15px); transform: none;
             background-color: rgba(40, 25, 10, 0.9);
             padding: clamp(10px, 2vw, 15px); /* ØªÙƒÙŠÙŠÙ Ø§Ù„Ø­Ø´Ùˆ */
             border-radius: 10px; box-shadow: 0 5px 10px rgba(0, 0, 0, 0.4); z-index: 115; display: none;
             flex-direction: column; align-items: center;
             gap: clamp(8px, 1.5vw, 10px); /* ØªÙƒÙŠÙŠÙ Ø§Ù„ÙØ¬ÙˆØ© */
             border: 1px solid #7a542e;
             max-height: calc(100vh - clamp(65px, 10vw, 80px)); /* ØªÙƒÙŠÙŠÙ Ø§Ù„Ø§Ø±ØªÙØ§Ø¹ Ø§Ù„Ø£Ù‚ØµÙ‰ */
             overflow-y: auto;
             box-sizing: border-box;
             width: auto; /* Ø§Ù„Ø³Ù…Ø§Ø­ Ù„Ù„Ø¹Ø±Ø¶ Ø¨Ø§Ù„ØªÙƒÙŠÙ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø­ØªÙˆÙ‰ */
             min-width: 120px; /* Ø­Ø¯ Ø£Ø¯Ù†Ù‰ Ù…Ø¹Ù‚ÙˆÙ„ */
        }
        #settings-panel.visible { display: flex; }
        #settings-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: transparent; z-index: 114; display: none; }
        .settings-icon-button {
             display: flex; align-items: center; justify-content: center;
             width: clamp(35px, 6vw, 45px); /* ØªÙƒÙŠÙŠÙ Ø§Ù„Ø­Ø¬Ù… */
             height: clamp(35px, 6vw, 45px); /* ØªÙƒÙŠÙŠÙ Ø§Ù„Ø­Ø¬Ù… */
             font-size: clamp(1.1em, 2vw, 1.3em); /* ØªÙƒÙŠÙŠÙ Ø­Ø¬Ù… Ø§Ù„Ø®Ø· */
             border: none; border-radius: 8px; cursor: pointer;
             background: linear-gradient(to bottom, #966f4d, #7a542e); color: #ffffff; box-shadow: 0 2px 4px rgba(0,0,0,0.3);
             transition: all 0.2s ease; text-align: center; flex-shrink: 0;
        }
        .settings-icon-button:hover { background: linear-gradient(to bottom, #a07551, #8b5e3c); box-shadow: 0 3px 6px rgba(0,0,0,0.4); transform: translateY(-1px); }
        .settings-icon-button:active { transform: translateY(0); box-shadow: 0 1px 3px rgba(0,0,0,0.3); }
        .settings-icon-button:disabled { background: #aaa; color: #666; cursor: not-allowed; box-shadow: 0 1px 2px rgba(0,0,0,0.2); transform: none; }
        .settings-icon-button i { /* Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„Ø£ÙŠÙ‚ÙˆÙ†Ø§Øª Ø¯Ø§Ø®Ù„ Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ù„Ø§ ØªØ³Ø¨Ø¨ ØªØ¬Ø§ÙˆØ²Ù‹Ø§ */
            display: block;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #sound-toggle-button.sound-off { background: linear-gradient(to bottom, #c1b2a3, #a39588); color: #321e06; }
        #sound-toggle-button.sound-off:hover { background: linear-gradient(to bottom, #d0c5b8, #b8a99a); }
        #timer-toggle-button.timer-off { background: linear-gradient(to bottom, #c1b2a3, #a39588); color: #321e06; }
        #timer-toggle-button.timer-off:hover { background: linear-gradient(to bottom, #d0c5b8, #b8a99a); }
         #undo-button, #hint-button { /* Ø¶Ø¨Ø· Ø­Ø¬Ù… Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ù…Ø­Ø¯Ø¯Ø© Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø± */
            /* Ù„Ø§ ØªØ­ØªØ§Ø¬ Ù„ØªØ¹Ø¯ÙŠÙ„ Ø¥Ø¶Ø§ÙÙŠ Ø¥Ø°Ø§ ÙƒØ§Ù† .settings-icon-button Ø´Ø§Ù…Ù„Ù‹Ø§ */
         }


        /* --- Overlay Screen Styles (Board/Piece selection) --- */
        .overlay-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.85); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 150; opacity: 0; transition: opacity 0.4s ease-in-out; padding: clamp(10px, 3vh, 30px); box-sizing: border-box; overflow-y: auto; /* Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„ØªÙ…Ø±ÙŠØ± Ø¥Ø°Ø§ ØªØ¬Ø§ÙˆØ² Ø§Ù„Ù…Ø­ØªÙˆÙ‰ */ } /* ØªÙƒÙŠÙŠÙ Ø§Ù„Ø­Ø´Ùˆ ÙˆØ§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„ØªÙ…Ø±ÙŠØ± */
        .overlay-screen.visible { display: flex; opacity: 1; }
        .selection-content {
            background-color: rgba(60, 40, 20, 0.9);
            padding: clamp(20px, 4vw, 25px) clamp(25px, 5vw, 35px); /* Ø­Ø´Ùˆ ÙŠØªÙƒÙŠÙ */
            border-radius: 15px; box-shadow: 0 6px 25px rgba(0,0,0,0.6); text-align: center;
            width: 90%; /* Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¹Ø±Ø¶ Ù†Ø³Ø¨ÙŠ */
            max-width: 700px; /* ØªØ­Ø¯ÙŠØ¯ Ø£Ù‚ØµÙ‰ Ø¹Ø±Ø¶ */
            transform: scale(0.9); transition: transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            border: 1px solid #966f4d; margin: 10px auto; /* ØªÙˆØ³ÙŠØ· Ø±Ø£Ø³ÙŠ ÙˆØ£ÙÙ‚ÙŠ Ù…Ø¹ Ù‡Ø§Ù…Ø´ */
            display: flex; flex-direction: column;
            max-height: 90vh; /* Ø§Ø±ØªÙØ§Ø¹ Ø£Ù‚ØµÙ‰ ÙŠØªÙƒÙŠÙ Ù…Ø¹ Ø§Ù„Ø´Ø§Ø´Ø© */
            box-sizing: border-box;
        }
        #confirmation-modal .selection-content { width: 90%; max-width: 450px; max-height: none; display: block; margin: auto; } /* Ø¶Ø¨Ø· Ø®Ø§Øµ Ø¨Ø§Ù„Ù†Ø§ÙØ°Ø© Ø§Ù„Ù…Ù†Ø¨Ø«Ù‚Ø© */
        .overlay-screen.visible .selection-content { transform: scale(1); }
        .selection-content h2 { font-size: clamp(1.4em, 4vh, 1.8em); color: #f0e5d1; margin-top: 0; margin-bottom: clamp(15px, 3vh, 20px); text-shadow: 1px 1px 3px rgba(0,0,0,0.5); flex-shrink: 0; word-break: break-word; padding: 0 5px; } /* ØªÙƒÙŠÙŠÙ Ø­Ø¬Ù… Ø§Ù„Ø®Ø· ÙˆØ§Ù„Ù‡Ø§Ù…Ø´ ÙˆÙƒØ³Ø± Ø§Ù„ÙƒÙ„Ù…Ø© */
        .options-container {
            display: grid;
            /* Ø§Ø³ØªØ®Ø¯Ø§Ù… minmax Ù…Ø¹ vw Ù„ØªÙƒÙŠÙŠÙ Ø­Ø¬Ù… Ø§Ù„Ø£Ø¹Ù…Ø¯Ø© */
            grid-template-columns: repeat(auto-fit, minmax(clamp(90px, 15vw, 120px), 1fr));
            gap: clamp(10px, 2vw, 20px); /* ØªÙƒÙŠÙŠÙ Ø§Ù„ÙØ¬ÙˆØ© */
            margin-bottom: clamp(15px, 3vh, 20px); /* ØªÙƒÙŠÙŠÙ Ø§Ù„Ù‡Ø§Ù…Ø´ */
            overflow-y: auto; /* Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„ØªÙ…Ø±ÙŠØ± Ø¯Ø§Ø®Ù„ Ø§Ù„Ø­Ø§ÙˆÙŠØ© */
            flex-shrink: 1; flex-grow: 1;
            padding: 5px clamp(8px, 1.5vw, 15px) clamp(10px, 2vh, 15px) 5px; /* Ø­Ø´Ùˆ Ù„ scrollbar */
            scrollbar-width: thin; scrollbar-color: #966f4d rgba(0,0,0,0.2);
        }
        .options-container::-webkit-scrollbar { width: 8px; }
        .options-container::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); border-radius: 4px; }
        .options-container::-webkit-scrollbar-thumb { background-color: #966f4d; border-radius: 4px; border: 2px solid transparent; background-clip: content-box;}
        .option-button {
             font-family: 'Roboto', 'Cairo', sans-serif; cursor: pointer; border: 2px solid #7a542e; border-radius: 8px;
             background-color: rgba(255, 255, 255, 0.05);
             padding: clamp(8px, 1.5vw, 10px); /* ØªÙƒÙŠÙŠÙ Ø§Ù„Ø­Ø´Ùˆ */
             transition: all 0.2s ease; display: flex; flex-direction: column; align-items: center;
             color: #e0d6c8;
             font-size: clamp(0.8em, 2vw, 0.9em); /* ØªÙƒÙŠÙŠÙ Ø­Ø¬Ù… Ø§Ù„Ø®Ø· */
             min-height: clamp(90px, 15vw, 110px); /* ØªÙƒÙŠÙŠÙ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ù„Ù„Ø§Ø±ØªÙØ§Ø¹ */
             justify-content: space-between;
             box-sizing: border-box;
        }
        .option-button:hover { background-color: rgba(255, 255, 255, 0.15); border-color: #a07551; transform: translateY(-3px); box-shadow: 0 4px 8px rgba(0,0,0,0.3); }
        .option-button.selected-style { border-color: #ffd700; background-color: rgba(255, 215, 0, 0.15); box-shadow: 0 0 10px rgba(255, 215, 0, 0.4); }
        .close-selection-button {
             font-family: 'Roboto', 'Cairo', sans-serif;
             font-size: clamp(1em, 2.5vh, 1.1em); /* ØªÙƒÙŠÙŠÙ Ø­Ø¬Ù… Ø§Ù„Ø®Ø· */
             padding: clamp(10px, 2vh, 12px) clamp(20px, 5vw, 28px); /* ØªÙƒÙŠÙŠÙ Ø§Ù„Ø­Ø´Ùˆ */
             cursor: pointer; border: none; border-radius: 10px;
             background: linear-gradient(to bottom, #e0d6c8, #c1b2a3); color: #321e06; font-weight: bold;
             box-shadow: 0 3px 5px rgba(0,0,0,0.25), inset 0 -2px 1px rgba(0,0,0,0.1);
             transition: all 0.2s ease; margin-top: auto; flex-shrink: 0;
             width: 80%; /* Ø¹Ø±Ø¶ Ù†Ø³Ø¨ÙŠ */
             max-width: 300px; /* Ø£Ù‚ØµÙ‰ Ø¹Ø±Ø¶ */
             align-self: center; /* ØªÙˆØ³ÙŠØ· Ø§Ù„Ø²Ø± Ø¯Ø§Ø®Ù„ flex container */
             box-sizing: border-box;
        }
        #confirmation-buttons button { margin-top: 0; width: 90%; max-width: 250px; } /* ØªÙƒÙŠÙŠÙ Ø¹Ø±Ø¶ Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø¯Ø§Ø®Ù„ Ù†Ø§ÙØ°Ø© Ø§Ù„ØªØ£ÙƒÙŠØ¯ */
        .close-selection-button:hover { background: linear-gradient(to bottom, #f7f2e8, #e8e0d0); box-shadow: 0 4px 7px rgba(0,0,0,0.3), inset 0 -2px 1px rgba(0,0,0,0.1); transform: translateY(-2px); }
        .close-selection-button:active { transform: translateY(0px); box-shadow: 0 2px 4px rgba(0,0,0,0.25), inset 0 -1px 1px rgba(0,0,0,0.15); }

        /* --- Board Selection Screen --- */
        .board-preview {
             width: clamp(40px, 8vw, 50px); /* ØªÙƒÙŠÙŠÙ Ø§Ù„Ø­Ø¬Ù… */
             height: clamp(40px, 8vw, 50px); /* ØªÙƒÙŠÙŠÙ Ø§Ù„Ø­Ø¬Ù… */
             display: grid; grid-template-columns: repeat(2, 1fr); grid-template-rows: repeat(2, 1fr);
             border: 1px solid rgba(0,0,0,0.3); margin-bottom: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.2);
             border-radius: 3px; overflow: hidden; flex-shrink: 0; /* Ù…Ù†Ø¹ Ø§Ù„Ø§Ù†ÙƒÙ…Ø§Ø´ */
        }
        .board-preview .sq { width: 100%; height: 100%; }
        /* Board preview colors (remain the same) */
        .board-preview-wood .light { background-color: #DEB887; } .board-preview-wood .dark { background-color: #A0522D; }
        .board-preview-desert .light { background-color: #f4a460; } .board-preview-desert .dark { background-color: #8b4513; }
        .board-preview-stone-path .light { background-color: #e0e0e0; } .board-preview-stone-path .dark { background-color: #616161; }
        .board-preview-emerald .light { background-color: #e0f2f1; } .board-preview-emerald .dark { background-color: #00695c; }
        .board-preview-volcano .light { background-color: #d3d3d3; } .board-preview-volcano .dark { background-color: #dc143c; }
        .board-preview-royal .light { background-color: #fffacd; } .board-preview-royal .dark { background-color: #4b0082; }

        /* --- Board Styles (Borders adapted using clamp) --- */
        #board.board-style-wood { border-color: #8B4513; } #board.board-style-wood .light-square { background: #DEB887; box-shadow: inset 1px 1px 3px rgba(255, 255, 255, 0.3); } #board.board-style-wood .dark-square { background: #A0522D; box-shadow: inset 1px 1px 4px rgba(0, 0, 0, 0.6); cursor: pointer; } #board.board-style-wood .dark-square:hover:not(:has(.piece)):not(.possible-move) { background: #b3623f; }
        #board.board-style-desert { border-color: #a0522d; background-color: #cd853f; } #board.board-style-desert .light-square { background: linear-gradient(135deg, #f4a460 0%, #deb887 100%); box-shadow: inset 1px 1px 3px rgba(255, 255, 255, 0.25); } #board.board-style-desert .dark-square { background: linear-gradient(135deg, #8b4513 0%, #a0522d 100%); box-shadow: inset 1px 1px 4px rgba(0, 0, 0, 0.5); cursor: pointer; } #board.board-style-desert .dark-square:hover:not(:has(.piece)):not(.possible-move) { background: linear-gradient(135deg, #9e5624 0%, #b3623f 100%); }
        #board.board-style-stone-path { border-color: #5d4037; background-color: #795548; } #board.board-style-stone-path .light-square { background: linear-gradient(135deg, #e0e0e0 0%, #bdbdbd 100%); box-shadow: inset 1px 1px 3px rgba(255, 255, 255, 0.2); } #board.board-style-stone-path .dark-square { background: linear-gradient(135deg, #616161 0%, #424242 100%); box-shadow: inset 1px 1px 4px rgba(0, 0, 0, 0.5); cursor: pointer; } #board.board-style-stone-path .dark-square:hover:not(:has(.piece)):not(.possible-move) { background: linear-gradient(135deg, #757575 0%, #5a5a5a 100%); }
        #board.board-style-emerald { border-color: #004d40; background-color: #00695c; } #board.board-style-emerald .light-square { background: linear-gradient(135deg, #e0f2f1 0%, #ffffff 100%); box-shadow: inset 1px 1px 3px rgba(0, 0, 0, 0.1); } #board.board-style-emerald .dark-square { background: linear-gradient(135deg, #00695c 0%, #004d40 100%); box-shadow: inset 1px 1px 4px rgba(0, 0, 0, 0.6); cursor: pointer; } #board.board-style-emerald .dark-square:hover:not(:has(.piece)):not(.possible-move) { background: linear-gradient(135deg, #00796b 0%, #005f51 100%); }
        #board.board-style-volcano { border-color: #696969; background-color: #8B0000; } #board.board-style-volcano .light-square { background: linear-gradient(135deg, #d3d3d3 0%, #f5f5f5 100%); box-shadow: inset 1px 1px 2px rgba(0, 0, 0, 0.1); } #board.board-style-volcano .dark-square { background: linear-gradient(135deg, #dc143c 0%, #b22222 100%); box-shadow: inset 1px 1px 4px rgba(0, 0, 0, 0.5); cursor: pointer; } #board.board-style-volcano .dark-square:hover:not(:has(.piece)):not(.possible-move) { background: linear-gradient(135deg, #e82e4f 0%, #c53030 100%); }
        #board.board-style-royal { border-color: #483d8b; background-color: #6a5acd; } #board.board-style-royal .light-square { background: linear-gradient(135deg, #fffacd 0%, #eee8aa 100%); box-shadow: inset 1px 1px 3px rgba(0, 0, 0, 0.15); } #board.board-style-royal .dark-square { background: linear-gradient(135deg, #4b0082 0%, #8a2be2 100%); box-shadow: inset 1px 1px 4px rgba(0, 0, 0, 0.6); cursor: pointer; } #board.board-style-royal .dark-square:hover:not(:has(.piece)):not(.possible-move) { background: linear-gradient(135deg, #5c1092 0%, #9d3fe5 100%); }

        /* Piece Selection Screen specific styles */
        #piece-options-container { grid-template-columns: repeat(auto-fit, minmax(clamp(80px, 14vw, 100px), 1fr)); } /* ØªÙƒÙŠÙŠÙ Ø­Ø¬Ù… Ø§Ù„Ø£Ø¹Ù…Ø¯Ø© */
        .piece-preview-container { display: flex; justify-content: center; align-items: center; gap: clamp(5px, 1.5vw, 8px); margin-bottom: 10px; width: 100%; height: clamp(35px, 6vw, 45px); flex-shrink: 0; } /* ØªÙƒÙŠÙŠÙ Ø§Ù„Ø­Ø¬Ù… ÙˆØ§Ù„ÙØ¬ÙˆØ© */
        .piece-preview {
             width: clamp(28px, 5vw, 35px); /* ØªÙƒÙŠÙŠÙ Ø§Ù„Ø­Ø¬Ù… */
             height: clamp(28px, 5vw, 35px); /* ØªÙƒÙŠÙŠÙ Ø§Ù„Ø­Ø¬Ù… */
             border-radius: 50%; border: 1px solid rgba(0,0,0,0.2); box-shadow: 0 1px 2px rgba(0,0,0,0.3);
             position: relative; display: flex; align-items: center; justify-content: center; flex-shrink: 0;
        }
        /* Piece preview colors (remain the same) */
         .piece-preview.black.classic { background: linear-gradient(to bottom right, #444 0%, #111 100%); box-shadow: inset 0 0 5px rgba(255, 255, 255, 0.1), 0 2px 4px rgba(0, 0, 0, 0.5); border-color: rgba(0, 0, 0, 0.2); } .piece-preview.white.classic { background: linear-gradient(to bottom right, #eee 0%, #ccc 100%); box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.1), 0 2px 4px rgba(0, 0, 0, 0.3); border-color: rgba(255, 255, 255, 0.3); }
         .piece-preview.black.flat { background: #2c2c2c; border: 1px solid #555; box-shadow: none; } .piece-preview.white.flat { background: #f0f0f0; border: 1px solid #ccc; box-shadow: none; }
         .piece-preview.black.crimson { background: linear-gradient(to bottom right, #b71c1c 0%, #7f0000 100%); border-color: rgba(50, 0, 0, 0.3); } .piece-preview.white.crimson { background: linear-gradient(to bottom right, #fffde7 0%, #fff8e1 100%); border-color: rgba(200, 190, 170, 0.4); }
         .piece-preview.black.azure { background: #1976d2; border-color: #0d47a1; box-shadow: none; } .piece-preview.white.azure { background: #e3f2fd; border-color: #90caf9; box-shadow: none; }
         .piece-preview.black.forest { background: linear-gradient(to bottom right, #388e3c 0%, #1b5e20 100%); border-color: rgba(0, 50, 0, 0.3); } .piece-preview.white.forest { background: linear-gradient(to bottom right, #f5f5dc 0%, #d2b48c 100%); border-color: rgba(180, 160, 130, 0.4); }
         .piece-preview.black.royal { background: linear-gradient(to bottom right, #6a1b9a 0%, #4a148c 100%); border-color: rgba(30, 0, 50, 0.4); } .piece-preview.white.royal { background: linear-gradient(to bottom right, #fff59d 0%, #ffee58 100%); border-color: rgba(190, 180, 100, 0.5); }

        /* Confirmation Modal Styles */
        #confirmation-modal .selection-content {
             width: 90%; /* Ø¹Ø±Ø¶ Ù†Ø³Ø¨ÙŠ */
             max-width: 450px; /* Ø£Ù‚ØµÙ‰ Ø¹Ø±Ø¶ */
             padding: clamp(25px, 5vw, 30px) clamp(20px, 4vw, 35px); /* Ø­Ø´Ùˆ ÙŠØªÙƒÙŠÙ */
             border-width: 2px; border-color: #b58863; background-color: #4a311c;
             box-shadow: 0 10px 30px rgba(0,0,0,0.6); max-height: none; display: block; margin: auto; /* ØªÙˆØ³ÙŠØ· */
             box-sizing: border-box;
        }
        #confirmation-message { font-size: clamp(1.1em, 3vh, 1.3em); color: #f0e5d1; margin-bottom: clamp(20px, 4vh, 35px); line-height: 1.6; text-shadow: 1px 1px 3px rgba(0,0,0,0.6); word-break: break-word; } /* ØªÙƒÙŠÙŠÙ Ø­Ø¬Ù… Ø§Ù„Ø®Ø· ÙˆØ§Ù„Ù‡Ø§Ù…Ø´ ÙˆÙƒØ³Ø± Ø§Ù„ÙƒÙ„Ù…Ø© */
        #confirmation-buttons { display: flex; flex-direction: column; align-items: center; margin-top: 20px; gap: clamp(10px, 2vh, 15px); } /* ØªÙƒÙŠÙŠÙ Ø§Ù„ÙØ¬ÙˆØ© */
        #confirmation-buttons button { width: 80%; max-width: 250px; margin-top: 0; } /* ØªÙƒÙŠÙŠÙ Ø¹Ø±Ø¶ Ø§Ù„Ø£Ø²Ø±Ø§Ø± */
        #confirm-logout-button { background: linear-gradient(to bottom, #b75656, #913434); color: #ffffff; text-shadow: 1px 1px 2px rgba(0,0,0,0.4); border: 1px solid #7a2a2a; }
        #confirm-logout-button:hover { background: linear-gradient(to bottom, #c96e6e, #a04a4a); border-color: #8b3a3a; }

        /* --- Media Queries (ØªØ¹Ø¯ÙŠÙ„Ø§Øª Ø¨Ø³ÙŠØ·Ø© Ø¹Ù„Ù‰ Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø§Ù„ÙˆØ³Ø§Ø¦Ø· Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø© Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… clamp) --- */
         /* Ø£Ø­Ø¬Ø§Ù… Ø´Ø§Ø´Ø© Ù…ØªÙˆØ³Ø·Ø© */
         @media (max-height: 850px), (max-width: 700px) {
             /* Ø­Ø¬Ù… Ø§Ù„Ù…Ø±Ø¨Ø¹ ÙÙŠ Ø§Ù„Ù„ÙˆØ­Ø© ÙŠØªÙ… Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹Ù‡ Ø¨ÙˆØ§Ø³Ø·Ø© clamp ÙÙŠ Ø§Ù„Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© Ù„Ù„ÙˆØ­Ø© */
             .selection-content { max-width: 650px; max-height: 85vh; } /* ØªÙ‚Ù„ÙŠÙ„ Ø£Ù‚ØµÙ‰ Ø¹Ø±Ø¶ ÙˆØ§Ø±ØªÙØ§Ø¹ */
             .options-container {
                 /* Ø­Ø¬Ù… Ø§Ù„Ø£Ø¹Ù…Ø¯Ø© ÙŠØªÙ… Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹Ù‡ Ø¨ÙˆØ§Ø³Ø·Ø© clamp ÙÙŠ Ø§Ù„Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© */
                 gap: clamp(10px, 2vw, 15px); /* ØªÙƒÙŠÙŠÙ Ø§Ù„ÙØ¬ÙˆØ© */
             }
             /* Ø´Ø±ÙŠØ· Ø§Ù„Ø­Ø§Ù„Ø© ÙŠØªÙ… Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹Ù‡ Ø¨ÙˆØ§Ø³Ø·Ø© clamp ÙÙŠ Ø§Ù„Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© */
         }

         /* Ø£Ø­Ø¬Ø§Ù… Ø´Ø§Ø´Ø© ØµØºÙŠØ±Ø© */
         @media (max-height: 680px), (max-width: 550px) {
             /* Ø­Ø¬Ù… Ø§Ù„Ù…Ø±Ø¨Ø¹ ÙÙŠ Ø§Ù„Ù„ÙˆØ­Ø© ÙŠØªÙ… Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹Ù‡ Ø¨ÙˆØ§Ø³Ø·Ø© clamp ÙÙŠ Ø§Ù„Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© Ù„Ù„ÙˆØ­Ø© */
             .selection-content { max-width: 95%; padding: clamp(15px, 3vw, 20px); max-height: 85vh; } /* ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø­Ø´Ùˆ Ø£ÙƒØ«Ø± */
             #confirmation-modal .selection-content { max-width: 95%; padding: clamp(20px, 4vw, 25px) clamp(15px, 3vw, 20px); max-height: none; } /* ØªÙ‚Ù„ÙŠÙ„ Ø­Ø´Ùˆ Ù†Ø§ÙØ°Ø© Ø§Ù„ØªØ£ÙƒÙŠØ¯ */
             .options-container {
                 /* Ø­Ø¬Ù… Ø§Ù„Ø£Ø¹Ù…Ø¯Ø© ÙŠØªÙ… Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹Ù‡ Ø¨ÙˆØ§Ø³Ø·Ø© clamp ÙÙŠ Ø§Ù„Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© */
                 gap: clamp(8px, 1.5vw, 15px); /* ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„ÙØ¬ÙˆØ© Ø£ÙƒØ«Ø± */
             }
             .option-button { min-height: clamp(80px, 13vw, 90px); } /* ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ù„Ù„Ø§Ø±ØªÙØ§Ø¹ */
             .board-preview { width: clamp(35px, 7vw, 40px); height: clamp(35px, 7vw, 40px); } /* ØªÙ‚Ù„ÙŠÙ„ Ø­Ø¬Ù… Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© */
             .piece-preview { width: clamp(25px, 4vw, 28px); height: clamp(25px, 4vw, 28px); } /* ØªÙ‚Ù„ÙŠÙ„ Ø­Ø¬Ù… Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© */
             .piece-preview-container { height: clamp(30px, 5vw, 35px); gap: clamp(4px, 1vw, 8px); } /* ØªÙ‚Ù„ÙŠÙ„ Ø§Ø±ØªÙØ§Ø¹ Ø§Ù„Ø­Ø§ÙˆÙŠØ© ÙˆØ§Ù„ÙØ¬ÙˆØ© */
             .selection-content h2 { font-size: clamp(1.3em, 3.5vh, 1.5em); margin-bottom: clamp(10px, 2vh, 15px); } /* ØªÙƒÙŠÙŠÙ Ø­Ø¬Ù… Ø§Ù„Ø®Ø· ÙˆØ§Ù„Ù‡Ø§Ù…Ø´ */
             .close-selection-button { font-size: clamp(0.9em, 2vh, 1em); padding: clamp(8px, 1.5vh, 10px) clamp(15px, 3vw, 24px); } /* ØªÙƒÙŠÙŠÙ Ø­Ø¬Ù… Ø§Ù„Ø®Ø· ÙˆØ§Ù„Ø­Ø´Ùˆ */

             /* Ø´Ø±ÙŠØ· Ø§Ù„Ø­Ø§Ù„Ø©: ÙŠØªÙ… Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹Ù‡ Ø¨ÙˆØ§Ø³Ø·Ø© clamp ÙÙŠ Ø§Ù„Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©ØŒ Ø§Ù„ØªØ±ØªÙŠØ¨ ÙŠØ¨Ù‚Ù‰ ÙƒÙ…Ø§ Ù‡Ùˆ */
         }

        /* Ø£Ø­Ø¬Ø§Ù… Ø´Ø§Ø´Ø© ØµØºÙŠØ±Ø© Ø¬Ø¯Ù‹Ø§ */
         @media (max-height: 600px), (max-width: 450px) {
             /* Ø­Ø¬Ù… Ø§Ù„Ù…Ø±Ø¨Ø¹ ÙÙŠ Ø§Ù„Ù„ÙˆØ­Ø© ÙŠØªÙ… Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹Ù‡ Ø¨ÙˆØ§Ø³Ø·Ø© clamp ÙÙŠ Ø§Ù„Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© Ù„Ù„ÙˆØ­Ø© */
             .selection-content { padding: clamp(10px, 2vw, 15px); max-height: 85vh; } /* ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø­Ø´Ùˆ Ø£ÙƒØ«Ø± */
             .options-container {
                 grid-template-columns: repeat(auto-fit, minmax(clamp(80px, 18vw, 100px), 1fr)); /* Adjust min column width for very small screens */
                 gap: clamp(5px, 1vw, 10px); /* ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„ÙØ¬ÙˆØ© Ø£ÙƒØ«Ø± */
                 padding: 5px clamp(5px, 1vw, 8px) clamp(8px, 1.5vh, 10px) 5px; /* Ø­Ø´Ùˆ Ù„ scrollbar */
            }
             .option-button { padding: clamp(5px, 1vw, 6px); font-size: clamp(0.7em, 1.8vw, 0.8em); min-height: clamp(70px, 16vw, 80px); } /* ØªÙƒÙŠÙŠÙ Ø­Ø¬Ù… Ø§Ù„Ø®Ø· ÙˆØ§Ù„Ø­Ø´Ùˆ ÙˆØ§Ù„Ø§Ø±ØªÙØ§Ø¹ */
             .board-preview { width: clamp(30px, 6vw, 35px); height: clamp(30px, 6vw, 35px); margin-bottom: 5px; } /* ØªÙ‚Ù„ÙŠÙ„ Ø­Ø¬Ù… Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© ÙˆØ§Ù„Ù‡Ø§Ù…Ø´ */
             .piece-preview { width: clamp(22px, 4vw, 25px); height: clamp(22px, 4vw, 25px); } /* ØªÙ‚Ù„ÙŠÙ„ Ø­Ø¬Ù… Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© */
             .piece-preview-container { height: clamp(25px, 4vw, 30px); gap: clamp(3px, 0.8vw, 5px); margin-bottom: 5px;} /* ØªÙ‚Ù„ÙŠÙ„ Ø§Ø±ØªÙØ§Ø¹ Ø§Ù„Ø­Ø§ÙˆÙŠØ© ÙˆØ§Ù„ÙØ¬ÙˆØ© ÙˆØ§Ù„Ù‡Ø§Ù…Ø´ */
             .selection-content h2 { font-size: clamp(1.1em, 3vh, 1.3em); margin-bottom: clamp(8px, 1.5vh, 10px); } /* ØªÙƒÙŠÙŠÙ Ø­Ø¬Ù… Ø§Ù„Ø®Ø· ÙˆØ§Ù„Ù‡Ø§Ù…Ø´ */
             .close-selection-button { font-size: clamp(0.8em, 1.8vh, 0.9em); padding: clamp(6px, 1.2vh, 8px) clamp(12px, 2.5vw, 20px); } /* ØªÙƒÙŠÙŠÙ Ø­Ø¬Ù… Ø§Ù„Ø®Ø· ÙˆØ§Ù„Ø­Ø´Ùˆ */
             #confirmation-modal .selection-content { padding: clamp(15px, 3vw, 20px) clamp(10px, 2vw, 15px); max-height: none;} /* ØªÙ‚Ù„ÙŠÙ„ Ø­Ø´Ùˆ Ù†Ø§ÙØ°Ø© Ø§Ù„ØªØ£ÙƒÙŠØ¯ */
             #confirmation-message { font-size: clamp(0.9em, 2.5vh, 1.1em); margin-bottom: clamp(15px, 3vh, 20px); } /* ØªÙƒÙŠÙŠÙ Ø­Ø¬Ù… Ø§Ù„Ø®Ø· ÙˆØ§Ù„Ù‡Ø§Ù…Ø´ */
             #confirmation-buttons { gap: clamp(8px, 1.5vh, 15px); } /* ØªÙƒÙŠÙŠÙ Ø§Ù„ÙØ¬ÙˆØ© */
             #confirmation-buttons button { font-size: clamp(0.8em, 1.8vh, 0.9em); padding: clamp(6px, 1.2vh, 8px) clamp(12px, 2.5vw, 18px);} /* ØªÙƒÙŠÙŠÙ Ø­Ø¬Ù… Ø§Ù„Ø®Ø· ÙˆØ§Ù„Ø­Ø´Ùˆ */

             /* Ø´Ø±ÙŠØ· Ø§Ù„Ø­Ø§Ù„Ø© */
             #status-bar {
                 /* Ø­Ø¬Ù… Ø§Ù„Ø®Ø· ÙˆØ§Ù„ÙØ¬ÙˆØ© ÙŠØªÙ… Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹Ù‡Ù…Ø§ Ø¨ÙˆØ§Ø³Ø·Ø© clamp ÙÙŠ Ø§Ù„Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© */
                 min-width: unset; /* Ø¥Ø²Ø§Ù„Ø© min-width Ø§Ù„Ø«Ø§Ø¨Øª Ù„Ù„Ø³Ù…Ø§Ø­ Ù„Ù‡ Ø¨Ø§Ù„Ø§Ù†ÙƒÙ…Ø§Ø´ Ø£ÙƒØ«Ø± Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø± */
                 flex-direction: row; /* Ø¥Ø¨Ù‚Ø§Ø¤Ù‡ ÙÙŠ ØµÙ ÙˆØ§Ø­Ø¯ Ù…Ø§ Ù„Ù… ÙŠÙ„ØªÙ */
                 gap: clamp(3px, 1vw, 5px); /* ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„ÙØ¬ÙˆØ© Ø£ÙƒØ«Ø± */
             }
             .status-section.capture-count {
                 min-width: unset; /* Ø¥Ø²Ø§Ù„Ø© min-width Ø§Ù„Ø«Ø§Ø¨Øª Ù„Ù„Ø³Ù…Ø§Ø­ Ù„Ù‡ Ø¨Ø§Ù„Ø§Ù†ÙƒÙ…Ø§Ø´ Ø£ÙƒØ«Ø± Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø± */
                 flex-basis: 0; /* Ø§Ù„Ø³Ù…Ø§Ø­ Ù„Ù‡ Ø¨Ø§Ù„Ø§Ù†ÙƒÙ…Ø§Ø´ Ø¥Ù„Ù‰ Ø§Ù„ØµÙØ± Ù‚Ø¨Ù„ Ù†Ù…ÙˆÙ‡ Ø¨Ù€ flex: 1 */
             }
             .status-icon { width: clamp(15px, 3vw, 20px); font-size: 1em;} /* ØªÙ‚Ù„ÙŠÙ„ Ø­Ø¬Ù… Ø§Ù„Ø£ÙŠÙ‚ÙˆÙ†Ø© */
             .timer-display { min-width: clamp(30px, 6vw, 40px); font-size: 0.8em; } /* ØªÙ‚Ù„ÙŠÙ„ Ø­Ø¬Ù… Ø§Ù„Ù…Ø¤Ù‚Øª */
             #turn-indicators { height: clamp(25px, 4vmin, 35px); margin: 0 clamp(3px, 0.8vw, 5px); } /* ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø§Ø±ØªÙØ§Ø¹ ÙˆØ§Ù„Ù‡ÙˆØ§Ù…Ø´ */
             .turn-indicator { width: clamp(20px, 3.5vmin, 25px); height: clamp(20px, 3.5vmin, 25px); margin: 0 clamp(3px, 0.8vw, 5px); border-width: 1px; } /* ØªÙ‚Ù„ÙŠÙ„ Ø­Ø¬Ù… ÙˆÙ…Ø³Ø§Ø­Ø© Ø§Ù„Ù…Ø¤Ø´Ø± */
             .turn-indicator .piece-visual { width: 80%; height: 80%; } /* ØªÙ‚Ù„ÙŠÙ„ Ø­Ø¬Ù… Ù‚Ø·Ø¹Ø© Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© */
         }

         /* ØªØ¹Ø¯ÙŠÙ„ Ø£Ø®ÙŠØ± Ù„Ø¶Ù…Ø§Ù† Ø£Ù† Ø§Ù„Ø¹Ù†Ø§ØµØ± ØªØ¸Ù‡Ø± Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ø´Ø§Ø´Ø© *Ù‚ØµÙŠØ±Ø© Ø¬Ø¯Ù‹Ø§* */
         @media (max-height: 400px) {
            #start-screen { padding: 10px; } /* ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø­Ø´Ùˆ ÙÙŠ Ø§Ù„Ø´Ø§Ø´Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© */
            #main-title { margin-bottom: 10px; }
            #start-screen h2#start-subtitle { margin-bottom: 10px; }
            .start-button { margin: 5px 0; padding: 8px 15px; }
            #game-container { padding: 5px; gap: 5px; } /* ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø­Ø´Ùˆ ÙˆØ§Ù„ÙØ¬ÙˆØ© ÙÙŠ Ø­Ø§ÙˆÙŠØ© Ø§Ù„Ù„Ø¹Ø¨Ø© */
            #board { border-width: 3px; } /* ØªÙ‚Ù„ÙŠÙ„ Ø³Ù…Ùƒ Ø¥Ø·Ø§Ø± Ø§Ù„Ù„ÙˆØ­Ø© */
            #status-bar { padding: 3px 5px; gap: 3px; font-size: 0.7em; } /* ØªÙ‚Ù„ÙŠÙ„ Ø­Ø´Ùˆ ÙˆÙØ¬ÙˆØ© Ø´Ø±ÙŠØ· Ø§Ù„Ø­Ø§Ù„Ø© */
            .status-section { gap: 3px; }
            .timer-display { min-width: 30px; font-size: 0.7em; padding: 1px 3px; }
            #turn-indicators { height: 20px; margin: 0 3px; }
            .turn-indicator { width: 18px; height: 18px; margin: 0 3px; border-width: 1px; }
            #settings-button { top: 5px; right: 5px; font-size: 1.3em; } /* ØªÙ‚Ù„ÙŠÙ„ Ø­Ø¬Ù… ÙˆÙ…ÙˆØ¶Ø¹ Ø²Ø± Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª */
            #settings-panel { top: 40px; right: 5px; padding: 5px; gap: 5px; max-height: calc(100vh - 50px); min-width: 100px;} /* ØªÙ‚Ù„ÙŠÙ„ Ø­Ø´Ùˆ ÙˆÙØ¬ÙˆØ© Ù„ÙˆØ­Ø© Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª */
             .settings-icon-button { width: 30px; height: 30px; font-size: 1em; } /* ØªÙ‚Ù„ÙŠÙ„ Ø­Ø¬Ù… Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª */
            .overlay-screen { padding: 10px; overflow-y: auto; } /* ØªÙ‚Ù„ÙŠÙ„ Ø­Ø´Ùˆ Ø´Ø§Ø´Ø§Øª Ø§Ù„ØªØ±Ø§ÙƒØ¨ ÙˆØ§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„ØªÙ…Ø±ÙŠØ± */
            .selection-content { padding: 10px 15px; max-height: 90vh; margin: auto; } /* ØªÙ‚Ù„ÙŠÙ„ Ø­Ø´Ùˆ Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø§Ø®ØªÙŠØ§Ø± */
            .selection-content h2 { font-size: 1em; margin-bottom: 8px; }
            .options-container { grid-template-columns: repeat(auto-fit, minmax(70px, 1fr)); gap: 5px; padding-bottom: 5px; } /* ØªÙ‚Ù„ÙŠÙ„ Ø­Ø¬Ù… Ø§Ù„Ø£Ø¹Ù…Ø¯Ø© ÙˆØ§Ù„ÙØ¬ÙˆØ© */
            .option-button { padding: 4px; font-size: 0.7em; min-height: 60px; }
            .board-preview { width: 25px; height: 25px; margin-bottom: 4px; }
            .piece-preview { width: 20px; height: 20px; }
            .piece-preview-container { height: 22px; gap: 3px; margin-bottom: 4px;}
            .close-selection-button { font-size: 0.8em; padding: 6px 12px; }
             #confirmation-modal .selection-content { padding: 15px 10px; } /* ØªÙ‚Ù„ÙŠÙ„ Ø­Ø´Ùˆ Ù†Ø§ÙØ°Ø© Ø§Ù„ØªØ£ÙƒÙŠØ¯ */
             #confirmation-message { font-size: 0.9em; margin-bottom: 15px; }
             #confirmation-buttons { gap: 8px; }
             #confirmation-buttons button { font-size: 0.8em; padding: 6px 12px;}
         }


    </style>
</head>
<body class="piece-style-classic">
    <!-- Settings Button -->
    <button id="settings-button" title="Settings"> <i class="fas fa-cog"></i> </button>

    <!-- Settings Overlay -->
    <div id="settings-overlay"></div>

    <!-- Settings Panel -->
    <div id="settings-panel">
        <button id="sound-toggle-button" class="settings-icon-button" title="Toggle Sound"> <i class="fas fa-volume-up"></i> </button>
        <button id="timer-toggle-button" class="settings-icon-button" title="Toggle Turn Timer"> <i class="fas fa-clock"></i> </button>
        <button id="undo-button" class="settings-icon-button" title="Undo Move" disabled> <i class="fas fa-undo"></i> </button>
        <button id="hint-button" class="settings-icon-button" title="Hint"> <i class="fas fa-lightbulb"></i> </button>
        <button id="change-board-button" class="settings-icon-button" title="Change Board Design"> <i class="fas fa-chess-board"></i> </button>
        <button id="change-piece-style-button" class="settings-icon-button" title="Change Piece Style"> <i class="fas fa-puzzle-piece"></i> </button>
        <button id="logout-button" class="settings-icon-button" title="Back to Main Menu"> <i class="fas fa-sign-out-alt"></i> </button>
    </div>

    <!-- Start Screen -->
    <div id="start-screen">
        <h1 id="main-title">Checkers Game</h1>
        <h2 id="start-subtitle">Select Play Mode</h2>
        <div id="start-options">
            <button id="vs-human-button" class="start-button">Play vs Friend</button>
            <button id="vs-ai-button" class="start-button">Play vs Computer</button>
        </div>
    </div>

    <!-- AI Difficulty Selector -->
    <div id="ai-difficulty-selector-container">
        <button id="close-difficulty-selector" title="Close"><i class="fas fa-times"></i></button>
        <h3>Select Difficulty Level</h3>
        <div class="difficulty-control">
            <button id="difficulty-prev" class="difficulty-arrow-button" title="Previous"> <i class="fas fa-chevron-left"></i> </button>
            <span id="difficulty-display">Medium</span>
            <button id="difficulty-next" class="difficulty-arrow-button" title="Next"> <i class="fas fa-chevron-right"></i> </button>
        </div>
        <button id="confirm-difficulty-button" class="start-button">Start Game</button>
    </div>

    <!-- Game Container -->
    <div id="game-container">
        <div id="status-bar">
             <!-- Order 1: White Player Info -->
            <div class="status-section capture-count white">
                <i class="fas fa-chess-pawn status-icon" style="color: #eee;"></i>
                <span>Captured:</span> <span id="captured-by-black">0</span>
                <div id="white-timer" class="timer-display">--:--</div>
            </div>
             <!-- Order 2: Turn Indicators -->
            <div id="turn-indicators">
                <div id="white-indicator" class="turn-indicator"><div class="piece-visual white piece white-piece"></div></div>
                <div id="black-indicator" class="turn-indicator"><div class="piece-visual black piece black-piece"></div></div>
            </div>
             <!-- Order 3: Black Player Info -->
            <div class="status-section capture-count black">
                 <div id="black-timer" class="timer-display">--:--</div>
                <span>Captured:</span> <span id="captured-by-white">0</span>
                <i class="fas fa-chess-pawn status-icon" style="color: #444;"></i>
            </div>
        </div>
        <div id="board"></div>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen">
        <div id="game-over-content">
            <div id="game-over-message"></div>
            <button id="back-to-menu-button" class="close-selection-button">Back to Main Menu</button>
        </div>
    </div>

    <!-- Board Selection Screen -->
    <div id="board-selection-screen" class="overlay-screen">
        <div id="board-selection-content" class="selection-content">
            <h2>Choose Your Preferred Board Design</h2>
            <div id="board-options-container" class="options-container">
                <button class="board-option option-button" data-style="wood" title="Wood"><div class="board-preview board-preview-wood"><div class="sq light"></div><div class="sq dark"></div> <div class="sq dark"></div><div class="sq light"></div></div> <span>Wood</span></button>
                <button class="board-option option-button" data-style="desert" title="Desert"><div class="board-preview board-preview-desert"><div class="sq light"></div><div class="sq dark"></div> <div class="sq dark"></div><div class="sq light"></div></div> <span>Desert</span></button>
                <button class="board-option option-button" data-style="stone-path" title="Stone Path"><div class="board-preview board-preview-stone-path"><div class="sq light"></div><div class="sq dark"></div> <div class="sq dark"></div><div class="sq light"></div></div> <span>Stone Path</span></button>
                <button class="board-option option-button" data-style="emerald" title="Emerald"><div class="board-preview board-preview-emerald"><div class="sq light"></div><div class="sq dark"></div> <div class="sq dark"></div><div class="sq light"></div></div> <span>Emerald</span></button>
                <button class="board-option option-button" data-style="volcano" title="Volcano"><div class="board-preview board-preview-volcano"><div class="sq light"></div><div class="sq dark"></div> <div class="sq dark"></div><div class="sq light"></div></div> <span>Volcano</span></button>
                <button class="board-option option-button" data-style="royal" title="Royal"><div class="board-preview board-preview-royal"><div class="sq light"></div><div class="sq dark"></div> <div class="sq dark"></div><div class="sq light"></div></div> <span>Royal</span></button>
             </div>
            <button id="close-board-selection" class="close-selection-button">Close</button>
        </div>
    </div>

    <!-- Piece Style Selection Screen -->
    <div id="piece-style-selection-screen" class="overlay-screen">
        <div id="piece-style-selection-content" class="selection-content">
            <h2>Choose Your Preferred Piece Style</h2>
            <div id="piece-options-container" class="options-container">
                <button class="piece-option option-button" data-style="classic" title="Classic"><div class="piece-preview-container"><div class="piece-preview white classic"></div> <div class="piece-preview black classic"></div></div> <span>Classic</span></button>
                <button class="piece-option option-button" data-style="flat" title="Flat"><div class="piece-preview-container"><div class="piece-preview white flat"></div> <div class="piece-preview black flat"></div></div> <span>Flat</span></button>
                <button class="piece-option option-button" data-style="crimson" title="Crimson"><div class="piece-preview-container"><div class="piece-preview white crimson"></div> <div class="piece-preview black crimson"></div></div> <span>Crimson</span></button>
                <button class="piece-option option-button" data-style="azure" title="Azure"><div class="piece-preview-container"><div class="piece-preview white azure"></div> <div class="piece-preview black azure"></div></div> <span>Azure</span></button>
                <button class="piece-option option-button" data-style="forest" title="Forest"><div class="piece-preview-container"><div class="piece-preview white forest"></div> <div class="piece-preview black forest"></div></div> <span>Forest</span></button>
                <button class="piece-option option-button" data-style="royal" title="Royal"><div class="piece-preview-container"><div class="piece-preview white royal"></div> <div class="piece-preview black royal"></div></div> <span>Royal</span></button>
             </div>
            <button id="close-piece-selection" class="close-selection-button">Close</button>
        </div>
    </div>

    <!-- Confirmation Modal -->
    <div id="confirmation-modal" class="overlay-screen">
        <div id="confirmation-content" class="selection-content">
            <p id="confirmation-message">Are you sure you want to return to the main menu? Your current game progress will be lost.</p>
            <div id="confirmation-buttons">
                <button id="confirm-logout-button" class="close-selection-button">Yes, Confirm</button>
                <button id="cancel-logout-button" class="close-selection-button">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // --- Element References ---
        const bodyElement = document.body;
        const startScreen = document.getElementById('start-screen');
        const mainTitle = document.getElementById('main-title');
        const startSubtitle = document.getElementById('start-subtitle');
        const startOptions = document.getElementById('start-options');
        const vsHumanButton = document.getElementById('vs-human-button');
        const vsAiButton = document.getElementById('vs-ai-button');
        const aiDifficultySelectorContainer = document.getElementById('ai-difficulty-selector-container');
        const difficultyPrevButton = document.getElementById('difficulty-prev');
        const difficultyNextButton = document.getElementById('difficulty-next');
        const difficultyDisplay = document.getElementById('difficulty-display');
        const confirmDifficultyButton = document.getElementById('confirm-difficulty-button');
        const gameContainer = document.getElementById('game-container');
        const statusBar = document.getElementById('status-bar');
        const whiteCapturedDisplay = document.getElementById('captured-by-black'); // Captures made by black (white pieces)
        const blackCapturedDisplay = document.getElementById('captured-by-white'); // Captures made by white (black pieces)
        const whiteTimerDisplay = document.getElementById('white-timer');
        const blackTimerDisplay = document.getElementById('black-timer');
        const boardElement = document.getElementById('board');
        const whiteIndicator = document.getElementById('white-indicator');
        const blackIndicator = document.getElementById('black-indicator');
        const gameOverScreen = document.getElementById('game-over-screen');
        const gameOverMessage = document.getElementById('game-over-message');
        const backToMenuButton = document.getElementById('back-to-menu-button');
        const settingsButton = document.getElementById('settings-button');
        const settingsPanel = document.getElementById('settings-panel');
        const settingsOverlay = document.getElementById('settings-overlay');
        const soundToggleButton = document.getElementById('sound-toggle-button');
        const timerToggleButton = document.getElementById('timer-toggle-button');
        const undoButton = document.getElementById('undo-button');
        const hintButton = document.getElementById('hint-button');
        const logoutButton = document.getElementById('logout-button');
        const changeBoardButton = document.getElementById('change-board-button');
        const changePieceStyleButton = document.getElementById('change-piece-style-button');
        const boardSelectionScreen = document.getElementById('board-selection-screen');
        const boardOptionsContainer = document.getElementById('board-options-container');
        const closeBoardSelectionButton = document.getElementById('close-board-selection');
        const pieceStyleSelectionScreen = document.getElementById('piece-style-selection-screen');
        const pieceOptionsContainer = document.getElementById('piece-options-container');
        const closePieceSelectionButton = document.getElementById('close-piece-selection');
        const confirmationModal = document.getElementById('confirmation-modal');
        const confirmLogoutButton = document.getElementById('confirm-logout-button');
        const cancelLogoutButton = document.getElementById('cancel-logout-button');
        const closeDifficultySelectorButton = document.getElementById('close-difficulty-selector');

        // --- Audio ---
        let audioCtx; function getAudioContext() { if (!audioCtx && (window.AudioContext || window.webkitAudioContext)) { try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch (e) { console.error("Web Audio API not supported", e); } } return audioCtx; }
        let isSoundEnabled = localStorage.getItem('isSoundEnabled') !== 'false';
        function playSound(type, options = {}) { if (!isSoundEnabled) return; const ctx = getAudioContext(); if (!ctx) return; if (ctx.state === 'suspended') { ctx.resume().then(() => { if (ctx.state === 'running') playSoundInternal(ctx, type, options); }).catch(e => console.error("Error resuming AudioContext:", e)); return; } if (ctx.state === 'running') { playSoundInternal(ctx, type, options); } }
        function playSoundInternal(ctx, type, options) { try { const time = ctx.currentTime; const osc = ctx.createOscillator(); const gain = ctx.createGain(); osc.connect(gain); gain.connect(ctx.destination); gain.gain.setValueAtTime(options.volume || 0.2, time); switch (type) { case 'select': osc.type = 'triangle'; osc.frequency.setValueAtTime(1500, time); gain.gain.setValueAtTime(options.volume || 0.15, time); gain.gain.linearRampToValueAtTime(0.001, time + 0.05); osc.start(time); osc.stop(time + 0.05); break; case 'move': osc.type = 'sine'; osc.frequency.setValueAtTime(600, time); osc.frequency.linearRampToValueAtTime(400, time + 0.08); gain.gain.setValueAtTime(options.volume || 0.2, time); gain.gain.linearRampToValueAtTime(0.001, time + 0.08); osc.start(time); osc.stop(time + 0.08); break; case 'capture': osc.type = 'square'; osc.frequency.setValueAtTime(500, time); gain.gain.setValueAtTime(options.volume || 0.25, time); gain.gain.exponentialRampToValueAtTime(0.001, time + 0.12); osc.start(time); osc.stop(time + 0.12); break; case 'king': osc.type = 'sine'; gain.gain.setValueAtTime(options.volume || 0.25, time); osc.frequency.setValueAtTime(880, time); osc.frequency.linearRampToValueAtTime(1318.51, time + 0.15); gain.gain.linearRampToValueAtTime(0.001, time + 0.2); osc.start(time); osc.stop(time + 0.2); break; case 'win': gain.gain.setValueAtTime(options.volume || 0.3, time); osc.frequency.setValueAtTime(523.25, time); osc.start(time); osc.stop(time + 0.15); const osc2 = ctx.createOscillator(); const gain2 = ctx.createGain(); osc2.connect(gain2); gain2.connect(ctx.destination); gain2.gain.setValueAtTime(options.volume || 0.3, time + 0.15); osc2.type = 'sine'; osc2.frequency.setValueAtTime(783.99, time + 0.15); gain2.gain.linearRampToValueAtTime(0.001, time + 0.4); osc2.start(time + 0.15); osc2.stop(time + 0.4); break; case 'undo': osc.type = 'sawtooth'; osc.frequency.setValueAtTime(300, time); osc.frequency.linearRampToValueAtTime(500, time + 0.1); gain.gain.setValueAtTime(options.volume || 0.15, time); gain.gain.linearRampToValueAtTime(0.001, time + 0.1); osc.start(time); osc.stop(time + 0.1); break; case 'hint': osc.type = 'sine'; osc.frequency.setValueAtTime(1200, time); gain.gain.setValueAtTime(options.volume || 0.1, time); gain.gain.linearRampToValueAtTime(0.001, time + 0.08); osc.start(time); osc.stop(time + 0.08); break; case 'timer_tick': osc.type = 'sine'; osc.frequency.setValueAtTime(900, time); gain.gain.setValueAtTime(options.volume || 0.05, time); gain.gain.linearRampToValueAtTime(0.001, time + 0.05); osc.start(time); osc.stop(time + 0.05); break; case 'timeout': osc.type = 'square'; osc.frequency.setValueAtTime(440, time); gain.gain.setValueAtTime(options.volume || 0.3, time); gain.gain.linearRampToValueAtTime(0.001, time + 0.3); osc.start(time); osc.stop(time + 0.3); break; default: console.warn("Unknown sound type:", type); } } catch (e) { console.error("Error playing sound:", type, e); } }

        // --- Game Constants & State ---
        const BOARD_SIZE = 8; const PLAYER_BLACK = 'black'; const PLAYER_WHITE = 'white'; const AI_PLAYER = PLAYER_WHITE;
        const DIFFICULTIES = { EASY: 'easy', MEDIUM: 'medium', HARD: 'hard' }; const MINIMAX_DEPTH = { MEDIUM: 3, HARD: 5 }; const TIMER_DURATION = 60;
        const difficultyLevels = [DIFFICULTIES.EASY, DIFFICULTIES.MEDIUM, DIFFICULTIES.HARD];
        const difficultyLabels = { easy: 'Easy', medium: 'Medium', hard: 'Hard' };
        let currentDifficultyIndex = 1;
        let chosenAiDifficulty = difficultyLevels[currentDifficultyIndex];
        let boardState = []; let currentPlayer = PLAYER_BLACK; let selectedPiece = null; let possibleMoves = []; let continuousJumpPossible = false; let gameMode = 'human'; let aiDifficulty = chosenAiDifficulty; let isAiThinking = false; let isGameOver = false; let isSettingsPanelVisible = false; let currentBoardStyle = localStorage.getItem('boardStyle') || 'wood';
        let currentPieceStyle = localStorage.getItem('pieceStyle') || 'classic';
        let capturedByBlack = 0; let capturedByWhite = 0; let moveHistory = []; let isTimerEnabled = localStorage.getItem('isTimerEnabled') === 'true'; let currentTurnTimeRemaining = TIMER_DURATION; let timerIntervalId = null; let hintTimeoutId = null;

        // --- Utility Functions ---
        function isValidSquare(row, col) { return row >= 0 && row < BOARD_SIZE && col >= 0 && col < BOARD_SIZE; }
        function deepCopyBoard(board) { return JSON.parse(JSON.stringify(board)); }
        function getOpponent(player) { return player === PLAYER_BLACK ? PLAYER_WHITE : PLAYER_BLACK; }

        // --- UI Update Functions ---
        function updateSoundButtonIcon() {
            const icon = soundToggleButton.querySelector('i');
            if (isSoundEnabled) { icon.classList.remove('fa-volume-mute'); icon.classList.add('fa-volume-up'); soundToggleButton.classList.remove('sound-off'); soundToggleButton.title = "Toggle Sound (On)"; }
            else { icon.classList.remove('fa-volume-up'); icon.classList.add('fa-volume-mute'); soundToggleButton.classList.add('sound-off'); soundToggleButton.title = "Toggle Sound (Off)"; }
        }
        function updateTimerButtonIcon() {
            const icon = timerToggleButton.querySelector('i');
            if (isTimerEnabled) { icon.classList.remove('fa-stopwatch'); icon.classList.add('fa-clock'); timerToggleButton.classList.remove('timer-off'); timerToggleButton.title = "Toggle Turn Timer (On)"; }
            else { icon.classList.remove('fa-clock'); icon.classList.add('fa-stopwatch'); timerToggleButton.classList.add('timer-off'); timerToggleButton.title = "Toggle Turn Timer (Off)"; }
        }
        function updateTurnIndicatorVisuals() { const whiteVisual = whiteIndicator.querySelector('.piece-visual'); const blackVisual = blackIndicator.querySelector('.piece-visual'); whiteVisual.style = ''; blackVisual.style = ''; whiteVisual.className = `piece-visual white piece white-piece`; blackVisual.className = `piece-visual black piece black-piece`; }
        function updateCapturedCounters() { whiteCapturedDisplay.textContent = capturedByBlack; blackCapturedDisplay.textContent = capturedByWhite; }
        function updateUndoButton() { undoButton.disabled = moveHistory.length === 0 || isAiThinking || isGameOver || (gameMode === 'ai' && currentPlayer === AI_PLAYER && moveHistory.length > 0); }
        function updateHintButton() { hintButton.disabled = isAiThinking || isGameOver || (gameMode === 'ai' && currentPlayer === AI_PLAYER); }
        function formatTime(seconds) { if (seconds < 0) seconds = 0; const mins = Math.floor(seconds / 60); const secs = seconds % 60; return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`; }
        function updateTimerDisplay() { if (!isTimerEnabled) { whiteTimerDisplay.textContent = '--:--'; blackTimerDisplay.textContent = '--:--'; return; } const display = currentPlayer === PLAYER_WHITE ? whiteTimerDisplay : blackTimerDisplay; const otherDisplay = currentPlayer === PLAYER_WHITE ? blackTimerDisplay : whiteTimerDisplay; display.textContent = formatTime(currentTurnTimeRemaining); otherDisplay.textContent = formatTime(TIMER_DURATION); }
        function updateDifficultySelectorDisplay() { chosenAiDifficulty = difficultyLevels[currentDifficultyIndex]; difficultyDisplay.textContent = difficultyLabels[chosenAiDifficulty]; }

        // --- Timer Logic ---
        function stopTurnTimer() { if (timerIntervalId) { clearInterval(timerIntervalId); timerIntervalId = null; } }
        function startTurnTimer() { stopTurnTimer(); if (!isTimerEnabled || isGameOver) { updateTimerDisplay(); return; } currentTurnTimeRemaining = TIMER_DURATION; updateTimerDisplay(); timerIntervalId = setInterval(() => { currentTurnTimeRemaining--; updateTimerDisplay(); if (currentTurnTimeRemaining <= 5 && currentTurnTimeRemaining > 0) { playSound('timer_tick', { volume: 0.1 }); } if (currentTurnTimeRemaining <= 0) { handleTimeout(); } }, 1000); }
        function handleTimeout() { stopTurnTimer(); if (isGameOver) return; playSound('timeout'); const winner = getOpponent(currentPlayer); const winnerText = winner === PLAYER_BLACK ? "Black" : "White"; endGame(`${winnerText} Wins (Opponent ran out of time)!`); }

        // --- Game Flow Functions ---
        function initGame() {
            stopTurnTimer(); isGameOver = false; gameOverScreen.classList.remove('visible'); settingsOverlay.style.display = 'none'; document.querySelectorAll('.dark-square').forEach(sq => { sq.style.cursor = 'pointer'; });
            boardState = createInitialBoardState(); currentPlayer = PLAYER_BLACK; selectedPiece = null; possibleMoves = []; continuousJumpPossible = false; isAiThinking = false; isSettingsPanelVisible = false; settingsPanel.classList.remove('visible'); boardSelectionScreen.classList.remove('visible'); pieceStyleSelectionScreen.classList.remove('visible'); confirmationModal.classList.remove('visible');
            capturedByBlack = 0; capturedByWhite = 0; moveHistory = [];
            loadBoardStyle(); loadPieceStyle(); updateTurnIndicatorVisuals(); createBoardUI(); renderBoard(); updateStatus(); updateCapturedCounters(); updateUndoButton(); updateHintButton(); settingsButton.style.display = 'block'; startTurnTimer();
             // Ø¥Ø¶Ø§ÙØ© Ù„Ù…Ø³ØªÙ…Ø¹ Ø§Ù„Ø³Ø­Ø¨ ÙˆØ§Ù„Ø¥ÙÙ„Ø§Øª
            addDragListeners();
        }
        function startGame(mode) { playSound('select', { volume: 0.4 }); gameMode = mode; if (gameMode === 'human') { aiDifficulty = DIFFICULTIES.EASY; startScreen.classList.add('hidden-completely'); aiDifficultySelectorContainer.classList.remove('visible'); gameContainer.style.display = 'flex'; initGame(); } else { showDifficultySelector(); } }
        function startAiGame() { playSound('select', { volume: 0.4 }); gameMode = 'ai'; aiDifficulty = chosenAiDifficulty; startScreen.classList.add('hidden-completely'); aiDifficultySelectorContainer.classList.remove('visible'); gameContainer.style.display = 'flex'; settingsButton.style.display = 'block'; initGame(); }
        function returnToStartScreen() {
            playSound('select'); stopTurnTimer(); gameOverScreen.classList.remove('visible'); gameContainer.style.display = 'none'; startScreen.classList.remove('hidden-completely'); aiDifficultySelectorContainer.classList.remove('visible'); settingsButton.style.display = 'none'; settingsPanel.classList.remove('visible'); settingsOverlay.style.display = 'none'; isSettingsPanelVisible = false; boardSelectionScreen.classList.remove('visible'); pieceStyleSelectionScreen.classList.remove('visible'); confirmationModal.classList.remove('visible');
            boardState = []; currentPlayer = PLAYER_BLACK; selectedPiece = null; possibleMoves = []; continuousJumpPossible = false; isAiThinking = false; isGameOver = true; capturedByBlack = 0; capturedByWhite = 0; moveHistory = [];
            whiteIndicator.classList.remove('active-turn'); blackIndicator.classList.remove('active-turn'); updateStatus(""); updateCapturedCounters(); updateUndoButton(); updateHintButton(); updateTimerDisplay();
            mainTitle.style.opacity = 1; startSubtitle.style.opacity = 1; startOptions.style.opacity = 1; startSubtitle.textContent = "Select Play Mode";
        }
        function endGame(message) {
            if (isGameOver) return; isGameOver = true; stopTurnTimer(); playSound('win'); isAiThinking = false; gameOverMessage.textContent = message; gameOverScreen.classList.add('visible');
            settingsButton.style.display = 'none'; settingsPanel.classList.remove('visible'); settingsOverlay.style.display = 'none'; boardSelectionScreen.classList.remove('visible'); pieceStyleSelectionScreen.classList.remove('visible'); confirmationModal.classList.remove('visible');
            updateStatus(); updateUndoButton(); updateHintButton(); renderBoard();
        }

        // --- Modal/Overlay Functions ---
        function showConfirmationModal() { if (isGameOver) return; stopTurnTimer(); settingsPanel.classList.remove('visible'); settingsOverlay.style.display = 'none'; isSettingsPanelVisible = false; confirmationModal.classList.add('visible'); renderBoard(); }
        function hideConfirmationModal() { confirmationModal.classList.remove('visible'); if (!isGameOver && !isSettingsPanelVisible) { startTurnTimer(); } renderBoard(); }
        function showOverlay(overlayElement) { if (isGameOver) return; stopTurnTimer(); settingsPanel.classList.remove('visible'); settingsOverlay.style.display = 'none'; isSettingsPanelVisible = false; overlayElement.classList.add('visible'); renderBoard(); }
        function hideOverlay(overlayElement) { overlayElement.classList.remove('visible'); if (!isGameOver && !isSettingsPanelVisible) { startTurnTimer(); } renderBoard(); }

        // --- Event Listeners ---
        vsHumanButton.addEventListener('click', () => startGame('human'));
        vsAiButton.addEventListener('click', () => { playSound('select'); showDifficultySelector(); });
        difficultyPrevButton.addEventListener('click', () => { playSound('select', {volume: 0.1}); currentDifficultyIndex = (currentDifficultyIndex - 1 + difficultyLevels.length) % difficultyLevels.length; updateDifficultySelectorDisplay(); });
        difficultyNextButton.addEventListener('click', () => { playSound('select', {volume: 0.1}); currentDifficultyIndex = (currentDifficultyIndex + 1) % difficultyLevels.length; updateDifficultySelectorDisplay(); });
        confirmDifficultyButton.addEventListener('click', startAiGame);
        closeDifficultySelectorButton.addEventListener('click', () => { playSound('select'); aiDifficultySelectorContainer.classList.remove('visible'); startScreen.classList.remove('hidden-completely'); });
        function showDifficultySelector() { startScreen.classList.add('hidden-completely'); aiDifficultySelectorContainer.classList.add('visible'); updateDifficultySelectorDisplay(); }
        backToMenuButton.addEventListener('click', returnToStartScreen);
        logoutButton.addEventListener('click', () => { playSound('select'); showConfirmationModal(); });
        confirmLogoutButton.addEventListener('click', () => { playSound('select'); hideConfirmationModal(); returnToStartScreen(); });
        cancelLogoutButton.addEventListener('click', () => { playSound('select'); hideConfirmationModal(); });
        confirmationModal.addEventListener('click', (event) => { if (event.target === confirmationModal) { playSound('select'); hideConfirmationModal(); } });
        settingsButton.addEventListener('click', (e) => {
             e.stopPropagation(); // Ù…Ù†Ø¹ Ø¥ØºÙ„Ø§Ù‚ Ù„ÙˆØ­Ø© Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª ÙÙˆØ±Ù‹Ø§ Ø¥Ø°Ø§ ØªÙ… Ø§Ù„Ù†Ù‚Ø± Ø®Ø§Ø±Ø¬Ù‡Ø§
             playSound('select'); isSettingsPanelVisible = !isSettingsPanelVisible;
             if (isSettingsPanelVisible && !isGameOver) {
                 stopTurnTimer();
                 settingsPanel.classList.add('visible');
                 settingsOverlay.style.display = 'block';
                 // Ø¥Ø®ÙØ§Ø¡ Ø£ÙŠ Ø´Ø§Ø´Ø§Øª ØªØ±Ø§ÙƒØ¨ Ø£Ø®Ø±Ù‰
                 boardSelectionScreen.classList.remove('visible');
                 pieceStyleSelectionScreen.classList.remove('visible');
                 confirmationModal.classList.remove('visible');
             } else {
                 if (!isGameOver) startTurnTimer();
                 settingsPanel.classList.remove('visible');
                 settingsOverlay.style.display = 'none';
             }
             renderBoard(); // ØªØ­Ø¯ÙŠØ« Ø¹Ø±Ø¶ Ø§Ù„Ù„ÙˆØ­Ø© Ù„Ø¥Ø²Ø§Ù„Ø©/Ø¥Ø¶Ø§ÙØ© ØªØ£Ø«ÙŠØ±Ø§Øª Ø§Ù„ØªÙØ§Ø¹Ù„
         });
        settingsOverlay.addEventListener('click', (e) => {
            // ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù‡Ø¯Ù Ù‡Ùˆ Ø§Ù„Ø®Ù„ÙÙŠØ© Ù†ÙØ³Ù‡Ø§ ÙˆÙ„ÙŠØ³ Ø£ÙŠ Ø´ÙŠØ¡ Ø¯Ø§Ø®Ù„ Ù„ÙˆØ­Ø© Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
            if (e.target === settingsOverlay) {
                 if(isSettingsPanelVisible) {
                    playSound('select');
                    isSettingsPanelVisible = false;
                    settingsPanel.classList.remove('visible');
                    settingsOverlay.style.display = 'none';
                    if (!isGameOver) startTurnTimer();
                    renderBoard(); // ØªØ­Ø¯ÙŠØ« Ø¹Ø±Ø¶ Ø§Ù„Ù„ÙˆØ­Ø©
                 }
            }
        });
        soundToggleButton.addEventListener('click', () => { isSoundEnabled = !isSoundEnabled; localStorage.setItem('isSoundEnabled', isSoundEnabled); updateSoundButtonIcon(); if (isSoundEnabled) { const ctx = getAudioContext(); if (ctx && ctx.state === 'suspended') { ctx.resume(); } playSound('select', { volume: 0.4 }); } });
        timerToggleButton.addEventListener('click', () => { isTimerEnabled = !isTimerEnabled; localStorage.setItem('isTimerEnabled', isTimerEnabled); updateTimerButtonIcon(); playSound('select'); if (isTimerEnabled && !isGameOver && !isSettingsPanelVisible && !confirmationModal.classList.contains('visible') && !boardSelectionScreen.classList.contains('visible') && !pieceStyleSelectionScreen.classList.contains('visible')) { startTurnTimer(); } else { stopTurnTimer(); updateTimerDisplay(); } }); // ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ø´Ø±Ø· Ø¨Ø¯Ø¡ Ø§Ù„Ù…Ø¤Ù‚Øª
        undoButton.addEventListener('click', () => { if (!undoButton.disabled) { playSound('undo'); undoMove(); } });
        hintButton.addEventListener('click', () => { if (!hintButton.disabled) { playSound('hint'); showHint(); } });
        changeBoardButton.addEventListener('click', () => { playSound('select'); updateSelectedBoardOption(); showOverlay(boardSelectionScreen); });
        changePieceStyleButton.addEventListener('click', () => { playSound('select'); updateSelectedPieceOption(); showOverlay(pieceStyleSelectionScreen); });
        closeBoardSelectionButton.addEventListener('click', () => { playSound('select'); hideOverlay(boardSelectionScreen); });
        closePieceSelectionButton.addEventListener('click', () => { playSound('select'); hideOverlay(pieceStyleSelectionScreen); });
        boardOptionsContainer.addEventListener('click', (event) => { const targetOption = event.target.closest('.board-option'); if (targetOption) { const selectedStyle = targetOption.dataset.style; if (selectedStyle && selectedStyle !== currentBoardStyle) { applyBoardStyle(selectedStyle); playSound('select'); } updateSelectedBoardOption(); } });
        pieceOptionsContainer.addEventListener('click', (event) => { const targetOption = event.target.closest('.piece-option'); if (targetOption) { const selectedStyle = targetOption.dataset.style; if (selectedStyle && selectedStyle !== currentPieceStyle) { applyPieceStyle(selectedStyle); playSound('select'); } updateSelectedPieceOption(); } });

        // --- Board Setup and Rendering ---
        function createInitialBoardState() { const state = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(null)); for (let r = 0; r < BOARD_SIZE; r++) { for (let c = 0; c < BOARD_SIZE; c++) { if ((r + c) % 2 !== 0) { if (r < 3) { state[r][c] = { player: PLAYER_WHITE, isKing: false }; } else if (r > 4) { state[r][c] = { player: PLAYER_BLACK, isKing: false }; } } } } return state; }
        function createBoardUI() { boardElement.innerHTML = ''; const squareSize = parseFloat(getComputedStyle(boardElement).getPropertyValue('--square-size')); for (let r = 0; r < BOARD_SIZE; r++) { for (let c = 0; c < BOARD_SIZE; c++) { const sq = document.createElement('div'); sq.classList.add('square', (r + c) % 2 === 0 ? 'light-square' : 'dark-square'); sq.dataset.row = r; sq.dataset.col = c; /*sq.dataset.x = c * squareSize; sq.dataset.y = r * squareSize;*/ // Ù„Ù… ØªØ¹Ø¯ ØªØ³ØªØ®Ø¯Ù… Ù‡Ø°Ù‡ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
            if ((r + c) % 2 !== 0) {
                // Ø¥Ø¶Ø§ÙØ© Ù…Ø³ØªÙ…Ø¹ Ø§Ù„Ù†Ù‚Ø± Ù„Ù„Ù…Ø±Ø¨Ø¹Ø§Øª Ø§Ù„Ù…Ø¸Ù„Ù…Ø©
                sq.addEventListener('click', handleSquareClick);
            }
            boardElement.appendChild(sq); } }
             // Ø¥Ø¶Ø§ÙØ© Ù…Ø³ØªÙ…Ø¹Ø§Øª Ø§Ù„Ø³Ø­Ø¨ ÙˆØ§Ù„Ø¥ÙÙ„Ø§Øª Ø¨Ø¹Ø¯ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø±Ø¨Ø¹Ø§Øª
            addDragListeners();
        }
        function getSquareElement(row, col) { if (!isValidSquare(row, col)) return null; return boardElement.querySelector(`.square[data-row="${row}"][data-col="${col}"]`); }
        let renderTimeout; function requestRender() { clearTimeout(renderTimeout); renderTimeout = setTimeout(renderBoard, 0); }
        function renderBoard() {
            clearHintHighlights();
            // ØªØ­Ø¯ÙŠØ« Ø´Ø±Ø· Ø­Ø¬Ø¨ Ø§Ù„ØªÙØ§Ø¹Ù„ Ù„ÙŠØ´Ù…Ù„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø´Ø§Ø´Ø§Øª Ø§Ù„Ù…Ù†Ø¨Ø«Ù‚Ø©/Ø§Ù„Ù…ØªØ±Ø§ÙƒØ¨Ø©
            const isInteractionBlocked = isGameOver || isAiThinking || isSettingsPanelVisible || boardSelectionScreen.classList.contains('visible') || pieceStyleSelectionScreen.classList.contains('visible') || confirmationModal.classList.contains('visible') || (gameMode === 'ai' && currentPlayer === AI_PLAYER && !isGameOver);
            const allSquares = boardElement.querySelectorAll('.square');
            allSquares.forEach(sq => {
                sq.classList.remove('possible-move');
                const isDarkSquare = sq.classList.contains('dark-square');
                // ØªØ­Ø¯ÙŠØ« Ù…Ø¤Ø´Ø± Ø§Ù„ÙØ£Ø±Ø© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„ØªÙØ§Ø¹Ù„ Ù…Ø­Ø¸ÙˆØ±Ù‹Ø§
                sq.style.cursor = (isDarkSquare && !isInteractionBlocked) ? 'pointer' : 'default';
                // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù‚Ø·Ø¹ Ø§Ù„ØªÙŠ Ù„Ù… ØªØ¹Ø¯ Ù…ÙˆØ¬ÙˆØ¯Ø© ÙÙŠ Ø­Ø§Ù„Ø© Ø§Ù„Ù„ÙˆØ­Ø© (Ù…Ø¹ Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§Ù„Ù‚Ø·Ø¹ Ø§Ù„ØªÙŠ ÙŠØªÙ… Ø³Ø­Ø¨Ù‡Ø§/ØªØ­Ø±ÙŠÙƒÙ‡Ø§)
                const existingPieces = sq.querySelectorAll('.piece:not(.dragging)');
                 existingPieces.forEach(pieceEl => {
                      const r = parseInt(sq.dataset.row);
                      const c = parseInt(sq.dataset.col);
                      if (!boardState[r][c] || pieceEl.dataset.pieceId !== `${r}-${c}`) {
                           pieceEl.remove();
                      }
                 });
            });

            const allPossibleJumps = !isInteractionBlocked ? getAllPossibleMoves(currentPlayer, true, boardState) : [];
            const jumpIsPossibleAnywhere = allPossibleJumps.length > 0;

            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const pieceData = boardState[r][c];
                    const square = getSquareElement(r, c);
                    if (pieceData && square) {
                        let pieceEl = square.querySelector(`.piece[data-piece-id="${r}-${c}"]`);
                        if (!pieceEl) {
                            pieceEl = document.createElement('div');
                            pieceEl.dataset.pieceId = `${r}-${c}`;
                            pieceEl.style.transform = `translate(-50%, -50%)`; // ØªØ¹ÙŠÙŠÙ† Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ
                             // Ø¥Ø¶Ø§ÙØ© Ù…Ø³ØªÙ…Ø¹Ø§Øª Ø§Ù„Ø³Ø­Ø¨ Ø¥Ù„Ù‰ Ø§Ù„Ù‚Ø·Ø¹Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
                            addDragListeners(pieceEl);
                            square.appendChild(pieceEl);
                         }
                        // ØªØ­Ø¯ÙŠØ« ÙØ¦Ø§Øª Ø§Ù„Ù‚Ø·Ø¹Ø© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§ØªÙ‡Ø§ ÙˆØ­Ø§Ù„Ø© Ø§Ù„Ù„Ø¹Ø¨Ø©
                        pieceEl.className = `piece ${pieceData.player}-piece ${pieceData.isKing ? 'king' : ''}`;

                        // ØªØ­Ø¯ÙŠØ¯ Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† ÙŠÙ…ÙƒÙ† Ø§Ù„ØªÙØ§Ø¹Ù„ Ù…Ø¹ Ø§Ù„Ù‚Ø·Ø¹Ø©
                        const canInteractPiece = !isInteractionBlocked && pieceData.player === currentPlayer && !(continuousJumpPossible && selectedPiece && (selectedPiece.row !== r || selectedPiece.col !== c));

                        pieceEl.classList.toggle('interactive', canInteractPiece);
                        pieceEl.style.cursor = canInteractPiece ? 'grab' : 'default';
                        // pointerEvents: 'none' Ø¥Ø°Ø§ ÙƒØ§Ù†Øª ØºÙŠØ± ØªÙØ§Ø¹Ù„ÙŠØ© Ù„ØªØ¬Ù†Ø¨ Ø­Ø¸Ø± Ø£Ø­Ø¯Ø§Ø« Ø§Ù„Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø±Ø¨Ø¹ Ø§Ù„Ø³ÙÙ„ÙŠ
                        pieceEl.style.pointerEvents = canInteractPiece ? 'auto' : 'none';

                         // Ø¥Ø²Ø§Ù„Ø©/Ø¥Ø¶Ø§ÙØ© Ù…Ø³ØªÙ…Ø¹ Ø§Ù„Ù†Ù‚Ø± Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„ØªÙØ§Ø¹Ù„ Ø§Ù„Ù…Ø³Ù…ÙˆØ­ Ø¨Ù‡
                         if (canInteractPiece) {
                             // Ø¥Ø²Ø§Ù„Ø© Ø£ÙŠ Ù…Ø³ØªÙ…Ø¹ Ù…ÙˆØ¬ÙˆØ¯ Ø£ÙˆÙ„Ø§Ù‹ Ù„ØªØ¬Ù†Ø¨ Ø§Ù„ØªÙƒØ±Ø§Ø±
                             const oldClickHandler = pieceEl.__clickHandler;
                             if (oldClickHandler) { pieceEl.removeEventListener('click', oldClickHandler); }
                             const newClickHandler = (e) => { e.stopPropagation(); handlePieceClick(e); };
                             pieceEl.addEventListener('click', newClickHandler);
                             pieceEl.__clickHandler = newClickHandler; // ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø³ØªÙ…Ø¹ Ù„Ù„Ø¥Ø²Ø§Ù„Ø© Ù„Ø§Ø­Ù‚Ù‹Ø§
                         } else {
                             const oldClickHandler = pieceEl.__clickHandler;
                             if (oldClickHandler) { pieceEl.removeEventListener('click', oldClickHandler); pieceEl.__clickHandler = null; }
                         }


                        // Ø¥Ø¶Ø§ÙØ© ØªÙ„Ù…ÙŠØ­ Ø§Ù„Ù‚ÙØ² Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù‚ÙØ²Ø§Øª Ø¥Ù„Ø²Ø§Ù…ÙŠØ© ÙˆÙ‡Ø°Ù‡ Ø§Ù„Ù‚Ø·Ø¹Ø© ÙŠÙ…ÙƒÙ†Ù‡Ø§ Ø§Ù„Ù‚ÙØ²
                        pieceEl.classList.remove('jump-hint');
                        if (jumpIsPossibleAnywhere && !continuousJumpPossible && pieceData.player === currentPlayer) {
                            const thisPieceCanJump = allPossibleJumps.some(jump => jump.origin.r === r && jump.origin.c === c);
                            if (thisPieceCanJump) { pieceEl.classList.add('jump-hint'); }
                        }

                        // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù‚Ø·Ø¹Ø© Ø§Ù„Ù…Ø®ØªØ§Ø±Ø©
                        pieceEl.classList.toggle('selected', selectedPiece && selectedPiece.row === r && selectedPiece.col === c);
                        if(selectedPiece && selectedPiece.row === r && selectedPiece.col === c){ selectedPiece.element = pieceEl; }
                    }
                }
            }

            // Ø¥Ø¨Ø±Ø§Ø² Ø§Ù„Ø­Ø±ÙƒØ§Øª Ø§Ù„Ù…Ù…ÙƒÙ†Ø© Ù„Ù„Ù‚Ø·Ø¹Ø© Ø§Ù„Ù…Ø®ØªØ§Ø±Ø©
            if (selectedPiece && !isInteractionBlocked) {
                 const mustJump = continuousJumpPossible || getAllPossibleMoves(currentPlayer, true, boardState).length > 0;
                 const movesToHighlight = calculateMovesForPieceInternal(selectedPiece.row, selectedPiece.col, mustJump, boardState);
                 movesToHighlight.forEach(move => {
                      const sq = getSquareElement(move.row, move.col);
                      if (sq) { sq.classList.add('possible-move'); sq.style.cursor = 'pointer'; }
                 });
            }

            // Ø¥Ø¶Ø§ÙØ©/Ø¥Ø²Ø§Ù„Ø© ØªØ£Ø«ÙŠØ±Ø§Øª Ø§Ù„ØªØ­ÙˆÙŠÙ… Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø­Ø§Ù„Ø© Ø§Ù„ØªÙØ§Ø¹Ù„
            if (!isInteractionBlocked) { addHoverEffects(); } else { removeHoverEffects(); }
        }

        // --- Drag and Drop (Touch and Mouse) ---
        let currentDraggingPiece = null;
        let initialX, initialY, currentX, currentY;
        let xOffset = 0, yOffset = 0;
        const dragThreshold = 5; // Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ù„Ù„Ø­Ø±ÙƒØ© Ù„Ø¨Ø¯Ø¡ Ø§Ù„Ø³Ø­Ø¨ Ø§Ù„ÙØ¹Ù„ÙŠ

        function addDragListeners(pieceEl = null) {
             const pieces = pieceEl ? [pieceEl] : boardElement.querySelectorAll('.piece');
             pieces.forEach(piece => {
                 // Ø¥Ø²Ø§Ù„Ø© Ù…Ø³ØªÙ…Ø¹Ø§Øª Ù…ÙˆØ¬ÙˆØ¯Ø© Ù„Ù…Ù†Ø¹ Ø§Ù„ØªÙƒØ±Ø§Ø±
                 piece.removeEventListener('mousedown', dragStart);
                 piece.removeEventListener('mouseup', dragEnd);
                 piece.removeEventListener('touchstart', dragStart);
                 piece.removeEventListener('touchend', dragEnd);
                 piece.removeEventListener('touchcancel', dragEnd); // Ø¥Ø¶Ø§ÙØ© Ù„Ù…Ø³ØªÙ…Ø¹ Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ù„Ù…Ø³

                 // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø³ØªÙ…Ø¹Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
                 piece.addEventListener('mousedown', dragStart);
                 piece.addEventListener('mouseup', dragEnd);
                 piece.addEventListener('touchstart', dragStart);
                 piece.addEventListener('touchend', dragEnd);
                 piece.addEventListener('touchcancel', dragEnd);
             });

            // Ø¥Ø¶Ø§ÙØ© Ù…Ø³ØªÙ…Ø¹Ø§Øª Ø§Ù„Ø­Ø±ÙƒØ© Ø¹Ù„Ù‰ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ù…Ø³ØªÙ†Ø¯ Ù„Ù„Ø³Ø­Ø¨
            document.removeEventListener('mousemove', drag);
            document.removeEventListener('touchmove', drag);
            document.addEventListener('mousemove', drag);
            document.addEventListener('touchmove', drag, { passive: false }); // Ø§Ø³ØªØ®Ø¯Ø§Ù… { passive: false } Ù„Ù„Ø³Ù…Ø§Ø­ Ø¨ preventDefault
        }


        function dragStart(e) {
            const pieceElement = e.target.closest('.piece');
            if (!pieceElement || !pieceElement.classList.contains('interactive')) return; // ÙÙ‚Ø· Ø§Ø³Ù…Ø­ Ø¨Ø³Ø­Ø¨ Ø§Ù„Ù‚Ø·Ø¹ Ø§Ù„ØªÙØ§Ø¹Ù„ÙŠØ©

            // Ù…Ù†Ø¹ Ø§Ù„Ø³Ù„ÙˆÙƒ Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ Ù„Ù„ØªÙ…Ø±ÙŠØ±/Ø§Ù„ØªÙƒØ¨ÙŠØ± Ø¹Ù„Ù‰ Ø§Ù„Ù„Ù…Ø³
            if (e.type === 'touchstart') { e.preventDefault(); }

            currentDraggingPiece = pieceElement;
            const square = currentDraggingPiece.closest('.square');
            const row = parseInt(square.dataset.row);
            const col = parseInt(square.dataset.col);

             // Ø§Ø®ØªØ± Ø§Ù„Ù‚Ø·Ø¹Ø© Ø¹Ù†Ø¯ Ø¨Ø¯Ø¡ Ø§Ù„Ø³Ø­Ø¨
            selectPiece(row, col, currentDraggingPiece);

            // Get the touch or mouse event coordinates
            if (e.type === 'touchstart') {
                initialX = e.touches[0].clientX;
                initialY = e.touches[0].clientY;
            } else {
                initialX = e.clientX;
                initialY = e.clientY;
            }

             // Calculate initial offset relative to the piece center
             const pieceRect = currentDraggingPiece.getBoundingClientRect();
             const pieceCenterX = pieceRect.left + pieceRect.width / 2;
             const pieceCenterY = pieceRect.top + pieceRect.height / 2;
             xOffset = initialX - pieceCenterX;
             yOffset = initialY - pieceCenterY;

            currentDraggingPiece.classList.add('dragging');
            currentDraggingPiece.style.transition = 'none'; // Disable transitions while dragging
             // Ensure Z-index is high while dragging
            currentDraggingPiece.style.zIndex = 1000;

             // Ø£Ø¶Ù ÙØ¦Ø© Ù„Ø¬Ø³Ù… Ø§Ù„Ù…Ø³ØªÙ†Ø¯ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø³Ø­Ø¨ Ù„Ø±Ø¨Ù…Ø§ ØªØ¹Ø·ÙŠÙ„ Ø§Ù„ØªÙ…Ø±ÙŠØ± Ø§Ù„Ø¹Ø§Ù…
             // document.body.classList.add('no-scroll'); // Ù‚Ø¯ Ù„Ø§ ÙŠÙƒÙˆÙ† Ø¶Ø±ÙˆØ±ÙŠÙ‹Ø§ Ù…Ø¹ touch-action: none Ùˆ preventDefault
        }

        function drag(e) {
            if (!currentDraggingPiece) return;

            // Ù…Ù†Ø¹ Ø§Ù„Ø³Ù„ÙˆÙƒ Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ Ù„Ù„ØªÙ…Ø±ÙŠØ± Ø¹Ù„Ù‰ Ø§Ù„Ù„Ù…Ø³
            if (e.type === 'touchmove') { e.preventDefault(); }

             // Get the touch or mouse event coordinates
            if (e.type === 'touchmove') {
                currentX = e.touches[0].clientX;
                currentY = e.touches[0].clientY;
            } else {
                currentX = e.clientX;
                currentY = e.clientY;
            }

             // Calculate the new position relative to the initial click/touch point and offset
             const newX = currentX - initialX;
             const newY = currentY - initialY;

             // Apply the translation relative to the piece's normal position (which is centered in the square)
             // Note: The piece's base transform is translate(-50%, -50%)
             currentDraggingPiece.style.transform = `translate(calc(-50% + ${newX}px - ${xOffset}px), calc(-50% + ${newY}px - ${yOffset}px)) scale(1.1)`;
        }

        function dragEnd(e) {
            if (!currentDraggingPiece) return;

            currentDraggingPiece.classList.remove('dragging');
            currentDraggingPiece.style.transition = ''; // Restore transitions
            currentDraggingPiece.style.zIndex = 10; // Restore default z-index
             // document.body.classList.remove('no-scroll');

            // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…Ø±Ø¨Ø¹ Ø§Ù„Ø°ÙŠ Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„Ø³Ø­Ø¨ ÙÙˆÙ‚Ù‡
            const finalTouchOrMouseX = e.type === 'touchend' ? e.changedTouches[0].clientX : e.clientX;
            const finalTouchOrMouseY = e.type === 'touchend' ? e.changedTouches[0].clientY : e.clientY;
            const elementsUnder = document.elementsFromPoint(finalTouchOrMouseX, finalTouchOrMouseY);
            const targetSquare = elementsUnder.find(el => el.classList.contains('square') && el !== currentDraggingPiece.closest('.square')); // Ø§Ø¨Ø­Ø« Ø¹Ù† Ù…Ø±Ø¨Ø¹ ØºÙŠØ± Ø§Ù„Ù…Ø±Ø¨Ø¹ Ø§Ù„Ø£ØµÙ„ÙŠ

            const fromSquare = currentDraggingPiece.closest('.square');
            const fromRow = parseInt(fromSquare.dataset.row);
            const fromCol = parseInt(fromSquare.dataset.col);

            currentDraggingPiece = null; // Clear the dragging piece reference

            if (targetSquare && targetSquare.classList.contains('dark-square')) {
                 const toRow = parseInt(targetSquare.dataset.row);
                 const toCol = parseInt(targetSquare.dataset.col);

                 // Ø­Ø§ÙˆÙ„ Ø§Ù„Ù‚ÙŠØ§Ù… Ø¨Ø§Ù„Ø­Ø±ÙƒØ© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø±Ø¨Ø¹ Ø§Ù„Ù…Ø³ØªÙ‡Ø¯Ù
                 let move; const mustJump = continuousJumpPossible || getAllPossibleMoves(currentPlayer, true, boardState).length > 0;
                 const possibleMovesForSelected = calculateMovesForPieceInternal(fromRow, fromCol, mustJump, boardState);
                 move = possibleMovesForSelected.find(m => m.row === toRow && m.col === toCol);

                 if (move) {
                    saveCurrentStateToHistory();
                    // animateAndMovePiece Ø³ØªÙ‚ÙˆÙ… Ø¨ØªØ­Ø¯ÙŠØ« Ù…ÙˆØ¶Ø¹ Ø§Ù„Ù‚Ø·Ø¹Ø© Ùˆ renderBoard Ø³ØªÙ‚ÙˆÙ… Ø¨ØªØ±ØªÙŠØ¨Ù‡Ø§ ÙÙŠ Ø§Ù„Ù…Ø±Ø¨Ø¹ Ø§Ù„Ø¬Ø¯ÙŠØ¯
                    animateAndMovePiece(fromRow, fromCol, move);
                 } else {
                    // Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ø§Ù„Ø­Ø±ÙƒØ© Ù…Ù…ÙƒÙ†Ø©ØŒ Ø£Ø¹Ø¯ Ø§Ù„Ù‚Ø·Ø¹Ø© Ø¥Ù„Ù‰ Ù…ÙƒØ§Ù†Ù‡Ø§ Ø§Ù„Ø£ØµÙ„ÙŠ Ø¨Ø§Ù„ØªØ­Ø±ÙŠÙƒ
                    resetPiecePosition(fromSquare, fromRow, fromCol);
                 }
            } else {
                 // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙ†ØªÙ‡ Ø§Ù„Ø³Ø­Ø¨ ÙÙˆÙ‚ Ù…Ø±Ø¨Ø¹ ØµØ§Ù„Ø­ØŒ Ø£Ø¹Ø¯ Ø§Ù„Ù‚Ø·Ø¹Ø© Ø¥Ù„Ù‰ Ù…ÙƒØ§Ù†Ù‡Ø§ Ø§Ù„Ø£ØµÙ„ÙŠ
                 resetPiecePosition(fromSquare, fromRow, fromCol);
            }

            // deselectPiece() Ø³ÙŠØªÙ… Ø§Ø³ØªØ¯Ø¹Ø§Ø¤Ù‡Ø§ ÙÙŠ handlePostMoveChecks Ø£Ùˆ Ø¹Ù†Ø¯ Ø§Ù„Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ù…Ø±Ø¨Ø¹ ØºÙŠØ± ØµØ§Ù„Ø­
            // Ø£Ùˆ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ø³ØªØ¯Ø¹Ø§Ø¤Ù‡Ø§ Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ø§Ù„Ø­Ø±ÙƒØ© Ù‚ÙØ²Ø© Ù…Ø³ØªÙ…Ø±Ø©
             if (!continuousJumpPossible || !targetSquare || !targetSquare.classList.contains('possible-move')) {
                 deselectPiece();
             }
        }

        function resetPiecePosition(squareElement, row, col) {
             const pieceEl = squareElement.querySelector(`.piece[data-piece-id="${row}-${col}"]`);
             if (pieceEl) {
                 pieceEl.style.transition = 'transform 0.2s ease'; // Restore animation
                 pieceEl.style.transform = 'translate(-50%, -50%)'; // Reset position
                 pieceEl.style.zIndex = 10; // Restore z-index
             }
             deselectPiece(); // Ø¥Ù„ØºØ§Ø¡ ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù‚Ø·Ø¹Ø©
             requestRender(); // Ø¥Ø¹Ø§Ø¯Ø© Ø¹Ø±Ø¶ Ù„ØªÙ†Ø¸ÙŠÙ Ø£ÙŠ Ø¥Ø¨Ø±Ø§Ø²Ø§Øª
        }


        // --- Board & Piece Style Functions ---
        function applyBoardStyle(styleName) {
            const validStyles = ['wood', 'desert', 'stone-path', 'emerald', 'volcano', 'royal']; if (!validStyles.includes(styleName)) styleName = 'wood';
            boardElement.className = ' '; boardElement.id = 'board'; validStyles.forEach(s => boardElement.classList.remove(`board-style-${s}`)); boardElement.classList.add(`board-style-${styleName}`);
            currentBoardStyle = styleName; localStorage.setItem('boardStyle', styleName);
        }
        function updateSelectedBoardOption() { const options = boardOptionsContainer.querySelectorAll('.board-option'); options.forEach(option => { option.classList.toggle('selected-style', option.dataset.style === currentBoardStyle); }); }
        function loadBoardStyle() { let loadedStyle = localStorage.getItem('boardStyle') || 'wood'; const validStyles = ['wood', 'desert', 'stone-path', 'emerald', 'volcano', 'royal']; if (!validStyles.includes(loadedStyle)) { loadedStyle = 'wood'; localStorage.setItem('boardStyle', loadedStyle); } applyBoardStyle(loadedStyle); }
        function applyPieceStyle(styleName) {
            const validStyles = ['classic', 'flat', 'crimson', 'azure', 'forest', 'royal']; if (!validStyles.includes(styleName)) styleName = 'classic';
            validStyles.forEach(s => bodyElement.classList.remove(`piece-style-${s}`)); bodyElement.classList.add(`piece-style-${styleName}`);
            currentPieceStyle = styleName; localStorage.setItem('pieceStyle', styleName);
            updateTurnIndicatorVisuals(); if (gameContainer.style.display === 'flex') { requestRender(); }
        }
        function updateSelectedPieceOption() { const options = pieceOptionsContainer.querySelectorAll('.piece-option'); options.forEach(option => { option.classList.toggle('selected-style', option.dataset.style === currentPieceStyle); }); }
        function loadPieceStyle() { let loadedStyle = localStorage.getItem('pieceStyle') || 'classic'; const validStyles = ['classic', 'flat', 'crimson', 'azure', 'forest', 'royal']; if (!validStyles.includes(loadedStyle)) { loadedStyle = 'classic'; localStorage.setItem('pieceStyle', loadedStyle); } applyPieceStyle(loadedStyle); }

        // --- Game Logic ---
        function handlePieceClick(event) {
            const pieceElement = event.target.closest('.piece'); const squareElement = pieceElement.closest('.square'); if (!squareElement) return;
            const row = parseInt(squareElement.dataset.row); const col = parseInt(squareElement.dataset.col);
             // ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ù‚Ø·Ø¹Ø© Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„ØªÙØ§Ø¹Ù„ (Ù„ÙŠØ³Øª ÙÙŠ Ø´Ø§Ø´Ø© Ø£Ø®Ø±Ù‰ØŒ Ø¯ÙˆØ± Ø§Ù„Ù„Ø§Ø¹Ø¨ØŒ Ù„ÙŠØ³Øª Ù‚ÙØ²Ø© Ù…Ø³ØªÙ…Ø±Ø© Ù„Ù‚Ø·Ø¹Ø© Ø£Ø®Ø±Ù‰)
             if (!pieceElement.classList.contains('interactive')) return;

            const pieceData = boardState[row][col]; // Ù‡Ø°Ø§ Ø§Ù„ØªØ­Ù‚Ù‚ Ø£ØµØ¨Ø­ Ø¶Ù…Ù† Ø´Ø±Ø· interactive class

            if (selectedPiece && selectedPiece.row === row && selectedPiece.col === col) { deselectPiece(); } else { selectPiece(row, col, pieceElement); }
        }
        function handleSquareClick(event) {
            const targetSquare = event.target.closest('.square');
             // Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„Ù†Ù‚Ø± ÙÙ‚Ø· Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø±Ø¨Ø¹Ø§Øª Ø§Ù„Ù…Ø¸Ù„Ù…Ø© Ø£Ùˆ Ø§Ù„Ù…Ø±Ø¨Ø¹Ø§Øª Ø§Ù„ØªÙŠ Ù‡ÙŠ Ø­Ø±ÙƒØ§Øª Ù…Ù…ÙƒÙ†Ø©
            if (!targetSquare || (!targetSquare.classList.contains('dark-square') && !targetSquare.classList.contains('possible-move'))) { return; }

             // ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„ØªÙØ§Ø¹Ù„ Ù…Ø³Ù…ÙˆØ­ Ø¨Ù‡ Ø­Ø§Ù„ÙŠÙ‹Ø§
            const isInteractionBlocked = isGameOver || isAiThinking || isSettingsPanelVisible || boardSelectionScreen.classList.contains('visible') || pieceStyleSelectionScreen.classList.contains('visible') || confirmationModal.classList.contains('visible') || (gameMode === 'ai' && currentPlayer === AI_PLAYER);
            if (isInteractionBlocked) return;


            const row = parseInt(targetSquare.dataset.row); const col = parseInt(targetSquare.dataset.col);

            // Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ Ù‚Ø·Ø¹Ø© Ù…Ø®ØªØ§Ø±Ø© ÙˆØ§Ù„Ù…Ø±Ø¨Ø¹ Ø§Ù„Ù…Ø³ØªÙ‡Ø¯Ù ÙØ§Ø±Øº
            if (selectedPiece && !boardState[row][col]) {
                let move; const mustJump = continuousJumpPossible || getAllPossibleMoves(currentPlayer, true, boardState).length > 0;
                const possibleMovesForSelected = calculateMovesForPieceInternal(selectedPiece.row, selectedPiece.col, mustJump, boardState);
                move = possibleMovesForSelected.find(m => m.row === row && m.col === col);

                if (move) { saveCurrentStateToHistory(); animateAndMovePiece(selectedPiece.row, selectedPiece.col, move); }
                else { deselectPiece(); } // Ø§Ù„Ø­Ø±ÙƒØ© ØºÙŠØ± Ù…Ù…ÙƒÙ†Ø© Ù„Ù„Ù…Ø±Ø¨Ø¹ Ø§Ù„Ù…Ø­Ø¯Ø¯
            }
            // Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ Ù‚Ø·Ø¹Ø© Ù…Ø®ØªØ§Ø±Ø© ÙˆØ§Ù„Ù…Ø±Ø¨Ø¹ Ø§Ù„Ù…Ø³ØªÙ‡Ø¯Ù ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ù‚Ø·Ø¹Ø©
            else if (selectedPiece && boardState[row][col]) {
                 const clickedPieceData = boardState[row][col];
                 // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù‚Ø·Ø¹Ø© Ø§Ù„ØªÙŠ ØªÙ… Ø§Ù„Ù†Ù‚Ø± Ø¹Ù„ÙŠÙ‡Ø§ Ù‡ÙŠ Ù‚Ø·Ø¹Ø© Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ø­Ø§Ù„ÙŠ (Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ­Ø¯ÙŠØ¯)
                 if (clickedPieceData && clickedPieceData.player === currentPlayer){
                      // ÙÙ‚Ø· Ø£Ø¹Ø¯ ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù‚Ø·Ø¹Ø© Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ø§Ù„Ù‚ÙØ²Ø© Ø§Ù„Ù…Ø³ØªÙ…Ø±Ø© Ù‚ÙŠØ¯ Ø§Ù„ØªÙ‚Ø¯Ù…
                      if (!continuousJumpPossible) {
                         const clickedPieceElement = targetSquare.querySelector('.piece');
                         selectPiece(row, col, clickedPieceElement);
                      }
                 } else {
                    // ØªÙ… Ø§Ù„Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ù‚Ø·Ø¹Ø© Ø§Ù„Ø®ØµÙ… Ø£Ùˆ Ù…Ø±Ø¨Ø¹ Ø¨Ù‚Ø·Ø¹Ø© ØºÙŠØ± Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„ØªÙØ§Ø¹Ù„ØŒ Ù‚Ù… Ø¨Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ØªØ­Ø¯ÙŠØ¯
                    deselectPiece();
                 }
            }
            // Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù‡Ù†Ø§Ùƒ Ù‚Ø·Ø¹Ø© Ù…Ø®ØªØ§Ø±Ø© ÙˆØªÙ… Ø§Ù„Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ù…Ø±Ø¨Ø¹ ÙØ§Ø±Øº (Ù„Ø§ ØªÙØ¹Ù„ Ø´ÙŠØ¦Ù‹Ø§ Ø³ÙˆÙ‰ Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠ)
            else {
                 deselectPiece();
            }
        }

        function deselectPiece() { if (selectedPiece && selectedPiece.element && boardElement.contains(selectedPiece.element)) { selectedPiece.element.classList.remove('selected'); } selectedPiece = null; requestRender(); }
        function selectPiece(row, col, element) { if (!selectedPiece || selectedPiece.row !== row || selectedPiece.col !== col) { playSound('select'); } deselectPiece(); selectedPiece = { row, col, element }; if (element && boardElement.contains(element)) { element.classList.add('selected'); } requestRender(); }
        function calculateMovesForPieceInternal(r, c, forceJumpsOnly, currentBoard) {
             const piece = currentBoard[r]?.[c]; if (!piece) return []; let moves = []; const jumpMoves = []; const regularMoves = []; const directions = []; const playerDirection = (piece.player === PLAYER_BLACK) ? -1 : 1; directions.push(playerDirection); if (piece.isKing) directions.push(-playerDirection);
             for (const dir of directions) { for (const dc of [-1, 1]) { const jumpedPieceRow = r + dir; const jumpedPieceCol = c + dc; const jumpLandingRow = r + dir * 2; const jumpLandingCol = c + dc * 2; if (isValidSquare(jumpLandingRow, jumpLandingCol) && !currentBoard[jumpLandingRow][jumpLandingCol]) { const jumpedPiece = isValidSquare(jumpedPieceRow, jumpedPieceCol) ? currentBoard[jumpedPieceRow][jumpedPieceCol] : null; if (jumpedPiece && jumpedPiece.player !== piece.player) { jumpMoves.push({ row: jumpLandingRow, col: jumpLandingCol, isJump: true, captured: { row: jumpedPieceRow, col: jumpedPieceCol }, origin: { r, c } }); } } const nr = r + dir; const nc = c + dc; if (isValidSquare(nr, nc) && !currentBoard[nr][nc]) { regularMoves.push({ row: nr, col: nc, isJump: false, origin: { r, c } }); } } }
             const mustJump = forceJumpsOnly || jumpMoves.length > 0; return mustJump ? jumpMoves : regularMoves;
        }
        function getAllPossibleMoves(player, onlyJumps = false, currentBoard = boardState) {
             let allMoves = []; let jumpMovesAvailable = false;
             for (let r = 0; r < BOARD_SIZE; r++) { for (let c = 0; c < BOARD_SIZE; c++) { const piece = currentBoard[r][c]; if (piece && piece.player === player) { const jumpsForPiece = calculateMovesForPieceInternal(r, c, true, currentBoard); if (jumpsForPiece.length > 0) { jumpMovesAvailable = true; break; } } } if (jumpMovesAvailable) break; }
             if (onlyJumps) { for (let r = 0; r < BOARD_SIZE; r++) { for (let c = 0; c < BOARD_SIZE; c++) { const piece = currentBoard[r][c]; if (piece && piece.player === player) { allMoves.push(...calculateMovesForPieceInternal(r, c, true, currentBoard)); } } } return allMoves; }
             for (let r = 0; r < BOARD_SIZE; r++) { for (let c = 0; c < BOARD_SIZE; c++) { const piece = currentBoard[r][c]; if (piece && piece.player === player) { allMoves.push(...calculateMovesForPieceInternal(r, c, jumpMovesAvailable, currentBoard)); } } } return allMoves;
        }
        function animateAndMovePiece(fromRow, fromCol, move) {
            const pieceData = boardState[fromRow][fromCol];
             // Ø§Ø¨Ø­Ø« Ø¹Ù† Ø¹Ù†ØµØ± Ø§Ù„Ù‚Ø·Ø¹Ø© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… data-piece-id Ù„Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ù‚Ø·Ø¹Ø© Ø§Ù„ØµØ­ÙŠØ­Ø©
            const movingPieceElement = getSquareElement(fromRow, fromCol)?.querySelector(`.piece[data-piece-id="${fromRow}-${fromCol}"]`);
            const targetSquareElement = getSquareElement(move.row, move.col);

            if (!pieceData || !movingPieceElement || !targetSquareElement) { console.error("Animation error: Missing elements", { fromRow, fromCol, move });
                 // Ø­Ø§ÙˆÙ„ ØªÙ†ÙÙŠØ° Ø§Ù„Ù…Ù†Ø·Ù‚ Ø¨Ø¯ÙˆÙ† ØªØ­Ø±ÙŠÙƒ Ù…Ø±Ø¦ÙŠ Ø¥Ø°Ø§ ÙØ´Ù„Øª Ø§Ù„Ø¹Ù†Ø§ØµØ±
                 executeMoveLogic(fromRow, fromCol, move);
                 handlePostMoveChecks(move);
                 return;
             }

            movingPieceElement.classList.add('moving');
            movingPieceElement.style.zIndex = 100;
            movingPieceElement.style.transition = 'transform 0.3s ease-in-out'; // Ø¥Ø¶Ø§ÙØ© Ø§Ù†ØªÙ‚Ø§Ù„ Ù…Ø­Ø¯Ø¯ Ù„Ù„Ø­Ø±ÙƒØ©

            // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…ÙˆØ¶Ø¹ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ Ù„Ù„Ù‚Ø·Ø¹Ø© Ø¨Ø§Ù„Ù†Ø³Ø¨Ø© Ù„Ù…ÙˆØ¶Ø¹Ù‡Ø§ Ø§Ù„Ø£ÙˆÙ„ÙŠ (Ø§Ù„Ø°ÙŠ Ù‡Ùˆ translate(-50%, -50%))
            const fromSquareRect = getSquareElement(fromRow, fromCol).getBoundingClientRect();
            const toSquareRect = targetSquareElement.getBoundingClientRect();
            const boardRect = boardElement.getBoundingClientRect();

            // Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ù…Ø±ÙƒØ² Ø§Ù„Ù…Ø±Ø¨Ø¹ Ø§Ù„Ù…Ø³ØªÙ‡Ø¯Ù Ø¨Ø§Ù„Ù†Ø³Ø¨Ø© Ù„Ù…Ø±ÙƒØ² Ø§Ù„Ù…Ø±Ø¨Ø¹ Ø§Ù„Ø£ØµÙ„ÙŠ
            const deltaX = (toSquareRect.left + toSquareRect.width/2) - (fromSquareRect.left + fromSquareRect.width/2);
            const deltaY = (toSquareRect.top + toSquareRect.height/2) - (fromSquareRect.top + fromSquareRect.height/2);

            // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†Ø³Ø¨ÙŠ
            movingPieceElement.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;


            if (move.isJump) {
                 playSound('capture');
                 // ØªØ£Ø®ÙŠØ± Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù‚Ø·Ø¹Ø© Ø§Ù„Ù…Ø£Ø³ÙˆØ±Ø© Ù‚Ù„ÙŠÙ„Ø§Ù‹ Ø¨Ø¹Ø¯ Ø¨Ø¯Ø¡ Ø­Ø±ÙƒØ© Ø§Ù„Ù‚ÙØ²Ø©
                 setTimeout(() => {
                    const capturedSquare = getSquareElement(move.captured.row, move.captured.col);
                    const capturedPieceEl = capturedSquare?.querySelector('.piece');
                    if (capturedPieceEl) {
                         // Ø¥Ø¶Ø§ÙØ© ÙØ¦Ø© ØªÙ„Ø§Ø´ÙŠ Ù„Ù„Ù‚Ø·Ø¹Ø© Ø§Ù„Ù…Ø£Ø³ÙˆØ±Ø©
                        capturedPieceEl.classList.add('captured-fade');
                        // Ø¥Ø²Ø§Ù„Ø© Ø¹Ù†ØµØ± Ø§Ù„Ù‚Ø·Ø¹Ø© Ø§Ù„Ù…Ø£Ø³ÙˆØ±Ø© Ø¨Ø¹Ø¯ Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„ØªØ­Ø±ÙŠÙƒ ÙˆØ§Ù„ØªÙ„Ø§Ø´ÙŠ
                        setTimeout(() => capturedPieceEl.remove(), 400);
                    }
                 }, 100); // ØªØ£Ø®ÙŠØ± Ø¨Ø³ÙŠØ·

            } else { playSound('move'); }

            deselectPiece(); // Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…Ø±Ø¦ÙŠ ÙÙˆØ± Ø¨Ø¯Ø¡ Ø§Ù„Ø­Ø±ÙƒØ©

            // Ø§Ù†ØªØ¸Ø± Ø­ØªÙ‰ ØªÙƒØªÙ…Ù„ Ø§Ù„Ø­Ø±ÙƒØ© Ø§Ù„Ù…Ø±Ø¦ÙŠØ© Ù‚Ø¨Ù„ ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ù„ÙˆØ­Ø© ÙˆÙ…Ù†Ø·Ù‚ Ø§Ù„Ù„Ø¹Ø¨Ø©
            setTimeout(() => {
                movingPieceElement.classList.remove('moving');
                 movingPieceElement.style.transition = ''; // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ø§Ù„Ù…Ø®ØµØµ Ù„Ù„Ø­Ø±ÙƒØ©
                movingPieceElement.style.transform = 'translate(-50%, -50%)'; // Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ
                movingPieceElement.style.zIndex = 10; // Ø¥Ø¹Ø§Ø¯Ø© z-index Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ

                 // ØªÙ†ÙÙŠØ° Ù…Ù†Ø·Ù‚ Ø§Ù„Ù„Ø¹Ø¨Ø© Ù„ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ù„ÙˆØ­Ø© Ø§Ù„Ø¯Ø§Ø®Ù„ÙŠØ©
                 executeMoveLogic(fromRow, fromCol, move);

                 // Ù†Ù‚Ù„ Ø¹Ù†ØµØ± Ø§Ù„Ù‚Ø·Ø¹Ø© Ø¥Ù„Ù‰ Ø§Ù„Ù…Ø±Ø¨Ø¹ Ø§Ù„Ø¬Ø¯ÙŠØ¯ ÙÙŠ DOM
                 // ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„Ù…Ø±Ø¨Ø¹ Ø§Ù„Ù…Ø³ØªÙ‡Ø¯Ù Ù…ÙˆØ¬ÙˆØ¯ Ù‚Ø¨Ù„ Ù†Ù‚Ù„ Ø§Ù„Ø¹Ù†ØµØ±
                 const destinationSquare = getSquareElement(move.row, move.col);
                 if (destinationSquare) {
                     // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù‚Ø·Ø¹Ø© Ù…Ù† Ù…Ø±Ø¨Ø¹Ù‡Ø§ Ø§Ù„Ø£ØµÙ„ÙŠ ÙÙŠ Ø§Ù„Ù€ DOM Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø© Ø¨Ø§Ù„ÙØ¹Ù„ (ÙÙŠ Ø­Ø§Ù„Ø© Ø§Ù„Ø³Ø­Ø¨ Ø§Ù„Ø³Ø±ÙŠØ¹)
                     const pieceInOrigin = getSquareElement(fromRow, fromCol)?.querySelector(`.piece[data-piece-id="${fromRow}-${fromCol}"]`);
                      if(pieceInOrigin && pieceInOrigin !== movingPieceElement) {
                           pieceInOrigin.remove();
                      }

                     destinationSquare.appendChild(movingPieceElement);
                     movingPieceElement.dataset.pieceId = `${move.row}-${move.col}`; // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù€ ID Ù„Ù„Ù‚Ø·Ø¹Ø© Ø§Ù„Ù…Ù†Ù‚ÙˆÙ„Ø©
                 } else {
                      console.error("Animation error: Destination square not found.", move.row, move.col);
                 }

                // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØªØªÙˆÙŠØ¬ Ø§Ù„Ù‚Ø·Ø¹Ø© Ø¨Ø¹Ø¯ Ø§Ù„Ù†Ù‚Ù„
                const finalPieceData = boardState[move.row][move.col];
                if(finalPieceData?.isKing && !movingPieceElement.classList.contains('king')) {
                     movingPieceElement.classList.add('king');
                }

                // Ù…ØªØ§Ø¨Ø¹Ø© Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù‚ÙØ²Ø§Øª Ø§Ù„Ù…Ø³ØªÙ…Ø±Ø© ÙˆØ¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ø¯ÙˆØ±
                handlePostMoveChecks(move);

            }, 300); // ÙŠØ¬Ø¨ Ø£Ù† ÙŠØªØ·Ø§Ø¨Ù‚ Ù‡Ø°Ø§ Ø§Ù„ØªØ£Ø®ÙŠØ± ØªÙ‚Ø±ÙŠØ¨Ù‹Ø§ Ù…Ø¹ Ù…Ø¯Ø© Ø§Ù†ØªÙ‚Ø§Ù„ CSS
        }

        function executeMoveLogic(fromRow, fromCol, move) {
             const pieceData = boardState[fromRow][fromCol]; if (!pieceData) { console.error("Move logic error", fromRow, fromCol); return; }
             const toRow = move.row; const toCol = move.col; boardState[toRow][toCol] = pieceData; boardState[fromRow][fromCol] = null;
             if (move.isJump && move.captured) { const capR = move.captured.row; const capC = move.captured.col; if (isValidSquare(capR, capC) && boardState[capR][capC]) { if (boardState[capR][capC].player === PLAYER_WHITE) { capturedByBlack++; } else { capturedByWhite++; } boardState[capR][capC] = null; updateCapturedCounters(); } else { console.warn("Capture logic warning", capR, capC); } }
             checkForKing(toRow, toCol);
        }
        function handlePostMoveChecks(move) {
            const toRow = move.row; const toCol = move.col; const movedPieceData = boardState[toRow][toCol];
            if (move.isJump && movedPieceData) {
                const nextJumps = calculateMovesForPieceInternal(toRow, toCol, true, boardState);
                if (nextJumps.length > 0) {
                    continuousJumpPossible = true;
                    // Ø¥Ø¹Ø§Ø¯Ø© ØªØ­Ø¯ÙŠØ¯ Ù†ÙØ³ Ø§Ù„Ù‚Ø·Ø¹Ø© Ø§Ù„ØªÙŠ Ù‚Ø§Ù…Øª Ø¨Ø§Ù„Ù‚ÙØ²Ø© Ù„Ù…ØªØ§Ø¨Ø¹Ø© Ø§Ù„Ù‚ÙØ²Ø© Ø§Ù„Ù…Ø³ØªÙ…Ø±Ø©
                    selectPiece(toRow, toCol, getSquareElement(toRow, toCol)?.querySelector('.piece'));
                    updateStatus("Complete the jump!");
                    requestRender();
                    // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø¯ÙˆØ± Ø§Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ±ØŒ Ø§Ø¬Ø¹Ù„Ù‡ ÙŠÙÙƒØ± ÙˆÙŠÙ‚ÙˆÙ… Ø¨Ø§Ù„Ù‚ÙØ²Ø© Ø§Ù„ØªØ§Ù„ÙŠØ© ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
                    if (gameMode === 'ai' && currentPlayer === AI_PLAYER && !isGameOver) {
                        isAiThinking = true;
                        updateUndoButton(); // ØªØ¹Ø·ÙŠÙ„ Ø§Ù„ØªØ±Ø§Ø¬Ø¹ Ø£Ø«Ù†Ø§Ø¡ ØªÙÙƒÙŠØ± Ø§Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ±
                        updateHintButton(); // ØªØ¹Ø·ÙŠÙ„ Ø§Ù„ØªÙ„Ù…ÙŠØ­ Ø£Ø«Ù†Ø§Ø¡ ØªÙÙƒÙŠØ± Ø§Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ±
                        renderBoard();
                         // ØªØ£Ø®ÙŠØ± ØµØºÙŠØ± Ù‚Ø¨Ù„ Ø­Ø±ÙƒØ© Ø§Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ± Ø§Ù„ØªØ§Ù„ÙŠØ©
                        setTimeout(makeAiMove, 500 + Math.random() * 50);
                    }
                    return;
                }
            }
            continuousJumpPossible = false;
            endTurn();
        }
        function checkForKing(row, col) { const piece = boardState[row]?.[col]; if (!piece || piece.isKing) return false; if ((piece.player === PLAYER_BLACK && row === 0) || (piece.player === PLAYER_WHITE && row === BOARD_SIZE - 1)) { piece.isKing = true; playSound('king');
             // ØªØ­Ø¯ÙŠØ« ÙØ¦Ø© Ø§Ù„Ø¹Ù†ØµØ± Ø§Ù„Ù…Ø±Ø¦ÙŠ Ù„Ù„Ù‚Ø·Ø¹Ø© Ø§Ù„ØªÙŠ Ø£ØµØ¨Ø­Øª Ù…Ù„ÙƒÙ‹Ø§
             const pieceEl = getSquareElement(row, col)?.querySelector('.piece');
             if (pieceEl) { pieceEl.classList.add('king'); }
             return true; } return false; }
        function endTurn() { deselectPiece(); if (checkWinCondition()) { return; } switchPlayer(); }
        function switchPlayer() {
            currentPlayer = getOpponent(currentPlayer); continuousJumpPossible = false; updateStatus(); startTurnTimer(); requestRender();
            if (gameMode === 'ai' && currentPlayer === AI_PLAYER && !isGameOver) { isAiThinking = true; updateUndoButton(); updateHintButton(); renderBoard(); requestAnimationFrame(() => { setTimeout(makeAiMove, 700 + Math.random() * 300); }); }
            else { isAiThinking = false; updateUndoButton(); updateHintButton(); }
        }
        function updateStatus(message = null) { whiteIndicator.classList.remove('active-turn'); blackIndicator.classList.remove('active-turn'); if (!isGameOver) { if (currentPlayer === PLAYER_WHITE) whiteIndicator.classList.add('active-turn'); else blackIndicator.classList.add('active-turn'); } if(message) console.log("Status Update:", message); }
        function checkWinCondition() {
            if (isGameOver) return true; let blackPieces = 0; let whitePieces = 0; let blackCanMove = false; let whiteCanMove = false;
            // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù‚Ø·Ø¹ Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø© Ø¹Ù„Ù‰ Ø§Ù„Ù„ÙˆØ­Ø© ÙˆØªØ­Ø¯ÙŠØ¯ Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ Ø­Ø±ÙƒØ§Øª Ù…Ù…ÙƒÙ†Ø© Ù„Ø£ÙŠ Ù„Ø§Ø¹Ø¨
            for (let r = 0; r < BOARD_SIZE; r++) { for (let c = 0; c < BOARD_SIZE; c++) { const piece = boardState[r][c]; if (piece) { if (piece.player === PLAYER_BLACK) blackPieces++; else whitePieces++; } } }
            blackCanMove = getAllPossibleMoves(PLAYER_BLACK, false, boardState).length > 0;
            whiteCanMove = getAllPossibleMoves(PLAYER_WHITE, false, boardState).length > 0;

            let gameOverTriggered = false; let winMessage = "";
            if (whitePieces === 0) { winMessage = "Black Wins (No White pieces left)!"; gameOverTriggered = true; }
            else if (blackPieces === 0) { winMessage = "White Wins (No Black pieces left)!"; gameOverTriggered = true; }
            else if (currentPlayer === PLAYER_BLACK && !blackCanMove && whitePieces > 0) { winMessage = "White Wins (Black has no moves)!"; gameOverTriggered = true; }
            else if (currentPlayer === PLAYER_WHITE && !whiteCanMove && blackPieces > 0) { winMessage = "Black Wins (White has no moves)!"; gameOverTriggered = true; }

             // Ø­Ø§Ù„Ø© Ø§Ù„ØªØ¹Ø§Ø¯Ù„: Ø¥Ø°Ø§ Ù„Ù… ÙŠØ³ØªØ·Ø¹ Ø£ÙŠ Ù…Ù† Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ† Ø§Ù„ØªØ­Ø±Ùƒ
             if (!blackCanMove && !whiteCanMove && blackPieces > 0 && whitePieces > 0) {
                 winMessage = "Draw (No moves possible)!";
                 gameOverTriggered = true;
             }

            if (gameOverTriggered) { endGame(winMessage); return true; } return false;
        }

        function saveCurrentStateToHistory() { const stateToSave = { boardState: deepCopyBoard(boardState), currentPlayer: currentPlayer, capturedByBlack: capturedByBlack, capturedByWhite: capturedByWhite, continuousJumpPossible: continuousJumpPossible, }; moveHistory.push(stateToSave); updateUndoButton(); }
        function undoMove() {
            // Ù„Ø§ ØªØ³Ù…Ø­ Ø¨Ø§Ù„ØªØ±Ø§Ø¬Ø¹ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù„Ø¹Ø¨Ø© Ù‚Ø¯ Ø§Ù†ØªÙ‡ØªØŒ Ø§Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ± ÙŠÙÙƒØ±ØŒ Ø£Ùˆ ÙÙŠ Ù…Ù†ØªØµÙ Ù‚ÙØ²Ø© Ù…Ø³ØªÙ…Ø±Ø© (Ø¥Ù„Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø£ÙˆÙ„ Ø®Ø·ÙˆØ© ÙÙŠ Ø§Ù„Ù‚ÙØ²Ø©)
             if (isGameOver || isAiThinking || (continuousJumpPossible && moveHistory.length > 0 && moveHistory[moveHistory.length - 1].continuousJumpPossible !== continuousJumpPossible)) {
                  console.log("Undo not allowed in current state.");
                 return;
            }
             if (moveHistory.length === 0) return; stopTurnTimer();

            // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù„Ø¹Ø¨Ø© Ø¶Ø¯ Ø§Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ±ØŒ Ø§Ù„ØªØ±Ø§Ø¬Ø¹ ÙŠØ¹ÙˆØ¯ Ø®Ø·ÙˆØªÙŠÙ† (Ø¯ÙˆØ± Ø§Ù„Ù„Ø§Ø¹Ø¨ ÙˆØ¯ÙˆØ± Ø§Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ±)
             const stepsToUndo = (gameMode === 'ai' && moveHistory.length >= 2 && !moveHistory[moveHistory.length - 1].continuousJumpPossible) ? 2 : 1;

             for (let i = 0; i < stepsToUndo; i++) {
                 if (moveHistory.length === 0) break; // ØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø®Ø·ÙˆØ§Øª Ù„Ù„ØªØ±Ø§Ø¬Ø¹ Ø¹Ù†Ù‡Ø§
                 const previousState = moveHistory.pop();
                 boardState = previousState.boardState;
                 currentPlayer = previousState.currentPlayer;
                 capturedByBlack = previousState.capturedByBlack;
                 capturedByWhite = previousState.capturedByWhite;
                 continuousJumpPossible = previousState.continuousJumpPossible;
             }

            selectedPiece = null; isGameOver = false; gameOverScreen.classList.remove('visible');
            updateCapturedCounters(); updateStatus(); updateUndoButton(); updateHintButton(); createBoardUI(); renderBoard(); startTurnTimer(); isAiThinking = false;
        }
        function clearHintHighlights() { if (hintTimeoutId) { clearTimeout(hintTimeoutId); hintTimeoutId = null; } document.querySelectorAll('.hint-piece-suggestion').forEach(el => { el.classList.remove('hint-piece-suggestion'); }); document.querySelectorAll('.square.possible-move.hint-move-suggestion').forEach(sq => { sq.classList.remove('hint-move-suggestion'); }); }
        function showHint() {
             clearHintHighlights(); if (isGameOver || isAiThinking || (gameMode === 'ai' && currentPlayer === AI_PLAYER)) { return; }
             let bestHintMove;
             const playerMoves = getAllPossibleMoves(currentPlayer, false, boardState);

             if (playerMoves.length === 0) {
                 console.log("Hint: No moves available for the current player.");
                 // Ø±Ø¨Ù…Ø§ ØªØ¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø© Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù‡Ù†Ø§
                 return;
             }

             // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù‡Ù†Ø§Ùƒ Ù‚ÙØ²Ø© Ù…Ø³ØªÙ…Ø±Ø©ØŒ ÙÙ‚Ø¯Ù… ØªÙ„Ù…ÙŠØ­Ù‹Ø§ Ù„Ø£ÙŠ Ù…Ù† Ø§Ù„Ù‚ÙØ²Ø§Øª Ø§Ù„Ù…ØªØ§Ø­Ø© Ù…Ù† Ø§Ù„Ù‚Ø·Ø¹Ø© Ø§Ù„Ù…Ø­Ø¯Ø¯Ø©
             if (continuousJumpPossible && selectedPiece) {
                 const nextJumps = calculateMovesForPieceInternal(selectedPiece.row, selectedPiece.col, true, boardState);
                 if (nextJumps.length > 0) {
                     bestHintMove = nextJumps[Math.floor(Math.random() * nextJumps.length)]; // Ø§Ø®ØªØ± Ù‚ÙØ²Ø© Ø¹Ø´ÙˆØ§Ø¦ÙŠØ© Ù…Ù† Ø§Ù„Ù‚ÙØ²Ø§Øª Ø§Ù„Ù…ØªØ§Ø­Ø© Ù„Ù„Ù‚Ø·Ø¹Ø© Ø§Ù„Ù…Ø­Ø¯Ø¯Ø©
                     bestHintMove.origin = { r: selectedPiece.row, c: selectedPiece.col }; // ØªØ£ÙƒØ¯ Ù…Ù† ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ø£ØµÙ„ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­
                 } else {
                      console.warn("Hint: Continuous jump required, but no next jump found for the selected piece.");
                      return; // Ù„Ø§ ÙŠÙˆØ¬Ø¯ ØªÙ„Ù…ÙŠØ­ Ù…Ù…ÙƒÙ†
                 }
             } else {
                  // Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù‡Ù†Ø§Ùƒ Ù‚ÙØ²Ø© Ù…Ø³ØªÙ…Ø±Ø©ØŒ Ø§Ø³ØªØ®Ø¯Ù… Minimax Ù„Ø§Ø®ØªÙŠØ§Ø± Ø£ÙØ¶Ù„ Ø­Ø±ÙƒØ© (Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„ØµØ¹ÙˆØ¨Ø© Ù„ÙŠØ³Øª Ø³Ù‡Ù„Ø©)
                  if (gameMode === 'ai' && aiDifficulty !== DIFFICULTIES.EASY) {
                      const depth = (aiDifficulty === DIFFICULTIES.HARD) ? MINIMAX_DEPTH.HARD : MINIMAX_DEPTH.MEDIUM;
                      bestHintMove = findBestMoveMinimax(currentPlayer, depth).move;
                  } else {
                      // ÙÙŠ Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø³Ù‡Ù„ Ø£Ùˆ Ø¶Ø¯ Ø¥Ù†Ø³Ø§Ù†ØŒ Ø§Ø®ØªØ± Ø­Ø±ÙƒØ© Ø¹Ø´ÙˆØ§Ø¦ÙŠØ©
                      bestHintMove = playerMoves[Math.floor(Math.random() * playerMoves.length)];
                  }
             }


             if (bestHintMove) {
                 const pieceSquare = getSquareElement(bestHintMove.origin.r, bestHintMove.origin.c);
                 const targetSquare = getSquareElement(bestHintMove.row, bestHintMove.col);
                 const pieceElement = pieceSquare?.querySelector('.piece');

                 if (pieceElement && targetSquare) {
                     // Ø£Ø¶Ù ÙØ¦Ø§Øª Ø§Ù„ØªÙ„Ù…ÙŠØ­
                     pieceElement.classList.add('hint-piece-suggestion');
                     targetSquare.classList.add('hint-move-suggestion');
                     targetSquare.classList.add('possible-move'); // ØªØ£ÙƒØ¯ Ù…Ù† Ø¥Ø¨Ø±Ø§Ø² Ø§Ù„Ù…Ø±Ø¨Ø¹ ÙƒÙ‡Ø¯Ù Ù…Ø­ØªÙ…Ù„
                     // ØªØ¹ÙŠÙŠÙ† Ù…Ø¤Ù‚Øª Ù„Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØªÙ„Ù…ÙŠØ­ Ø¨Ø¹Ø¯ ÙØªØ±Ø©
                     hintTimeoutId = setTimeout(clearHintHighlights, 2500); // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØªÙ„Ù…ÙŠØ­ Ø¨Ø¹Ø¯ 2.5 Ø«Ø§Ù†ÙŠØ©
                 } else {
                      console.warn("Hint error: elements not found for move", bestHintMove);
                 }
             }
             // Ù„Ø§ Ø­Ø§Ø¬Ø© Ù„Ù€ else Ø¥Ø°Ø§ ÙƒØ§Ù†Øª playerMoves.length == 0 Ù„Ø£Ù†Ù‡ ØªÙ… Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹Ù‡Ø§ Ø¨Ø§Ù„ÙØ¹Ù„
        }

        // --- AI Logic ---
        function makeAiMove() {
            if (isGameOver || currentPlayer !== AI_PLAYER) { isAiThinking = false; requestRender(); return; }

            let bestMoveResult = null;

            // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù‡Ù†Ø§Ùƒ Ù‚ÙØ²Ø© Ù…Ø³ØªÙ…Ø±Ø© Ù‚ÙŠØ¯ Ø§Ù„ØªÙ†ÙÙŠØ° Ù„Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ±
            if (continuousJumpPossible && selectedPiece && selectedPiece.player === AI_PLAYER) {
                 const nextJumps = calculateMovesForPieceInternal(selectedPiece.row, selectedPiece.col, true, boardState);
                 if (nextJumps.length > 0) {
                     // Ø§Ø®ØªØ± Ø£ÙˆÙ„ Ù‚ÙØ²Ø© Ù…ØªØ§Ø­Ø© ÙÙ‚Ø· Ù„Ù…ÙˆØ§ØµÙ„Ø© Ø§Ù„Ø³Ù„Ø³Ù„Ø©
                     bestMoveResult = { move: nextJumps[0], score: 0 };
                 } else {
                      // Ù‡Ø°Ø§ ÙŠØ¬Ø¨ Ø£Ù„Ø§ ÙŠØ­Ø¯Ø« ÙÙŠ Ù„Ø¹Ø¨Ø© Ø·Ø¨ÙŠØ¹ÙŠØ©ØŒ Ù„ÙƒÙ† Ù„Ù„ØªØ­ÙˆØ·:
                     console.error("AI Error: Continuous jump required, but no next jump found!");
                     continuousJumpPossible = false; // Ø¥Ù†Ù‡Ø§Ø¡ Ø­Ø§Ù„Ø© Ø§Ù„Ù‚ÙØ²Ø© Ø§Ù„Ù…Ø³ØªÙ…Ø±Ø©
                      // Ø«Ù… Ø­Ø§ÙˆÙ„ Ø¥ÙŠØ¬Ø§Ø¯ Ø£ÙØ¶Ù„ Ø­Ø±ÙƒØ© Ø¹Ø§Ø¯ÙŠØ© (Ù‡Ø°Ø§ Ù‚Ø¯ ÙŠØ¤Ø¯ÙŠ Ø¥Ù„Ù‰ Ù…Ø´Ø§ÙƒÙ„ Ù‚ÙˆØ§Ø¹Ø¯)
                      bestMoveResult = findBestMoveForAI();
                 }
            } else {
                 // Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù‡Ù†Ø§Ùƒ Ù‚ÙØ²Ø© Ù…Ø³ØªÙ…Ø±Ø©ØŒ Ø§Ø¨Ø­Ø« Ø¹Ù† Ø£ÙØ¶Ù„ Ø­Ø±ÙƒØ© Ø¬Ø¯ÙŠØ¯Ø©
                 bestMoveResult = findBestMoveForAI();
            }

            if (bestMoveResult && bestMoveResult.move) {
                 const chosenMove = bestMoveResult.move;

                 // Ø­ÙØ¸ Ø§Ù„Ø­Ø§Ù„Ø© Ù‚Ø¨Ù„ Ø§Ù„Ø­Ø±ÙƒØ© ÙÙ‚Ø· Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ø§Ù„Ù‚ÙØ²Ø© Ù…Ø³ØªÙ…Ø±Ø© (Ù„Ø­Ø±ÙƒØ© Ø¬Ø¯ÙŠØ¯Ø©)
                 if (!continuousJumpPossible) {
                     saveCurrentStateToHistory();
                 }
                 // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù‚ÙØ²Ø© Ù…Ø³ØªÙ…Ø±Ø©ØŒ ØªÙ… Ø­ÙØ¸ Ø§Ù„Ø­Ø§Ù„Ø© Ø¨Ø§Ù„ÙØ¹Ù„ ÙÙŠ Ø£ÙˆÙ„ Ù‚ÙØ²Ø© ÙÙŠ Ø§Ù„Ø³Ù„Ø³Ù„Ø©

                 // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù‚Ø·Ø¹Ø© Ø§Ù„Ù…Ø±Ø¦ÙŠØ© Ù„Ù„Ø¹Ù†ØµØ± Ø§Ù„Ø°ÙŠ Ø³ÙŠØªÙ… ØªØ­Ø±ÙŠÙƒÙ‡ Ù„Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ±
                 const aiPieceSquare = getSquareElement(chosenMove.origin.r, chosenMove.origin.c);
                 const aiPieceElement = aiPieceSquare?.querySelector('.piece');

                 // ØªØ­Ø¯ÙŠØ« selectedPiece Ù„Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ± (Ø¶Ø±ÙˆØ±ÙŠ Ù„Ù€ animateAndMovePiece)
                 selectedPiece = { row: chosenMove.origin.r, col: chosenMove.origin.c, player: AI_PLAYER, element: aiPieceElement };

                 // Ø¨Ø¯Ø¡ Ø§Ù„ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ù…Ø±Ø¦ÙŠ ÙˆØªÙ†ÙÙŠØ° Ù…Ù†Ø·Ù‚ Ø§Ù„Ù„Ø¹Ø¨Ø© Ø¨Ø¹Ø¯ Ø§ÙƒØªÙ…Ø§Ù„ Ø§Ù„ØªØ­Ø±ÙŠÙƒ
                 animateAndMovePiece(chosenMove.origin.r, chosenMove.origin.c, chosenMove);

            }
            else {
                 console.log("AI has no moves.");
                 isAiThinking = false;
                 // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù„Ø¯Ù‰ Ø§Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ± Ø­Ø±ÙƒØ§Øª Ù…Ù…ÙƒÙ†Ø©ØŒ ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø§Ù„Ø© Ø§Ù„ÙÙˆØ²
                 if (!checkWinCondition()) {
                     // Ø¥Ø°Ø§ Ù„Ù… ØªÙ†ØªÙ‡ Ø§Ù„Ù„Ø¹Ø¨Ø©ØŒ Ù‚Ù… Ø¨Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ø¯ÙˆØ± (Ù„ÙŠØµØ¨Ø­ Ø¯ÙˆØ± Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ø¢Ø®Ø±)
                     endTurn();
                 }
                 // Ø¥Ø°Ø§ Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù„Ø¹Ø¨Ø©ØŒ endGame() ØªÙ… Ø§Ø³ØªØ¯Ø¹Ø§Ø¤Ù‡Ø§ Ø¨Ø§Ù„ÙØ¹Ù„ ÙÙŠ checkWinCondition
            }
        }

        function findBestMoveForAI() {
             if (aiDifficulty === DIFFICULTIES.EASY) {
                 const possibleAiMoves = getAllPossibleMoves(AI_PLAYER, false, boardState);
                 if (possibleAiMoves.length === 0) { return null; }
                 const randomMove = possibleAiMoves[Math.floor(Math.random() * possibleAiMoves.length)];
                 return { move: randomMove, score: 0 }; // Ù„Ø§ ÙŠÙˆØ¬Ø¯ score Ù…Ù‡Ù… ÙÙŠ Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø³Ù‡Ù„
             } else {
                 const depth = (aiDifficulty === DIFFICULTIES.HARD) ? MINIMAX_DEPTH.HARD : MINIMAX_DEPTH.MEDIUM;
                 // Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Minimax Ù„Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø£ÙØ¶Ù„ Ø­Ø±ÙƒØ©
                 return findBestMoveMinimax(AI_PLAYER, depth);
             }
        }
        function findBestMoveMinimax(player, depth) {
            let bestScore = -Infinity;
            let bestMove = null;
            const possibleMoves = getAllPossibleMoves(player, false, boardState);

            // Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù‡Ù†Ø§Ùƒ Ø­Ø±ÙƒØ§Øª Ù…Ù…ÙƒÙ†Ø©ØŒ Ø¥Ø±Ø¬Ø§Ø¹ Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ù„Ù„ÙˆØ­Ø©
            if (possibleMoves.length === 0) {
                return { move: null, score: evaluateBoard(boardState, player) };
            }

             // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù‡Ù†Ø§Ùƒ Ù‚ÙØ²Ø§Øª Ø¥Ù„Ø²Ø§Ù…ÙŠØ©ØŒ Ø±ÙƒØ² ÙÙ‚Ø· Ø¹Ù„Ù‰ Ø§Ù„Ù‚ÙØ²Ø§Øª
             const jumpMovesOnly = getAllPossibleMoves(player, true, boardState);
             const movesToEvaluate = jumpMovesOnly.length > 0 ? jumpMovesOnly : possibleMoves;


            for (const move of movesToEvaluate) {
                const tempBoard = deepCopyBoard(boardState);
                simulateMove(tempBoard, move);

                let score;
                // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ø­Ø±ÙƒØ© Ù‚ÙØ²Ø©ØŒ Ø§Ø³ØªÙ…Ø± ÙÙŠ Ø§Ø³ØªÙƒØ´Ø§Ù Ø§Ù„Ù‚ÙØ²Ø§Øª Ø§Ù„Ù…ØªØ¹Ø¯Ø¯Ø© Ø§Ù„Ù…Ù…ÙƒÙ†Ø©
                if (move.isJump) {
                    // Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ minimaxWithContinuation Ø§Ù„Ø°ÙŠ ÙŠØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„Ù‚ÙØ²Ø§Øª Ø§Ù„Ù…ØªØ¹Ø¯Ø¯Ø©
                    score = minimaxWithContinuation(tempBoard, depth - 1, -Infinity, Infinity, false, getOpponent(player), player, move.row, move.col);
                } else {
                    // Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù‚ÙØ²Ø©ØŒ Ø§Ù†ØªÙ‚Ù„ Ù„Ù„Ø¯ÙˆØ± Ø§Ù„ØªØ§Ù„ÙŠ
                    score = minimax(tempBoard, depth - 1, -Infinity, Infinity, false, getOpponent(player), player);
                }

                // ÙÙŠ Ø¯ÙˆØ± Ø§Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ± (Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ù…Ø¹Ø¸Ù…)ØŒ Ø§Ø®ØªØ± Ø§Ù„Ø­Ø±ÙƒØ© Ø°Ø§Øª Ø£Ø¹Ù„Ù‰ Ù†ØªÙŠØ¬Ø©
                if (score > bestScore) {
                    bestScore = score;
                    bestMove = move;
                }
            }

            // ÙÙŠ Ø­Ø§Ù„Ø© Ø¹Ø¯Ù… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø£ÙØ¶Ù„ Ø­Ø±ÙƒØ© (ÙˆÙ‡Ùˆ Ø£Ù…Ø± Ù†Ø§Ø¯Ø± Ø¥Ø°Ø§ ÙƒØ§Ù†Øª possibleMoves.length > 0)
            if (!bestMove && movesToEvaluate.length > 0) {
                console.warn("Minimax: No best move found, selecting first available move.");
                 // Ø§Ø®ØªØ± Ø£ÙˆÙ„ Ø­Ø±ÙƒØ© Ù…ØªØ§Ø­Ø© Ù…Ù† Ø§Ù„Ø­Ø±ÙƒØ§Øª Ø§Ù„ØªÙŠ ØªÙ… ØªÙ‚ÙŠÙŠÙ…Ù‡Ø§ (Ù‚ÙØ²Ø© Ø£Ùˆ Ø­Ø±ÙƒØ© Ø¹Ø§Ø¯ÙŠØ©)
                bestMove = movesToEvaluate[0];
            } else if (!bestMove && possibleMoves.length > 0) {
                 // Ù‡Ø°Ø§ ÙŠØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø­Ø§Ù„Ø© Ù†Ø§Ø¯Ø±Ø© Ø­ÙŠØ« movesToEvaluate ÙØ§Ø±ØºØ© Ù„ÙƒÙ† possibleMoves Ù„ÙŠØ³Øª ÙØ§Ø±ØºØ© (Ù„Ø§ ÙŠÙ†Ø¨ØºÙŠ Ø£Ù† ØªØ­Ø¯Ø« Ø¥Ø°Ø§ ÙƒØ§Ù† getAllPossibleMoves ØµØ­ÙŠØ­Ù‹Ø§)
                 console.warn("Minimax: movesToEvaluate was empty but possibleMoves wasn't. Selecting first possible move.");
                 bestMove = possibleMoves[0];
            }


            return { move: bestMove, score: bestScore };
        }

        function minimax(currentBoard, depth, alpha, beta, isMaximizingPlayer, currentPlayerMM, originalPlayer) {
            // Ø´Ø±ÙˆØ· Ø§Ù„ØªÙˆÙ‚Ù: Ø¹Ù…Ù‚ Ø§Ù„Ø¨Ø­Ø« ÙˆØµÙ„ Ù„Ù„ØµÙØ± Ø£Ùˆ Ø§Ù„Ù„Ø¹Ø¨Ø© Ø§Ù†ØªÙ‡Øª ÙÙŠ Ø§Ù„Ù„ÙˆØ­Ø© Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø©
            if (depth === 0 || checkGameOverSimulated(currentBoard, currentPlayerMM)) {
                 // Ù‚ÙŠÙ…Ø© Ø§Ù„Ù„ÙˆØ­Ø© ÙÙŠ Ù‡Ø°Ø§ Ø§Ù„Ø¹Ù…Ù‚
                 return evaluateBoard(currentBoard, originalPlayer, depth);
            }

            // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø­Ø±ÙƒØ§Øª Ø§Ù„Ù…Ù…ÙƒÙ†Ø© Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ø­Ø§Ù„ÙŠ ÙÙŠ Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø©
            const possibleMoves = getAllPossibleMoves(currentPlayerMM, false, currentBoard);

            // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù‡Ù†Ø§Ùƒ Ø­Ø±ÙƒØ§Øª Ù…Ù…ÙƒÙ†Ø© Ù„Ù‡Ø°Ø§ Ø§Ù„Ù„Ø§Ø¹Ø¨ ÙÙŠ Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø©ØŒ Ø¥Ø±Ø¬Ø§Ø¹ Ù‚ÙŠÙ…Ø© Ø§Ù„Ù„ÙˆØ­Ø©
             if (possibleMoves.length === 0) {
                  return evaluateBoard(currentBoard, originalPlayer, depth);
             }

             // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ø­Ø§Ù„ÙŠ Ù‡Ùˆ Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ù…Ø¹Ø¸Ù… (Ø¹Ø§Ø¯Ø© Ø§Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ± AI)
            if (isMaximizingPlayer) {
                let maxEval = -Infinity;
                 // ØªÙ‚ÙŠÙŠÙ… ÙƒÙ„ Ø­Ø±ÙƒØ© Ù…Ù…ÙƒÙ†Ø©
                for (const move of possibleMoves) {
                    const tempBoard = deepCopyBoard(currentBoard);
                    simulateMove(tempBoard, move); // Ù…Ø­Ø§ÙƒØ§Ø© Ø§Ù„Ø­Ø±ÙƒØ©

                    let evalScore;
                     // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ø­Ø±ÙƒØ© Ù‚ÙØ²Ø©ØŒ Ø§Ø³ØªÙ…Ø± ÙÙŠ Ø§Ø³ØªÙƒØ´Ø§Ù Ø§Ù„Ù‚ÙØ²Ø§Øª Ø§Ù„Ù…ØªØ¹Ø¯Ø¯Ø©
                    if (move.isJump) {
                         evalScore = minimaxWithContinuation(tempBoard, depth - 1, alpha, beta, true, currentPlayerMM, originalPlayer, move.row, move.col); // Ø§Ø³ØªÙ…Ø± ÙƒÙ„Ø§Ø¹Ø¨ Ù…Ø¹Ø¸Ù…
                    } else {
                         // Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù‚ÙØ²Ø©ØŒ Ø§Ù†ØªÙ‚Ù„ Ù„Ø¯ÙˆØ± Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ø¢Ø®Ø± (Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ù…Ù‚Ù‘Ù„)
                        evalScore = minimax(tempBoard, depth - 1, alpha, beta, false, getOpponent(currentPlayerMM), originalPlayer);
                    }

                    maxEval = Math.max(maxEval, evalScore); // ØªØ­Ø¯ÙŠØ« Ø£ÙØ¶Ù„ Ù†ØªÙŠØ¬Ø©
                    alpha = Math.max(alpha, evalScore); // ØªØ­Ø¯ÙŠØ« Alpha
                     // Alpha-Beta Pruning
                    if (beta <= alpha) break;
                }
                return maxEval;

            } else { // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ø­Ø§Ù„ÙŠ Ù‡Ùˆ Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ù…Ù‚Ù‘Ù„ (Ø¹Ø§Ø¯Ø© Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ø¨Ø´Ø±ÙŠ)
                let minEval = Infinity;
                 // ØªÙ‚ÙŠÙŠÙ… ÙƒÙ„ Ø­Ø±ÙƒØ© Ù…Ù…ÙƒÙ†Ø©
                for (const move of possibleMoves) {
                    const tempBoard = deepCopyBoard(currentBoard);
                    simulateMove(tempBoard, move); // Ù…Ø­Ø§ÙƒØ§Ø© Ø§Ù„Ø­Ø±ÙƒØ©

                    let evalScore;
                     // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ø­Ø±ÙƒØ© Ù‚ÙØ²Ø©ØŒ Ø§Ø³ØªÙ…Ø± ÙÙŠ Ø§Ø³ØªÙƒØ´Ø§Ù Ø§Ù„Ù‚ÙØ²Ø§Øª Ø§Ù„Ù…ØªØ¹Ø¯Ø¯Ø©
                    if (move.isJump) {
                         evalScore = minimaxWithContinuation(tempBoard, depth - 1, alpha, beta, false, currentPlayerMM, originalPlayer, move.row, move.col); // Ø§Ø³ØªÙ…Ø± ÙƒÙ„Ø§Ø¹Ø¨ Ù…Ù‚Ù‘Ù„
                    } else {
                         // Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù‚ÙØ²Ø©ØŒ Ø§Ù†ØªÙ‚Ù„ Ù„Ø¯ÙˆØ± Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ø¢Ø®Ø± (Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ù…Ø¹Ø¸Ù…)
                        evalScore = minimax(tempBoard, depth - 1, alpha, beta, true, getOpponent(currentPlayerMM), originalPlayer);
                    }

                    minEval = Math.min(minEval, evalScore); // ØªØ­Ø¯ÙŠØ« Ø£Ø³ÙˆØ£ Ù†ØªÙŠØ¬Ø©
                    beta = Math.min(beta, evalScore); // ØªØ­Ø¯ÙŠØ« Beta
                     // Alpha-Beta Pruning
                    if (beta <= alpha) break;
                }
                return minEval;
            }
        }

        function minimaxWithContinuation(currentBoard, depth, alpha, beta, isMaximizingPlayer, playerWhoJustMoved, originalPlayer, currentR, currentC) {
             // Ø§Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ù‚ÙØ²Ø§Øª Ø§Ù„Ù…Ù…ÙƒÙ†Ø© Ù…Ù† Ø§Ù„Ù…Ø±Ø¨Ø¹ Ø§Ù„Ø­Ø§Ù„ÙŠ Ø¨Ø¹Ø¯ Ø§Ù„Ù‚ÙØ²Ø© Ø§Ù„Ø£Ø®ÙŠØ±Ø©
             const nextJumps = calculateMovesForPieceInternal(currentR, currentC, true, currentBoard);

             // Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙØ²Ø§Øª Ø§Ù„Ù…Ù…ÙƒÙ†Ø© Ù…Ù† Ù‡Ø°Ù‡ Ø§Ù„Ù‚Ø·Ø¹Ø©
             if (nextJumps.length > 0) {
                 let bestEval = isMaximizingPlayer ? -Infinity : Infinity;

                 for(const nextJump of nextJumps) {
                      const tempBoard = deepCopyBoard(currentBoard);
                      simulateMove(tempBoard, nextJump); // Ù…Ø­Ø§ÙƒØ§Ø© Ø§Ù„Ù‚ÙØ²Ø© Ø§Ù„Ù…ØªØ¹Ø¯Ø¯Ø© Ø§Ù„ØªØ§Ù„ÙŠØ©

                      // Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ minimaxWithContinuation Ø¨Ø´ÙƒÙ„ ØªÙƒØ±Ø§Ø±ÙŠ Ø¨Ù†ÙØ³ Ø§Ù„Ø¹Ù…Ù‚ ÙˆØ§Ù„Ù„Ø§Ø¹Ø¨
                      const evalScore = minimaxWithContinuation(tempBoard, depth, alpha, beta, isMaximizingPlayer, playerWhoJustMoved, originalPlayer, nextJump.row, nextJump.col);

                      if (isMaximizingPlayer) {
                           bestEval = Math.max(bestEval, evalScore);
                           alpha = Math.max(alpha, bestEval);
                      } else {
                           bestEval = Math.min(bestEval, evalScore);
                           beta = Math.min(beta, bestEval);
                      }

                      // Alpha-Beta Pruning
                      if (beta <= alpha) break;
                 }
                 return bestEval;
             }
             else {
                  // Ø¥Ø°Ø§ Ù„Ù… ØªØ¹Ø¯ Ù‡Ù†Ø§Ùƒ Ù‚ÙØ²Ø§Øª Ù…Ø³ØªÙ…Ø±Ø© Ù…Ù† Ù‡Ø°Ù‡ Ø§Ù„Ù‚Ø·Ø¹Ø©ØŒ Ø§Ù†ØªÙ‚Ù„ Ù„Ù„Ø¯ÙˆØ± Ø§Ù„ØªØ§Ù„ÙŠ (Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ø¢Ø®Ø±)
                  return minimax(currentBoard, depth, alpha, beta, !isMaximizingPlayer, getOpponent(playerWhoJustMoved), originalPlayer);
             }
        }

        function evaluateBoard(currentBoard, player, depth = 0) {
            let score = 0;
            const opponent = getOpponent(player);
            const WIN_SCORE = 1000;
            const KING_VALUE = 3; // Ù‚ÙŠÙ…Ø© Ù„Ù„Ù…Ù„Ùƒ Ø£Ø¹Ù„Ù‰ Ù…Ù† Ø§Ù„Ù‚Ø·Ø¹Ø© Ø§Ù„Ø¹Ø§Ø¯ÙŠØ©
            const PIECE_VALUE = 1; // Ù‚ÙŠÙ…Ø© Ù„Ù„Ù‚Ø·Ø¹Ø© Ø§Ù„Ø¹Ø§Ø¯ÙŠØ©
            const ADVANCEMENT_VALUE = 0.1; // Ù‚ÙŠÙ…Ø© ØµØºÙŠØ±Ø© Ù„ØªÙ‚Ø¯Ù… Ø§Ù„Ù‚Ø·Ø¹ Ù†Ø­Ùˆ Ø§Ù„ØªØªÙˆÙŠØ¬
            const SAFE_EDGE_BONUS = 0.2; // Ù…ÙƒØ§ÙØ£Ø© ØµØºÙŠØ±Ø© Ù„Ù„Ù‚Ø·Ø¹ Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø© Ø¹Ù„Ù‰ Ø­Ø§ÙØ© Ø§Ù„Ù„ÙˆØ­Ø© (Ø£Ù‚Ù„ Ø¹Ø±Ø¶Ø© Ù„Ù„Ù‚ÙØ²)

            let myPieces = 0, oppPieces = 0;
            let myKings = 0, oppKings = 0;
            let myCanMove = false, oppCanMove = false; // Ù„ØªÙ‚ÙŠÙŠÙ… Ø­Ø§Ù„Ø§Øª Ø¹Ø¯Ù… Ø¥Ù…ÙƒØ§Ù†ÙŠØ© Ø§Ù„Ø­Ø±ÙƒØ©

             // Ø­Ø³Ø§Ø¨ Ø¹Ø¯Ø¯ Ø§Ù„Ù‚Ø·Ø¹ ÙˆØ§Ù„Ù…Ù„ÙˆÙƒ ÙˆØªÙ‚ÙŠÙŠÙ… ØªÙ…Ø±ÙƒØ² Ø§Ù„Ù‚Ø·Ø¹ ÙˆØ¥Ù…ÙƒØ§Ù†ÙŠØ© Ø§Ù„Ø­Ø±ÙƒØ©
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const piece = currentBoard[r][c];
                    if (piece) {
                         // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¥Ù…ÙƒØ§Ù†ÙŠØ© Ø§Ù„Ø­Ø±ÙƒØ© (ÙŠØªÙ… ÙÙ‚Ø· Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© Ù„ÙƒÙ„ Ù„Ø§Ø¹Ø¨ Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø£Ø¯Ø§Ø¡)
                         if (!myCanMove && piece.player === player) {
                             if (calculateMovesForPieceInternal(r, c, false, currentBoard).length > 0) {
                                 myCanMove = true;
                             }
                         }
                         if (!oppCanMove && piece.player === opponent) {
                              if (calculateMovesForPieceInternal(r, c, false, currentBoard).length > 0) {
                                  oppCanMove = true;
                              }
                         }

                         // ØªÙ‚ÙŠÙŠÙ… Ù‚ÙŠÙ…Ø© Ø§Ù„Ù‚Ø·Ø¹ ÙˆØªÙ…Ø±ÙƒØ²Ù‡Ø§
                        if (piece.player === player) {
                            myPieces++;
                            score += PIECE_VALUE;
                            if (piece.isKing) {
                                myKings++;
                                score += KING_VALUE - PIECE_VALUE; // Ø¥Ø¶Ø§ÙØ© Ø§Ù„ÙØ±Ù‚ ÙÙŠ Ø§Ù„Ù‚ÙŠÙ…Ø©
                            } else {
                                 // Ù…ÙƒØ§ÙØ£Ø© ØªÙ‚Ø¯Ù… Ø§Ù„Ù‚Ø·Ø¹: ØªØ²Ø¯Ø§Ø¯ ÙƒÙ„Ù…Ø§ Ø§Ù‚ØªØ±Ø¨Øª Ø§Ù„Ù‚Ø·Ø¹Ø© Ù…Ù† ØµÙ Ø§Ù„ØªØªÙˆÙŠØ¬
                                score += (player === PLAYER_WHITE ? r : (BOARD_SIZE - 1 - r)) * ADVANCEMENT_VALUE;
                            }
                             // Ù…ÙƒØ§ÙØ£Ø© Ø§Ù„Ù‚Ø·Ø¹ Ø¹Ù„Ù‰ Ø§Ù„Ø­ÙˆØ§Ù (Ø§Ù„Ø£Ø¹Ù…Ø¯Ø© 0 Ùˆ 7)
                            if (c === 0 || c === BOARD_SIZE - 1) {
                                score += SAFE_EDGE_BONUS;
                            }
                        } else { // Ù‚Ø·Ø¹Ø© Ø§Ù„Ø®ØµÙ…
                            oppPieces++;
                            score -= PIECE_VALUE;
                            if (piece.isKing) {
                                oppKings++;
                                score -= (KING_VALUE - PIECE_VALUE); // Ø®ØµÙ… Ø§Ù„ÙØ±Ù‚ ÙÙŠ Ø§Ù„Ù‚ÙŠÙ…Ø©
                            } else {
                                 // Ù…Ø¹Ø§Ù‚Ø¨Ø© ØªÙ‚Ø¯Ù… Ù‚Ø·Ø¹ Ø§Ù„Ø®ØµÙ…
                                score -= (opponent === PLAYER_WHITE ? r : (BOARD_SIZE - 1 - r)) * ADVANCEMENT_VALUE;
                            }
                             // Ù…Ø¹Ø§Ù‚Ø¨Ø© Ù‚Ø·Ø¹ Ø§Ù„Ø®ØµÙ… Ø¹Ù„Ù‰ Ø§Ù„Ø­ÙˆØ§Ù
                            if (c === 0 || c === BOARD_SIZE - 1) {
                                score -= SAFE_EDGE_BONUS;
                            }
                        }
                    }
                }
            }

            // ØªÙ‚ÙŠÙŠÙ… Ø­Ø§Ù„Ø© Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ù„Ø¹Ø¨Ø©
            // Ù‚ÙŠÙ…Ø© ØµØºÙŠØ±Ø© ØªØ¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ø¹Ù…Ù‚ Ù„ØªÙØ¶ÙŠÙ„ Ø§Ù„Ù†Ù‡Ø§ÙŠØ§Øª Ø§Ù„Ø£Ø³Ø±Ø¹ (Ø£Ùˆ Ø§Ù„Ø£Ø¨Ø·Ø£ Ø­Ø³Ø¨ Ø§Ù„Ø¹Ù…Ù‚ ÙˆØ§Ù„Ù…ÙƒØ§ÙØ¦)
            let currentDepthFactor = depth * 0.01; // Ù‚ÙŠÙ…Ø© ØµØºÙŠØ±Ø© Ø¬Ø¯Ø§

            // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù„Ø¯Ù‰ Ø§Ù„Ø®ØµÙ… Ù‚Ø·Ø¹ Ù…ØªØ¨Ù‚ÙŠØ© Ø£Ùˆ Ù„Ø§ ÙŠØ³ØªØ·ÙŠØ¹ Ø§Ù„ØªØ­Ø±ÙƒØŒ ÙØ§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ø­Ø§Ù„ÙŠ ÙŠÙÙˆØ²
            if (oppPieces === 0 || !oppCanMove) {
                return WIN_SCORE + currentDepthFactor; // Ù†Ù‚Ø§Ø· Ø¹Ø§Ù„ÙŠØ© Ø¬Ø¯Ø§ + Ù…ÙƒØ§ÙØ£Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø¹Ù…Ù‚ (Ø£Ø³Ø±Ø¹ ÙÙˆØ²)
            }
             // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù„Ø¯Ù‰ Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ø­Ø§Ù„ÙŠ Ù‚Ø·Ø¹ Ù…ØªØ¨Ù‚ÙŠØ© Ø£Ùˆ Ù„Ø§ ÙŠØ³ØªØ·ÙŠØ¹ Ø§Ù„ØªØ­Ø±ÙƒØŒ ÙØ§Ù„Ø®ØµÙ… ÙŠÙÙˆØ²
            if (myPieces === 0 || !myCanMove) {
                return -WIN_SCORE - currentDepthFactor; // Ù†Ù‚Ø§Ø· Ù…Ù†Ø®ÙØ¶Ø© Ø¬Ø¯Ø§ - Ø®ØµÙ… Ø¹Ù„Ù‰ Ø§Ù„Ø¹Ù…Ù‚ (Ø£Ø³Ø±Ø¹ Ø®Ø³Ø§Ø±Ø©)
            }

            // Ø¥Ø°Ø§ Ù„Ù… ØªÙ†ØªÙ‡ Ø§Ù„Ù„Ø¹Ø¨Ø©ØŒ Ø¥Ø±Ø¬Ø§Ø¹ Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ù…Ø­Ø³ÙˆØ¨Ø©
            return score;
        }
        function simulateMove(board, move) {
             // ØªØ£ÙƒØ¯ Ù…Ù† Ù†Ø³Ø® Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù‚Ø·Ø¹Ø© Ù„ØªØ¬Ù†Ø¨ ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª Ø§Ù„Ù…Ø±Ø¬Ø¹ÙŠØ© ÙÙŠ Ø§Ù„Ù„ÙˆØ­Ø© Ø§Ù„Ø£ØµÙ„ÙŠØ©
             const pieceData = JSON.parse(JSON.stringify(board[move.origin.r][move.origin.c]));
             if (!pieceData) return; // Ù„Ø§ ØªÙˆØ¬Ø¯ Ù‚Ø·Ø¹Ø© Ù„Ù„ØªØ­Ø±ÙŠÙƒ

             // Ù†Ù‚Ù„ Ø§Ù„Ù‚Ø·Ø¹Ø©
             board[move.row][move.col] = pieceData;
             board[move.origin.r][move.origin.c] = null;

             // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù‚Ø·Ø¹Ø© Ø§Ù„Ù…Ø£Ø³ÙˆØ±Ø© Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ø­Ø±ÙƒØ© Ù‚ÙØ²Ø©
             if (move.isJump && move.captured) {
                  // ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø±Ø¨Ø¹ Ø§Ù„Ù…Ø³ØªÙ‡Ø¯Ù Ù„Ù„Ø£Ø³ÙŠØ± ØµØ§Ù„Ø­Ù‹Ø§ ÙˆÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ù‚Ø·Ø¹Ø©
                 if (isValidSquare(move.captured.row, move.captured.col) && board[move.captured.row][move.captured.col]) {
                     board[move.captured.row][move.captured.col] = null;
                 } else {
                      console.warn("Simulate move warning: Captured piece not found at", move.captured);
                 }
             }

             // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªØªÙˆÙŠØ¬
             if (!pieceData.isKing) {
                 if ((pieceData.player === PLAYER_BLACK && move.row === 0) || (pieceData.player === PLAYER_WHITE && move.row === BOARD_SIZE - 1)) {
                     // ØªÙˆØ¬ Ø§Ù„Ù‚Ø·Ø¹Ø© ÙÙŠ Ø§Ù„Ù„ÙˆØ­Ø© Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø©
                     pieceData.isKing = true;
                     board[move.row][move.col].isKing = true; // ØªØ£ÙƒØ¯ Ù…Ù† ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙƒØ§Ø¦Ù† Ø§Ù„Ø¬Ø¯ÙŠØ¯ ÙÙŠ Ø§Ù„Ù„ÙˆØ­Ø©
                 }
             }
        }
        function checkGameOverSimulated(board, playerToCheck) {
             let pieces = 0;
             let canMove = false;
             // ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ù‚Ø·Ø¹ Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ù…Ø­Ø¯Ø¯
             for(let r=0; r<BOARD_SIZE; r++){
                  for(let c=0; c<BOARD_SIZE; c++){
                       if(board[r][c]?.player === playerToCheck){
                            pieces++;
                            // ØªØ­Ù‚Ù‚ Ù…Ù† Ø¥Ù…ÙƒØ§Ù†ÙŠØ© Ø§Ù„Ø­Ø±ÙƒØ© (ÙŠØªÙˆÙ‚Ù Ø¨Ù…Ø¬Ø±Ø¯ Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø­Ø±ÙƒØ© ÙˆØ§Ø­Ø¯Ø©)
                            if(!canMove && calculateMovesForPieceInternal(r, c, false, board).length > 0){
                                 canMove = true;
                            }
                       }
                  }
             }
             // ØªÙ†ØªÙ‡ÙŠ Ø§Ù„Ù„Ø¹Ø¨Ø© Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ù…Ø­Ø¯Ø¯ Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù„Ø¯ÙŠÙ‡ Ù‚Ø·Ø¹ Ù…ØªØ¨Ù‚ÙŠØ© Ø£Ùˆ Ù„Ø§ ÙŠØ³ØªØ·ÙŠØ¹ Ø§Ù„ØªØ­Ø±Ùƒ
             return pieces === 0 || !canMove;
        }

        function addHoverEffects() {
            removeHoverEffects(); // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØªØ£Ø«ÙŠØ±Ø§Øª Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø© Ø£ÙˆÙ„Ø§Ù‹
            // ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø¬Ø¨ Ø§Ù„ØªÙØ§Ø¹Ù„ Ø§Ù„Ø¹Ø§Ù…
            const isInteractionBlocked = isGameOver || isAiThinking || isSettingsPanelVisible || boardSelectionScreen.classList.contains('visible') || pieceStyleSelectionScreen.classList.contains('visible') || confirmationModal.classList.contains('visible') || (gameMode === 'ai' && currentPlayer === AI_PLAYER);
            if (isInteractionBlocked) return; // Ù„Ø§ ØªØ¶ÙŠÙ ØªØ£Ø«ÙŠØ±Ø§Øª Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„ØªÙØ§Ø¹Ù„ Ù…Ø­Ø¸ÙˆØ±Ù‹Ø§

            // Ø§Ø¨Ø­Ø« Ø¹Ù† Ù‚Ø·Ø¹ Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ø­Ø§Ù„ÙŠ ØºÙŠØ± Ø§Ù„Ù…Ø®ØªØ§Ø±Ø©
            boardElement.querySelectorAll(`.piece.${currentPlayer}-piece:not(.selected)`).forEach(piece => {
                const square = piece.closest('.square');
                if (!square) return;
                const r = parseInt(square.dataset.row);
                const c = parseInt(square.dataset.col);

                // ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù‚Ø·Ø¹Ø© Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„Ø³Ø­Ø¨/Ø§Ù„Ù†Ù‚Ø± ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ø­Ø§Ù„Ø© (Ø®Ø§ØµØ© ÙÙŠ Ø­Ø§Ù„Ø© Ø§Ù„Ù‚ÙØ²Ø© Ø§Ù„Ù…Ø³ØªÙ…Ø±Ø©)
                const isHoverable = !(continuousJumpPossible && selectedPiece && (selectedPiece.row !== r || selectedPiece.col !== c));

                if (isHoverable) {
                    // ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† Ù„Ø¯Ù‰ Ø§Ù„Ù‚Ø·Ø¹Ø© Ø­Ø±ÙƒØ§Øª Ù…Ù…ÙƒÙ†Ø© (Ù‚ÙØ²Ø§Øª Ø£Ùˆ Ø­Ø±ÙƒØ§Øª Ø¹Ø§Ø¯ÙŠØ© Ø­Ø³Ø¨ Ø§Ù„Ù‚ÙˆØ§Ø¹Ø¯)
                    const mustJump = getAllPossibleMoves(currentPlayer, true, boardState).length > 0;
                    const movesForThisPiece = calculateMovesForPieceInternal(r, c, mustJump, boardState);

                    // Ø¥Ø°Ø§ ÙƒØ§Ù† Ù„Ø¯Ù‰ Ø§Ù„Ù‚Ø·Ø¹Ø© Ø­Ø±ÙƒØ§Øª Ù…Ù…ÙƒÙ†Ø©ØŒ Ø§Ø¬Ø¹Ù„Ù‡Ø§ Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„ØªØ­ÙˆÙŠÙ… ÙˆØ§Ù„Ø³Ø­Ø¨
                    if (movesForThisPiece.length > 0) {
                        piece.classList.add('hoverable');
                        // Ù…Ø¤Ø´Ø± Ø§Ù„ÙØ£Ø±Ø© ÙŠØªÙ… Ø§Ù„ØªØ­ÙƒÙ… ÙÙŠÙ‡ Ø§Ù„Ø¢Ù† Ø¨Ø´ÙƒÙ„ Ø£Ø³Ø§Ø³ÙŠ Ø¨ÙˆØ§Ø³Ø·Ø© ÙØ¦Ø© interactive Ø£Ùˆ logic click/drag
                        // piece.style.cursor = 'grab'; // ÙŠÙ…ÙƒÙ† Ø¥Ø²Ø§Ù„ØªÙ‡ Ù‡Ù†Ø§ ÙˆØ§Ù„Ø§Ø¹ØªÙ…Ø§Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¹Ø§Ù…Ø© Ø£Ùˆ logic
                    } else {
                         // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù„Ø¯Ù‰ Ø§Ù„Ù‚Ø·Ø¹Ø© Ø­Ø±ÙƒØ§Øª Ù…Ù…ÙƒÙ†Ø©ØŒ Ø§Ø¬Ø¹Ù„ Ù…Ø¤Ø´Ø± Ø§Ù„ÙØ£Ø±Ø© Ø§ÙØªØ±Ø§Ø¶ÙŠÙ‹Ø§
                        // piece.style.cursor = 'default'; // ÙŠÙ…ÙƒÙ† Ø¥Ø²Ø§Ù„ØªÙ‡ Ù‡Ù†Ø§ ÙˆØ§Ù„Ø§Ø¹ØªÙ…Ø§Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¹Ø§Ù…Ø© Ø£Ùˆ logic
                    }
                } else {
                     // Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ø§Ù„Ù‚Ø·Ø¹Ø© Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„ØªÙØ§Ø¹Ù„ Ø­Ø§Ù„ÙŠÙ‹Ø§ (Ù…Ø«Ø§Ù„: ÙŠØ¬Ø¨ Ø§Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‚ÙØ²Ø© Ù…Ø³ØªÙ…Ø±Ø© Ø¨Ù‚Ø·Ø¹Ø© Ø£Ø®Ø±Ù‰)ØŒ Ø§Ø¬Ø¹Ù„ Ù…Ø¤Ø´Ø± Ø§Ù„ÙØ£Ø±Ø© Ø§ÙØªØ±Ø§Ø¶ÙŠÙ‹Ø§
                    // piece.style.cursor = 'default'; // ÙŠÙ…ÙƒÙ† Ø¥Ø²Ø§Ù„ØªÙ‡ Ù‡Ù†Ø§ ÙˆØ§Ù„Ø§Ø¹ØªÙ…Ø§Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¹Ø§Ù…Ø© Ø£Ùˆ logic
                }
            });

             // ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„Ù‚Ø·Ø¹Ø© Ø§Ù„Ù…Ø®ØªØ§Ø±Ø© Ù„Ù‡Ø§ Ù…Ø¤Ø´Ø± Ø³Ø­Ø¨ ØµØ­ÙŠØ­
             if (selectedPiece && selectedPiece.element && boardElement.contains(selectedPiece.element) && !isInteractionBlocked) {
                  // selectedPiece.element.style.cursor = 'grab'; // ÙŠÙ…ÙƒÙ† Ø§Ù„Ø§Ø¹ØªÙ…Ø§Ø¯ Ø¹Ù„Ù‰ ÙØ¦Ø© 'interactive' Ø£Ùˆ logic
             }
        }

        function removeHoverEffects() { document.querySelectorAll('.piece.hoverable').forEach(p => p.classList.remove('hoverable')); }

        // --- Initialization on Load ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM Loaded. Initializing...");
            updateSoundButtonIcon(); updateTimerButtonIcon();
            // Ø¥Ø®ÙØ§Ø¡ Ø¬Ù…ÙŠØ¹ Ø´Ø§Ø´Ø§Øª Ø§Ù„Ù„Ø¹Ø¨Ø© ÙˆØ§Ù„ØªØ±Ø§ÙƒØ¨Ø§Øª Ø¹Ù†Ø¯ Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø£ÙˆÙ„ÙŠ
            settingsButton.style.display = 'none'; settingsPanel.classList.remove('visible'); settingsOverlay.style.display = 'none'; boardSelectionScreen.classList.remove('visible'); pieceStyleSelectionScreen.classList.remove('visible'); confirmationModal.classList.remove('visible'); gameContainer.style.display = 'none'; gameOverScreen.classList.remove('visible'); aiDifficultySelectorContainer.classList.remove('visible');
            // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø¸Ù‡ÙˆØ± Ø§Ù„Ø´Ø§Ø´Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
            startScreen.classList.remove('hidden-completely');
            // ØªØ¹ÙŠÙŠÙ† Ø­Ø§Ù„Ø© Ø§Ù„Ù„Ø¹Ø¨Ø© Ø¹Ù„Ù‰ Ø£Ù†Ù‡Ø§ ØºÙŠØ± Ù†Ø´Ø·Ø©
            isSettingsPanelVisible = false; isGameOver = true;
            // ØªØ­Ù…ÙŠÙ„ ÙˆØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø©
            loadBoardStyle(); loadPieceStyle();
            // ØªØ­Ø¯ÙŠØ« Ø¹Ù†Ø§ØµØ± ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£ÙˆÙ„ÙŠØ©
            updateTurnIndicatorVisuals(); updateUndoButton(); updateHintButton(); updateCapturedCounters(); updateTimerDisplay(); updateDifficultySelectorDisplay();

             // Ø¥Ø¶Ø§ÙØ© Ù…Ø³ØªÙ…Ø¹ Ø­Ø¯Ø« ØªØºÙŠÙŠØ± Ø­Ø¬Ù… Ø§Ù„Ù†Ø§ÙØ°Ø© Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø¹Ø±Ø¶ Ø§Ù„Ù„ÙˆØ­Ø© Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
             window.addEventListener('resize', () => {
                 if (gameContainer.style.display === 'flex') {
                     // Ø¥Ø¹Ø§Ø¯Ø© Ø¨Ù†Ø§Ø¡ ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù„ÙˆØ­Ø© Ù„ØªØ­Ø¯ÙŠØ« Ø£Ø­Ø¬Ø§Ù… Ø§Ù„Ù…Ø±Ø¨Ø¹Ø§Øª ÙˆØ§Ù„Ù‚Ø·Ø¹ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø­Ø¬Ù… Ø§Ù„Ù†Ø§ÙØ°Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯
                     createBoardUI();
                     // Ø¥Ø¹Ø§Ø¯Ø© Ø¹Ø±Ø¶ Ø§Ù„Ù‚Ø·Ø¹ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø­Ø§Ù„Ø© Ø§Ù„Ù„ÙˆØ­Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©
                     renderBoard();
                 }
             });


            console.log("Initialization Complete. Ready.");
        });
    </script>

</body>
</html>
