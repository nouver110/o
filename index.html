<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Checkers - Drag & Drop</title>
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <!-- Font Awesome for Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        /* --- Base Styles --- */
        html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; }
        body {
            font-family: 'Roboto', 'Cairo', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh; /* Ensure body takes at least full viewport height */
            background-color: #321e06; /* Dark wood/brown background */
            color: #e0d6c8; /* Light text color */
            box-sizing: border-box;
            position: relative;
            touch-action: none; /* Disable default touch actions like scrolling/zooming */
        }

        /* --- Start Screen --- */
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #4a3b31, #321e06, #4a3b31);
            background-size: 200% 200%;
            animation: gradientBG 15s ease infinite;
            text-align: center;
            z-index: 120;
            box-sizing: border-box;
            padding: 5vh 20px; /* Responsive padding */
            transition: opacity 0.3s ease-out, visibility 0s linear 0.3s;
            opacity: 1;
            visibility: visible;
         }
        #start-screen.hidden-completely {
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-out, visibility 0s linear 0.3s;
        }

        @keyframes gradientBG { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } }
        #main-title {
            font-size: clamp(3.5em, 13vh, 7em); /* Responsive font size */
            color: #e8d5b7;
            font-weight: 700;
            margin-bottom: clamp(30px, 7vh, 60px); /* Increased spacing, responsive */
            text-shadow: 0 0 7px #fff, 0 0 14px #ffd700, 5px 5px 5px rgba(0,0,0,0.6);
            letter-spacing: 4px;
            font-family: 'Roboto', 'Cairo', Impact, sans-serif;
            opacity: 0;
            animation: fadeInTitle 1s ease-out 0.5s forwards;
            transition: opacity 0.4s ease-out;
            flex-shrink: 0; /* Prevent shrinking */
        }
        @keyframes fadeInTitle { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }
        #start-screen h2#start-subtitle {
            font-size: clamp(1.6em, 5vh, 2.5em); /* Responsive font size */
            color: #f0e5d1;
            margin-top: 0;
            margin-bottom: clamp(25px, 5vh, 40px); /* Responsive spacing */
            opacity: 0;
            animation: fadeInSubtitle 1s ease-out 1s forwards;
            text-shadow: 1px 1px 4px rgba(0,0,0,0.5);
            transition: opacity 0.4s ease-out;
            flex-shrink: 0; /* Prevent shrinking */
        }
        @keyframes fadeInSubtitle { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
        #start-options {
             display: flex;
             flex-direction: column;
             align-items: center;
             width: 100%;
             opacity: 1;
             transition: opacity 0.5s ease-out;
             flex-shrink: 0; /* Prevent shrinking */
             /* Added max-width to prevent buttons from becoming too wide on large screens */
             max-width: 400px;
             margin: 0 auto;
         }
        .start-button {
            font-family: 'Roboto', 'Cairo', sans-serif;
            font-size: clamp(1.4em, 4.5vh, 2em); /* Responsive font size */
            padding: clamp(12px, 3vh, 25px) clamp(25px, 6vw, 50px); /* Responsive padding */
            margin: clamp(10px, 2vh, 20px); /* Responsive margin */
            min-width: clamp(260px, 55vw, 380px); /* Responsive minimum width */
            cursor: pointer;
            border: none;
            border-radius: 20px;
            background: linear-gradient(to bottom, #966f4d, #7a542e);
            color: #ffffff;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            box-shadow: 0 7px 12px rgba(0,0,0,0.45), inset 0 1px 2px rgba(255,255,255,0.2);
            transition: all 0.2s ease;
            opacity: 0;
            transform: translateY(20px);
            animation: fadeInUpButton 0.6s ease-out forwards;
            flex-shrink: 0; /* Prevent shrinking */
            /* Ensure button text wraps if needed on very small screens */
            white-space: normal;
        }
        #vs-human-button { animation-delay: 1.3s; }
        #vs-ai-button { animation-delay: 1.5s; }
        @keyframes fadeInUpButton { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        .start-button:hover { background: linear-gradient(to bottom, #a07551, #8b5e3c); box-shadow: 0 9px 16px rgba(0,0,0,0.55), inset 0 1px 2px rgba(255,255,255,0.2); transform: translateY(-4px) scale(1.04); }
        .start-button:active { transform: translateY(0px) scale(1); box-shadow: 0 5px 8px rgba(0,0,0,0.4), inset 0 1px 2px rgba(0,0,0,0.25); }

        /* --- AI Difficulty Selector --- */
        #ai-difficulty-selector-container {
            display: none; /* Controlled by JS visible class */
            flex-direction: column;
            align-items: center;
            width: clamp(300px, 75vw, 480px); /* Responsive width */
            padding: 30px 35px;
            background-color: #3a281a;
            border-radius: 15px;
            border: 1px solid #6b4f3b;
            z-index: 130;
            opacity: 0; /* Controlled by JS visible class */
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9); /* Start scaled down */
            transition: opacity 0.3s ease-out 0.1s, transform 0.3s ease-out 0.1s;
            visibility: hidden; /* Controlled by JS visible class */
            box-sizing: border-box; /* Include padding in width */
            max-height: 95vh; /* Prevent overflow on small screens */
            overflow-y: auto; /* Add scroll if content is too tall */
        }
        #ai-difficulty-selector-container.visible {
            display: flex;
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
            visibility: visible;
        }
        #ai-difficulty-selector-container h3 {
            color: #f0e5d1;
            margin-top: 0;
            margin-bottom: 30px;
            font-size: clamp(1.4em, 4vh, 1.8em); /* Responsive font size */
            text-shadow: 1px 1px 2px rgba(0,0,0,0.4);
        }
        .difficulty-control {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 30px; /* Spacing between elements */
            width: 100%;
            margin-bottom: 35px;
            flex-wrap: wrap; /* Allow wrapping on very small screens */
        }
        .difficulty-arrow-button {
            background: linear-gradient(to bottom, #966f4d, #7a542e);
            border: none;
            color: white;
            font-size: 1.8em;
            padding: 10px 18px;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            transition: all 0.2s ease;
            flex-shrink: 0; /* Prevent shrinking */
        }
        .difficulty-arrow-button:hover { background: linear-gradient(to bottom, #a07551, #8b5e3c); transform: scale(1.05); }
        .difficulty-arrow-button:active { transform: scale(0.98); box-shadow: 0 2px 4px rgba(0,0,0,0.3); }
        #difficulty-display {
            font-size: clamp(1.6em, 4.5vh, 2.1em); /* Responsive font size */
            font-weight: bold;
            color: #fff;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.6);
            min-width: 120px;
            text-align: center;
            flex-grow: 1; /* Allow display to grow */
            flex-basis: 120px; /* Suggest a base width */
        }
        #confirm-difficulty-button {
            font-size: clamp(1.3em, 4vh, 1.9em); /* Responsive font size */
            padding: clamp(12px, 3vh, 25px) clamp(25px, 6vw, 50px); /* Responsive padding */
            min-width: clamp(250px, 55vw, 350px); /* Responsive minimum width */
            opacity: 1; /* Overrides start-button animation opacity */
            transform: none; /* Overrides start-button animation transform */
            animation: none; /* Disable start-button specific animation */
            margin-top: 15px;
        }
        #close-difficulty-selector {
            position: absolute;
            top: 15px;
            right: 15px;
            left: auto;
            background: none;
            border: none;
            font-size: 1.6em;
            color: #e0d6c8;
            cursor: pointer;
            padding: 5px;
            transition: color 0.2s ease, transform 0.2s ease;
            z-index: 131;
        }
        #close-difficulty-selector:hover { color: #ffffff; transform: scale(1.1); }
        #difficulty-prev i { transform: scaleX(-1); } /* Flip icon */
        #difficulty-next i { transform: scaleX(-1); } /* Flip icon */


        /* --- Game Container --- */
        #game-container {
            display: none; /* Controlled by JS */
            flex-direction: column;
            align-items: center;
            justify-content: space-around; /* Distribute space between status, board, etc. */
            width: 100%;
            height: 100%;
            padding: 15px;
            gap: clamp(10px, 2vh, 15px); /* Responsive gap between flex items */
            box-sizing: border-box;
            position: relative;
            overflow: hidden;
            /* Added max-width/height for very large displays if needed */
            /* max-width: 1200px; */
            /* max-height: 900px; */
        }
        /* --- Status Bar --- */
        #status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: var(--board-size); /* Match board width */
            max-width: 95vmin; /* Responsive max width, scales with viewport */
            margin: 0 auto;
            padding: 5px 10px;
            background-color: rgba(0,0,0,0.2);
            border-radius: 8px;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.3);
            flex-wrap: wrap; /* Allow items to wrap on smaller screens */
            gap: 10px; /* Spacing between status sections when wrapping */
            flex-shrink: 0; /* Prevent shrinking */
            box-sizing: border-box;
        }
        .status-section.capture-count.white { order: 1; } /* Order for flex items on small screens */
        #turn-indicators { order: 2; } /* Center item */
        .status-section.capture-count.black { order: 3; text-align: right; } /* Right item */
        .status-section {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: clamp(0.8em, 2.5vh, 1.1em); /* Responsive font size */
            /* Allow flex items to grow if needed on wider screens */
            flex-grow: 1;
            /* Set a basis to influence wrapping */
            flex-basis: 100px; /* Suggest a minimum base width */
            justify-content: flex-start; /* Align items within section */
        }
        .status-section.capture-count.black { justify-content: flex-end; } /* Align right section to the end */
        .status-icon { font-size: 1.2em; width: 20px; text-align: center; }
        .timer-display { min-width: 50px; text-align: right; background-color: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 4px; font-variant-numeric: tabular-nums; }
        .capture-count span:first-of-type { margin-right: 3px; margin-left: 0; }
        .capture-count span:last-of-type { font-weight: bold; }
        .status-section.capture-count.white .timer-display { margin-left: 10px; margin-right: 0; }
        .status-section.capture-count.black .timer-display { margin-right: 10px; margin-left: 0; }

        #turn-indicators {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 0;
            flex-shrink: 0; /* Prevent shrinking */
            height: 40px;
            /* Ensure it doesn't take too much space if wrapping */
            flex-basis: auto;
        }
        .turn-indicator {
             width: 30px;
             height: 30px;
             border-radius: 50%;
             margin: 0 8px;
             box-sizing: border-box;
             display: flex;
             align-items: center;
             justify-content: center;
             position: relative;
             border: 2px solid rgba(255, 50, 50, 0.6); /* Red indicator */
             box-shadow: 0 0 4px rgba(255, 50, 50, 0.4);
             transition: border-color 0.3s ease, box-shadow 0.3s ease, transform 0.3s ease;
         }
        .turn-indicator .piece-visual { width: 85%; height: 85%; border-radius: 50%; box-shadow: 0 1px 3px rgba(0,0,0,0.4); }
        .turn-indicator.active-turn { border-color: rgba(50, 255, 50, 0.8); box-shadow: 0 0 8px rgba(50, 255, 50, 0.7); transform: scale(1.1); }

        /* --- Board & Piece Styles --- */
        #board {
            display: grid;
            /* Responsive square size based on viewport, clamped between min/max */
            --square-size: clamp(45px, 9.5vmin, 75px);
            --board-size: calc(var(--square-size) * 8);
            grid-template-columns: repeat(8, var(--square-size));
            grid-template-rows: repeat(8, var(--square-size));
            width: var(--board-size);
            height: var(--board-size);
            box-shadow: 0 8px 16px rgba(0,0,0,0.5), inset 0 0 10px rgba(0,0,0,0.4);
            border-radius: 8px;
            position: relative;
            margin: 0 auto;
            max-width: 95vmin; /* Responsive max width */
            max-height: 95vmin; /* Responsive max height */
            aspect-ratio: 1 / 1; /* Ensure board is always square */
            flex-shrink: 1; /* Allow board to shrink if space is limited */
            border: 2px solid transparent;
            background-color: #4a311c; /* Default background */
            transition: border-color 0.3s ease, background-color 0.3s ease;
            user-select: none; /* Prevent selecting board text */
        }
        .square {
             width: var(--square-size);
             height: var(--square-size);
             display: flex;
             align-items: center;
             justify-content: center;
             position: relative;
             transition: background-color 0.15s ease, box-shadow 0.2s ease, background 0.2s ease;
             overflow: visible; /* Allow piece shadow/outline to extend */
         }
        .piece {
            width: 85%;
            height: 85%;
            border-radius: 50%;
            cursor: grab;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white; /* Default color, might be overridden by style */
            position: absolute; /* Absolute positioning within the square */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%); /* Center the piece */
            z-index: 10;
            transition: transform 0.15s ease, box-shadow 0.2s ease, background 0.3s ease, border-color 0.3s ease, outline-color 0.3s ease;
            border: 2px solid rgba(255, 255, 255, 0.1);
            overflow: hidden; /* Hide anything outside the circle */
            animation: none;
            outline: 0px solid transparent; /* For hint/selection outline */
            outline-offset: 2px;
            will-change: transform; /* Hint browser about animation */
            touch-action: none; /* Disable browser touch gestures */
        }
        .piece.dragging {
            cursor: grabbing;
            z-index: 1000 !important; /* Ensure it's on top while dragging */
            transform: translate(-50%, -50%) scale(1.1); /* Slightly larger when dragging */
            box-shadow: 0 10px 25px rgba(0,0,0,0.5) !important; /* Larger shadow */
            opacity: 0.85;
            transition: none !important; /* Disable transition while dragging */
        }
        .piece.ghost { opacity: 0.3 !important; } /* For the ghost image */
        .piece.captured-fade { animation: fadeOutPiece 0.4s ease-out forwards; z-index: 5; }
        @keyframes fadeOutPiece { from { opacity: 1; transform: translate(-50%, -50%) scale(0.9); } to { opacity: 0; transform: translate(-50%, -50%) scale(0.5); } }
        .piece.jump-hint { outline-color: rgba(0, 255, 0, 0.7); outline-width: 3px; animation: hintPulseGreen 1.5s infinite ease-in-out !important; }
        @keyframes hintPulseGreen { 0%, 100% { outline-color: rgba(0, 255, 0, 0.7); box-shadow: 0 0 8px rgba(0, 255, 0, 0.4); } 50% { outline-color: rgba(150, 255, 150, 0.9); box-shadow: 0 0 15px rgba(150, 255, 150, 0.7); } }

        /* --- King Crown Style --- */
        .piece.king::after {
            content: '‚ôï'; /* Queen symbol */
            position: absolute;
            font-size: calc(var(--square-size) * 0.35); /* Size relative to square */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none; /* Don't interfere with clicks */
            z-index: 11;
            opacity: 1;
            line-height: 1;
            text-align: center;
        }
        .piece.king.white-piece::after { color: #000000; text-shadow: 0 0 2px rgba(255, 255, 255, 0.6); }
        .piece.king.black-piece::after {
            color: #FFD700; /* Gold color */
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.6);
        }

        /* --- Piece Style Variations --- */
        /* Base styles for different piece themes */
        body.piece-style-classic .piece.black-piece { background: linear-gradient(to bottom right, #444 0%, #111 100%); box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.2), 0 4px 8px rgba(0, 0, 0, 0.7); border-color: rgba(0, 0, 0, 0.2); }
        body.piece-style-classic .piece.white-piece { background: linear-gradient(to bottom right, #eee 0%, #ccc 100%); box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.2), 0 4px 8px rgba(0, 0, 0, 0.5); border-color: rgba(255, 255, 255, 0.3); }
        body.piece-style-classic .piece.selected { box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.3), 0 4px 12px rgba(0, 0, 0, 0.9), 0 0 0 5px rgba(52, 152, 219, 0.8) !important; }
        body.piece-style-classic .piece.white-piece.selected { box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3), 0 4px 12px rgba(0, 0, 0, 0.6), 0 0 0 5px rgba(52, 152, 219, 0.8) !important; }
        body.piece-style-classic .piece.hoverable:hover { box-shadow: inset 0 0 12px rgba(255, 255, 255, 0.3), 0 6px 15px rgba(0, 0, 0, 0.8); }
        body.piece-style-classic .piece.white-piece.hoverable:hover { box-shadow: inset 0 0 12px rgba(0, 0, 0, 0.2), 0 6px 15px rgba(0, 0, 0, 0.6); }

        body.piece-style-flat .piece { border: 1px solid rgba(0,0,0,0.3); box-shadow: none; }
        body.piece-style-flat .piece.black-piece { background: #2c2c2c; }
        body.piece-style-flat .piece.white-piece { background: #f0f0f0; }
        body.piece-style-flat .piece.selected { box-shadow: 0 0 0 5px rgba(52, 152, 219, 0.8) !important; }
        body.piece-style-flat .piece.hoverable:hover { transform: translate(-50%, -50%) translateY(-3px) scale(1.04); opacity: 0.9; }

        body.piece-style-crimson .piece.black-piece { background: linear-gradient(to bottom right, #b71c1c 0%, #7f0000 100%); box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.25), 0 4px 8px rgba(0, 0, 0, 0.7); border-color: rgba(50, 0, 0, 0.3); }
        body.piece-style-crimson .piece.white-piece { background: linear-gradient(to bottom right, #fffde7 0%, #fff8e1 100%); box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.1), 0 4px 8px rgba(0, 0, 0, 0.4); border-color: rgba(200, 190, 170, 0.4); }
        body.piece-style-crimson .piece.selected { box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.3), 0 4px 12px rgba(0, 0, 0, 0.9), 0 0 0 5px rgba(255, 82, 82, 0.8) !important; }
        body.piece-style-crimson .piece.white-piece.selected { box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.2), 0 4px 12px rgba(0, 0, 0, 0.5), 0 0 0 5px rgba(255, 82, 82, 0.8) !important; }
        body.piece-style-crimson .piece.hoverable:hover { box-shadow: inset 0 0 12px rgba(255, 255, 255, 0.3), 0 6px 15px rgba(0, 0, 0, 0.8); }
        body.piece-style-crimson .piece.white-piece.hoverable:hover { box-shadow: inset 0 0 12px rgba(0, 0, 0, 0.2), 0 6px 15px rgba(0, 0, 0, 0.5); }

        body.piece-style-azure .piece { border: 1px solid rgba(0,0,0,0.3); box-shadow: none; }
        body.piece-style-azure .piece.black-piece { background: #1976d2; border-color: #0d47a1; }
        body.piece-style-azure .piece.white-piece { background: #e3f2fd; border-color: #90caf9; }
        body.piece-style-azure .piece.selected { box-shadow: 0 0 0 5px rgba(66, 165, 245, 0.8) !important; }
        body.piece-style-azure .piece.hoverable:hover { transform: translate(-50%, -50%) translateY(-3px) scale(1.04); opacity: 0.9; }

        body.piece-style-forest .piece.black-piece { background: linear-gradient(to bottom right, #388e3c 0%, #1b5e20 100%); box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.2), 0 4px 8px rgba(0, 0, 0, 0.7); border-color: rgba(0, 50, 0, 0.3); }
        body.piece-style-forest .piece.white-piece { background: linear-gradient(to bottom right, #f5f5dc 0%, #d2b48c 100%); box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.15), 0 4px 8px rgba(0, 0, 0, 0.4); border-color: rgba(180, 160, 130, 0.4); }
        body.piece-style-forest .piece.selected { box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.3), 0 4px 12px rgba(0, 0, 0, 0.9), 0 0 0 5px rgba(102, 187, 106, 0.8) !important; }
        body.piece-style-forest .piece.white-piece.selected { box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.2), 0 4‰πé 12px rgba(0, 0, 0, 0.5), 0 0 0 5px rgba(102, 187, 106, 0.8) !important; }
        body.piece-style-forest .piece.hoverable:hover { box-shadow: inset 0 0 12px rgba(255, 255, 255, 0.3), 0 6px 15px rgba(0, 0, 0, 0.8); }
        body.piece-style-forest .piece.white-piece.hoverable:hover { box-shadow: inset 0 0 12px rgba(0, 0, 0, 0.2), 0 6px 15px rgba(0, 0, 0, 0.5); }

        body.piece-style-royal .piece.black-piece { background: linear-gradient(to bottom right, #6a1b9a 0%, #4a148c 100%); box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.25), 0 4px 8px rgba(0, 0, 0, 0.7); border-color: rgba(30, 0, 50, 0.4); }
        body.piece-style-royal .piece.white-piece { background: linear-gradient(to bottom right, #fff59d 0%, #ffee58 100%); box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.1), 0 4px 8px rgba(0, 0, 0, 0.4); border-color: rgba(190, 180, 100, 0.5); }
        body.piece-style-royal .piece.selected { box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.3), 0 4px 12px rgba(0, 0, 0, 0.9), 0 0 0 5px rgba(255, 238, 88, 0.8) !important; }
        body.piece-style-royal .piece.white-piece.selected { box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.2), 0 4px 12px rgba(0, 0, 0, 0.5), 0 0 0 5px rgba(255, 238, 88, 0.8) !important; }
        body.piece-style-royal .piece.hoverable:hover { box-shadow: inset 0 0 12px rgba(255, 255, 255, 0.3), 0 6px 15px rgba(0, 0, 0, 0.8); }
        body.piece-style-royal .piece.white-piece.hoverable:hover { box-shadow: inset 0 0 12px rgba(0, 0, 0, 0.2), 0 6px 15px rgba(0, 0, 0, 0.5); }

        /* --- General Piece Modifiers --- */
        .selected { z-index: 20; transform: translate(-50%, -50%) scale(1.05); outline-width: 0px !important; animation: none !important; }
        .possible-move::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 255, 0, 0.15);
            border: 2px solid rgba(0, 255, 0, 0.4);
            border-radius: 50%; /* Use 50% for circle */
            pointer-events: none;
            z-index: 5;
            box-sizing: border-box;
            animation: pulsePossible 1.8s infinite ease-in-out;
        }
        @keyframes pulsePossible { 0% { transform: scale(0.5); opacity: 0.5; } 50% { transform: scale(0.7); opacity: 0.8; } 100% { transform: scale(0.5); opacity: 0.5; } }
        .hint-piece-suggestion { outline: 4px dashed #ffdd00 !important; outline-offset: 3px; animation: hintPulseYellow 1s infinite !important; z-index: 22 !important; }
        .hint-move-suggestion::before { background-color: rgba(255, 221, 0, 0.3) !important; border-color: #ffdd00 !important; animation: pulsePossible 1s infinite ease-in-out !important; z-index: 6 !important; }
        @keyframes hintPulseYellow { 0%, 100% { outline-color: #ffdd00; } 50% { outline-color: #fff3a0; } }
        .piece.hoverable:hover { transform: translate(-50%, -50%) translateY(-3px) scale(1.04); }

        /* --- Game Over Screen --- */
        #game-over-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(0, 0, 0, 0.7) 0%, rgba(0, 0, 0, 0.9) 100%);
            display: none; /* Controlled by JS visible class */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            text-align: center;
            opacity: 0; /* Controlled by JS visible class */
            transition: opacity 0.6s ease-in-out;
            padding: 20px; /* Add padding for small screens */
            box-sizing: border-box;
        }
        #game-over-screen.visible { display: flex; opacity: 1; }
        #game-over-content {
            background-color: rgba(60, 40, 20, 0.8);
            padding: 30px 40px;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.6);
            transform: scale(0.8); /* Start scaled down */
            transition: transform 0.4s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            border: 1px solid #a07551;
            max-width: 90%; /* Responsive max width */
        }
        #game-over-screen.visible #game-over-content { transform: scale(1); }
        #game-over-message {
            font-size: clamp(1.8em, 5vh, 2.2em); /* Responsive font size */
            color: #fff;
            text-shadow: 1px 1px 0px #ffeb3b, 3px 3px 5px rgba(0,0,0,0.7);
            margin-bottom: 25px;
            font-weight: 700;
        }
        #game-over-message::before { content: 'üèÜ'; display: block; font-size: 2em; margin-bottom: 10px; text-shadow: 0 0 10px #ffd700; }
        #back-to-menu-button {
            font-family: 'Roboto', 'Cairo', sans-serif;
            font-size: 1.1em;
            padding: 10px 25px;
            cursor: pointer;
            border: none;
            border-radius: 8px;
            background: linear-gradient(to bottom, #e0d6c8, #c1b2a3);
            color: #321e06;
            font-weight: bold;
            box-shadow: 0 3px 5px rgba(0,0,0,0.25), inset 0 -2px 1px rgba(0,0,0,0.1);
            transition: all 0.2s ease;
        }
        #back-to-menu-button:hover { background: linear-gradient(to bottom, #f7f2e8, #e8e0d0); box-shadow: 0 4px 7px rgba(0,0,0,0.3), inset 0 -2px 1px rgba(0,0,0,0.1); transform: translateY(-1px); }
        #back-to-menu-button:active { transform: translateY(0px); box-shadow: 0 2px 4px rgba(0,0,0,0.25), inset 0 -1px 1px rgba(0,0,0,0.15); }

        /* --- Settings Button & Panel Styles --- */
        #settings-button {
            position: fixed;
            top: 15px;
            right: 15px;
            z-index: 110;
            font-size: 1.8em;
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            padding: 5px;
            transition: color 0.2s ease, transform 0.2s ease;
        }
        #settings-button:hover { color: rgba(255, 255, 255, 1); transform: rotate(15deg); }
        #settings-panel {
            position: fixed;
            top: 60px; /* Position below the button */
            right: 15px;
            transform: none; /* No initial scale */
            background-color: rgba(40, 25, 10, 0.9);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.4);
            z-index: 115;
            display: none; /* Controlled by JS visible class */
            flex-direction: column;
            align-items: center;
            gap: 10px; /* Space between buttons */
            border: 1px solid #7a542e;
            max-height: calc(100vh - 80px); /* Prevent overflow on tall screens */
            overflow-y: auto; /* Add scroll if content is too tall */
        }
        #settings-panel.visible { display: flex; }
        #settings-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: transparent; /* Invisible overlay to close panel/modals */
            z-index: 114;
            display: none; /* Controlled by JS */
        }
        .settings-icon-button {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 45px;
            height: 45px;
            font-size: 1.3em;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background: linear-gradient(to bottom, #966f4d, #7a542e);
            color: #ffffff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            transition: all 0.2s ease;
            text-align: center;
            flex-shrink: 0; /* Prevent shrinking */
        }
        .settings-icon-button:hover { background: linear-gradient(to bottom, #a07551, #8b5e3c); box-shadow: 0 3px 6px rgba(0,0,0,0.4); transform: translateY(-1px); }
        .settings-icon-button:active { transform: translateY(0); box-shadow: 0 1px 3px rgba(0,0,0,0.3); }
        .settings-icon-button:disabled { background: #aaa; color: #666; cursor: not-allowed; box-shadow: 0 1px 2px rgba(0,0,0,0.2); transform: none; }
        #sound-toggle-button.sound-off { background: linear-gradient(to bottom, #c1b2a3, #a39588); color: #321e06; }
        #sound-toggle-button.sound-off:hover { background: linear-gradient(to bottom, #d0c5b8, #b8a99a); }
        #timer-toggle-button.timer-off { background: linear-gradient(to bottom, #c1b2a3, #a39588); color: #321e06; }
        #timer-toggle-button.timer-off:hover { background: linear-gradient(to bottom, #d0c5b8, #b8a99a); }

        /* --- Overlay Screen Styles (Board/Piece selection, Confirmation) --- */
        .overlay-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            display: none; /* Controlled by JS visible class */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 150;
            opacity: 0; /* Controlled by JS visible class */
            transition: opacity 0.4s ease-in-out;
            padding: 20px; /* Add padding for small screens */
            box-sizing: border-box;
            overflow-y: hidden; /* Prevent body scroll */
        }
        .overlay-screen.visible { display: flex; opacity: 1; }
        .selection-content {
            background-color: rgba(60, 40, 20, 0.9);
            padding: 25px 35px;
            border-radius: 15px;
            box-shadow: 0 6px 25px rgba(0,0,0,0.6);
            text-align: center;
            max-width: 90%; /* Responsive max width */
            width: 700px; /* Base width */
            transform: scale(0.9); /* Start scaled down */
            transition: transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            border: 1px solid #966f4d;
            margin: 10px 0; /* Add vertical margin */
            display: flex; /* Use flexbox for content layout */
            flex-direction: column;
            max-height: 85vh; /* Limit height to prevent overflow */
            overflow-y: auto; /* Add scroll to content if needed */
            flex-shrink: 1; /* Allow content to shrink */
        }
        #confirmation-modal .selection-content {
            width: auto; /* Auto width based on content/max-width */
            max-width: 450px; /* Specific max width for modal */
            max-height: none; /* Allow full height */
            display: block; /* Use block display for simpler layout */
        }
        .overlay-screen.visible .selection-content { transform: scale(1); }
        .selection-content h2 {
            font-size: 1.8em;
            color: #f0e5d1;
            margin-top: 0;
            margin-bottom: 20px;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
            flex-shrink: 0; /* Prevent shrinking */
        }
        .options-container {
            display: grid;
            /* Responsive grid: auto columns with min size 110px, fills space */
            grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
            gap: 20px; /* Space between grid items */
            margin-bottom: 20px;
            overflow-y: auto; /* Add scroll if grid content overflows height */
            flex-shrink: 1; /* Allow container to shrink */
            flex-grow: 1; /* Allow container to grow */
            padding-left: 5px;
            padding-right: 15px; /* Adjust padding for scrollbar */
            padding-bottom: 15px;
            scrollbar-width: thin; /* Firefox scrollbar */
            scrollbar-color: #966f4d rgba(0,0,0,0.2); /* Firefox scrollbar colors */
        }
        /* Custom scrollbar for Webkit browsers */
        .options-container::-webkit-scrollbar { width: 8px; }
        .options-container::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); border-radius: 4px; }
        .options-container::-webkit-scrollbar-thumb { background-color: #966f4d; border-radius: 4px; border: 2px solid transparent; background-clip: content-box;}

        .option-button {
            font-family: 'Roboto', 'Cairo', sans-serif;
            cursor: pointer;
            border: 2px solid #7a542e;
            border-radius: 8px;
            background-color: rgba(255, 255, 255, 0.05);
            padding: 10px;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: #e0d6c8;
            font-size: 0.9em;
            min-height: 100px; /* Ensure minimum height */
            justify-content: space-between; /* Space out image/preview and text */
            text-align: center;
            box-sizing: border-box;
        }
        .option-button:hover { background-color: rgba(255, 255, 255, 0.15); border-color: #a07551; transform: translateY(-3px); box-shadow: 0 4px 8px rgba(0,0,0,0.3); }
        .option-button.selected-style { border-color: #ffd700; background-color: rgba(255, 215, 0, 0.15); box-shadow: 0 0 10px rgba(255, 215, 0, 0.4); }
        .close-selection-button {
            font-family: 'Roboto', 'Cairo', sans-serif;
            font-size: 1.1em;
            padding: 12px 28px;
            cursor: pointer;
            border: none;
            border-radius: 10px;
            background: linear-gradient(to bottom, #e0d6c8, #c1b2a3);
            color: #321e06;
            font-weight: bold;
            box-shadow: 0 3px 5px rgba(0,0,0,0.25), inset 0 -2px 1px rgba(0,0,0,0.1);
            transition: all 0.2s ease;
            margin-top: auto; /* Push button to the bottom in flex container */
            flex-shrink: 0; /* Prevent shrinking */
        }
        #confirmation-buttons button { margin-top: 0; } /* Override margin-top auto for confirmation buttons */
        .close-selection-button:hover { background: linear-gradient(to bottom, #f7f2e8, #e8e0d0); box-shadow: 0 4px 7px rgba(0,0,0,0.3), inset 0 -2px 1px rgba(0,0,0,0.1); transform: translateY(-2px); }
        .close-selection-button:active { transform: translateY(0px); box-shadow: 0 2px 4px rgba(0,0,0,0.25), inset 0 -1px 1px rgba(0,0,0,0.15); }

        /* --- Board Selection Screen --- */
        #board-options-container { } /* Specific container if needed */
        .board-option { } /* Specific option style if needed */
        .board-preview {
            width: 50px;
            height: 50px;
            display: grid;
            grid-template-columns: repeat(2, 1fr); /* 2x2 grid for preview */
            grid-template-rows: repeat(2, 1fr);
            border: 1px solid rgba(0,0,0,0.3);
            margin-bottom: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            border-radius: 3px;
            overflow: hidden;
            flex-shrink: 0; /* Prevent shrinking */
        }
        .board-preview .sq { width: 100%; height: 100%; }
        .board-preview-wood .light { background-color: #DEB887; } .board-preview-wood .dark { background-color: #A0522D; }
        .board-preview-desert .light { background-color: #f4a460; } .board-preview-desert .dark { background-color: #8b4513; }
        .board-preview-stone-path .light { background-color: #e0e0e0; } .board-preview-stone-path .dark { background-color: #616161; }
        .board-preview-emerald .light { background-color: #e0f2f1; } .board-preview-emerald .dark { background-color: #00695c; }
        .board-preview-volcano .light { background-color: #d3d3d3; } .board-preview-volcano .dark { background-color: #dc143c; }
        .board-preview-royal .light { background-color: #fffacd; } .board-preview-royal .dark { background-color: #4b0082; }

        /* --- Board Styles --- */
        /* Base styles for different board themes */
        #board.board-style-wood { border: 10px solid #8B4513; background-color: #A0522D; }
        #board.board-style-wood .light-square { background: #DEB887; box-shadow: inset 1px 1px 3px rgba(255, 255, 255, 0.3); }
        #board.board-style-wood .dark-square { background: #A0522D; box-shadow: inset 1px 1px 4px rgba(0, 0, 0, 0.6); cursor: pointer; }
        #board.board-style-wood .dark-square:hover:not(:has(.piece)):not(.possible-move) { background: #b3623f; }

        #board.board-style-desert { border: 10px solid #a0522d; background-color: #cd853f; }
        #board.board-style-desert .light-square { background: linear-gradient(135deg, #f4a460 0%, #deb887 100%); box-shadow: inset 1px 1px 3px rgba(255, 255, 255, 0.25); }
        #board.board-style-desert .dark-square { background: linear-gradient(135deg, #8b4513 0%, #a0522d 100%); box-shadow: inset 1px 1px 4px rgba(0, 0, 0, 0.5); cursor: pointer; }
        #board.board-style-desert .dark-square:hover:not(:has(.piece)):not(.possible-move) { background: linear-gradient(135deg, #9e5624 0%, #b3623f 100%); }

        #board.board-style-stone-path { border: 10px solid #5d4037; background-color: #795548; }
        #board.board-style-stone-path .light-square { background: linear-gradient(135deg, #e0e0e0 0%, #bdbdbd 100%); box-shadow: inset 1px 1px 3px rgba(255, 255, 255, 0.2); }
        #board.board-style-stone-path .dark-square { background: linear-gradient(135deg, #616161 0%, #424242 100%); box-shadow: inset 1px 1px 4px rgba(0, 0, 0, 0.5); cursor: pointer; }
        #board.board-style-stone-path .dark-square:hover:not(:has(.piece)):not(.possible-move) { background: linear-gradient(135deg, #757575 0%, #5a5a5a 100%); }

        #board.board-style-emerald { border: 10px solid #004d40; background-color: #00695c; }
        #board.board-style-emerald .light-square { background: linear-gradient(135deg, #e0f2f1 0%, #ffffff 100%); box-shadow: inset 1px 1px 3px rgba(0, 0, 0, 0.1); }
        #board.board-style-emerald .dark-square { background: linear-gradient(135deg, #00695c 0%, #004d40 100%); box-shadow: inset 1px 1px 4px rgba(0, 0, 0, 0.6); cursor: pointer; }
        #board.board-style-emerald .dark-square:hover:not(:has(.piece)):not(.possible-move) { background: linear-gradient(135deg, #00796b 0%, #005f51 100%); }

        #board.board-style-volcano { border: 10px solid #696969; background-color: #8B0000; }
        #board.board-style-volcano .light-square { background: linear-gradient(135deg, #d3d3d3 0%, #f5f5f5 100%); box-shadow: inset 1px 1px 2px rgba(0, 0, 0, 0.1); }
        #board.board-style-volcano .dark-square { background: linear-gradient(135deg, #dc143c 0%, #b22222 100%); box-shadow: inset 1px 1px 4px rgba(0, 0, 0, 0.5); cursor: pointer; }
        #board.board-style-volcano .dark-square:hover:not(:has(.piece)):not(.possible-move) { background: linear-gradient(135deg, #e82e4f 0%, #c53030 100%); }

        #board.board-style-royal { border: 10px solid #483d8b; background-color: #6a5acd; }
        #board.board-style-royal .light-square { background: linear-gradient(135deg, #fffacd 0%, #eee8aa 100%); box-shadow: inset 1px 1px 3px rgba(0, 0, 0, 0.15); }
        #board.board-style-royal .dark-square { background: linear-gradient(135deg, #4b0082 0%, #8a2be2 100%); box-shadow: inset 1px 1px 4px rgba(0, 0, 0, 0.6); cursor: pointer; }
        #board.board-style-royal .dark-square:hover:not(:has(.piece)):not(.possible-move) { background: linear-gradient(135deg, #5c1092 0%, #9d3fe5 100%); }

        /* Piece Selection Screen specific styles */
        #piece-options-container { grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); } /* Adjusted minmax */
        .piece-option { }
        .piece-preview-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
            width: 100%;
            height: 45px; /* Fixed height for preview container */
            flex-shrink: 0; /* Prevent shrinking */
        }
        .piece-preview {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            border: 1px solid rgba(0,0,0,0.2);
            box-shadow: 0 1px 2px rgba(0,0,0,0.3);
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
         /* Styles for piece previews */
         .piece-preview.black.classic { background: linear-gradient(to bottom right, #444 0%, #111 100%); box-shadow: inset 0 0 5px rgba(255, 255, 255, 0.1), 0 2px 4px rgba(0, 0, 0, 0.5); border-color: rgba(0, 0, 0, 0.2); }
         .piece-preview.white.classic { background: linear-gradient(to bottom right, #eee 0%, #ccc 100%); box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.1), 0 2px 4px rgba(0, 0, 0, 0.3); border-color: rgba(255, 255, 255, 0.3); }
         .piece-preview.black.flat { background: #2c2c2c; border: 1px solid #555; box-shadow: none; }
         .piece-preview.white.flat { background: #f0f0f0; border: 1px solid #ccc; box-shadow: none; }
         .piece-preview.black.crimson { background: linear-gradient(to bottom right, #b71c1c 0%, #7f0000 100%); border-color: rgba(50, 0, 0, 0.3); }
         .piece-preview.white.crimson { background: linear-gradient(to bottom right, #fffde7 0%, #fff8e1 100%); border-color: rgba(200, 190, 170, 0.4); }
         .piece-preview.black.azure { background: #1976d2; border-color: #0d47a1; box-shadow: none; }
         .piece-preview.white.azure { background: #e3f2fd; border-color: #90caf9; box-shadow: none; }
         .piece-preview.black.forest { background: linear-gradient(to bottom right, #388e3c 0%, #1b5e20 100%); border-color: rgba(0, 50, 0, 0.3); }
         .piece-preview.white.forest { background: linear-gradient(to bottom right, #f5f5dc 0%, #d2b48c 100%); border-color: rgba(180, 160, 130, 0.4); }
         .piece-preview.black.royal { background: linear-gradient(to bottom right, #6a1b9a 0%, #4a148c 100%); border-color: rgba(30, 0, 50, 0.4); }
         .piece-preview.white.royal { background: linear-gradient(to bottom right, #fff59d 0%, #ffee58 100%); border-color: rgba(190, 180, 100, 0.5); }

        /* Confirmation Modal Styles */
        #confirmation-modal .selection-content {
            width: auto; /* Auto width */
            max-width: 450px; /* Max width */
            padding: 30px 35px;
            border-width: 2px;
            border-color: #b58863;
            background-color: #4a311c;
            box-shadow: 0 10px 30px rgba(0,0,0,0.6);
            max-height: none; /* No height limit */
            display: block; /* Use block layout */
        }
        #confirmation-message {
            font-size: 1.3em;
            color: #f0e5d1;
            margin-bottom: 35px;
            line-height: 1.6;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.6);
        }
        #confirmation-buttons {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
            gap: 15px; /* Space between buttons */
        }
        #confirmation-buttons button {
            width: 80%; /* Make buttons take 80% of container width */
            max-width: 250px; /* Limit max width */
            margin-top: 0; /* Override default button margin */
        }
        #confirm-logout-button { background: linear-gradient(to bottom, #b75656, #913434); color: #ffffff; text-shadow: 1px 1px 2px rgba(0,0,0,0.4); border: 1px solid #7a2a2a; }
        #confirm-logout-button:hover { background: linear-gradient(to bottom, #c96e6e, #a04a4a); border-color: #8b3a3a; }
        #cancel-logout-button { /* Style already inherited */ }

        /* --- Media Queries for Responsiveness --- */

        /* Medium screens (e.g., large tablets, small desktops) */
         @media (max-height: 850px), (max-width: 700px) {
             /* Adjust square size slightly */
             #board { --square-size: clamp(40px, 9vmin, 65px); }

             /* Adjust selection overlay/modal sizes */
             .selection-content { width: 650px; max-width: 95%; max-height: 80vh; padding: 20px; }
             #confirmation-modal .selection-content { max-width: 90%; padding: 25px 20px; max-height: none; }

             /* Adjust grid options size */
             .options-container { grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 15px; }
             .option-button { min-height: 90px; padding: 8px; }
             .board-preview { width: 40px; height: 40px; margin-bottom: 6px; }
             .piece-preview { width: 30px; height: 30px; }
             .piece-preview-container { height: 35px; gap: 6px; }

             /* Adjust font sizes and spacing if needed */
             .selection-content h2 { font-size: 1.6em; margin-bottom: 15px; }
             .close-selection-button { font-size: 1em; padding: 10px 24px; }
             #confirmation-message { font-size: 1.2em; margin-bottom: 25px; }
             #confirmation-buttons button { font-size: 1em; padding: 10px 20px;}

             /* Status bar adjustments */
             #status-bar { width: var(--board-size); /* Still match board */ flex-direction: row; /* Keep horizontal if space allows */ align-items: center; }
             /* Ensure flex items can wrap if needed */
             .status-section { flex-basis: auto; flex-grow: 1; } /* Let items grow/shrink naturally */
         }

        /* Small screens (e.g., phones in portrait) */
         @media (max-height: 680px), (max-width: 550px) {
             /* Further adjust square size */
             #board { --square-size: clamp(40px, 8.5vmin, 60px); }

             /* Further adjust selection overlay/modal sizes */
             .selection-content { padding: 15px; max-height: 80vh; }
             #confirmation-modal .selection-content { padding: 20px 15px; max-width: 95%; }

             /* Further adjust grid options size and layout */
             .options-container { grid-template-columns: repeat(2, 1fr); /* Force 2 columns on smaller phones */ gap: 10px; padding-left: 5px; padding-right: 8px; padding-bottom: 10px;}
             .option-button { padding: 6px; font-size: 0.8em; min-height: 80px; }
             .board-preview { width: 35px; height: 35px; margin-bottom: 5px; }
             .piece-preview { width: 28px; height: 28px; }
             .piece-preview-container { height: 30px; gap: 5px; }

             /* Further adjust font sizes and spacing */
             .selection-content h2 { font-size: 1.4em; margin-bottom: 10px;}
             .close-selection-button { font-size: 0.9em; padding: 8px 20px;}
             #confirmation-message { font-size: 1.1em; margin-bottom: 20px; }
             #confirmation-buttons button { font-size: 0.9em; padding: 8px 18px;}

             /* Status bar adjustments for smaller screens */
             #status-bar {
                 width: var(--board-size);
                 flex-direction: row; /* Can still wrap */
                 align-items: center;
                 padding: 5px; /* Smaller padding */
                 gap: 5px; /* Smaller gap */
             }
             /* Explicitly control order if wrap occurs - although order is set, flex-wrap might rearrange */
             .status-section.capture-count.white { order: 1; flex-basis: 100px; flex-grow: 1; justify-content: flex-start; }
             #turn-indicators { order: 2; flex-basis: auto; flex-grow: 0; } /* Don't grow */
             .status-section.capture-count.black { order: 3; flex-basis: 100px; flex-grow: 1; justify-content: flex-end; }

             /* Adjusting padding/margin on elements if needed for tighter layout */
             #game-container { padding: 10px; gap: 8px; }

             /* Adjust start screen padding */
             #start-screen { padding: 3vh 15px; }
         }

        /* Very small screens (e.g., older phones, very limited height/width) */
         @media (max-height: 600px), (max-width: 450px) {
             /* Smallest square size */
             #board { --square-size: clamp(35px, 8vmin, 55px); }

             /* Further adjust padding/sizes */
             #game-container { padding: 8px; gap: 5px; }
             #status-bar { padding: 4px; gap: 4px; }
             .status-section { font-size: 0.75em; gap: 5px; flex-basis: 80px;} /* Smaller text/gap/basis */
             .status-icon { font-size: 1em; width: 18px; }
             .timer-display { min-width: 45px; padding: 1px 4px; }
             #turn-indicators { height: 35px; margin: 0 5px; }
             .turn-indicator { width: 25px; height: 25px; margin: 0 5px; }

             /* Further adjust selection overlay/modal sizes */
             .selection-content { padding: 10px; max-height: 80vh; }
             #confirmation-modal .selection-content { padding: 15px 10px; max-width: 98%; }
             .selection-content h2 { font-size: 1.2em; margin-bottom: 8px; }
             .options-container { grid-template-columns: repeat(auto-fit, minmax(80px, 1fr)); gap: 8px; padding-left: 4px; padding-right: 6px; padding-bottom: 8px;} /* Adjust grid min size and gap */
             .option-button { padding: 4px; font-size: 0.7em; min-height: 70px; }
             .board-preview { width: 30px; height: 30px; margin-bottom: 4px;}
             .piece-preview { width: 22px; height: 22px; }
             .piece-preview-container { height: 25px; gap: 4px; }

             /* Further adjust font sizes and spacing */
             .close-selection-button { font-size: 0.8em; padding: 6px 15px;}
             #confirmation-message { font-size: 1em; margin-bottom: 15px; }
             #confirmation-buttons { gap: 10px; }
             #confirmation-buttons button { font-size: 0.8em; padding: 6px 15px; max-width: 200px; }

              /* Adjust start screen elements */
             #main-title { font-size: clamp(3em, 12vh, 6em); margin-bottom: clamp(20px, 5vh, 40px); }
             #start-subtitle { font-size: clamp(1.4em, 4vh, 2em); margin-bottom: clamp(15px, 4vh, 30px); }
             .start-button { font-size: clamp(1.2em, 4vh, 1.8em); padding: clamp(10px, 2.5vh, 20px) clamp(20px, 5vw, 40px); margin: clamp(8px, 1.5vh, 15px); min-width: clamp(220px, 60vw, 300px); }

             /* Adjust settings panel size */
             #settings-panel { top: 50px; right: 10px; padding: 10px; gap: 8px; max-height: calc(100vh - 60px); }
             .settings-icon-button { width: 40px; height: 40px; font-size: 1.2em; padding: 4px; }
         }


    </style>
</head>
<body class="piece-style-classic">
    <!-- Settings Button -->
    <button id="settings-button" title="Settings"> <i class="fas fa-cog"></i> </button>

    <!-- Settings Overlay -->
    <div id="settings-overlay"></div>

    <!-- Settings Panel -->
    <div id="settings-panel">
        <button id="sound-toggle-button" class="settings-icon-button" title="Toggle Sound"> <i class="fas fa-volume-up"></i> </button>
        <button id="timer-toggle-button" class="settings-icon-button" title="Toggle Turn Timer"> <i class="fas fa-clock"></i> </button>
        <button id="undo-button" class="settings-icon-button" title="Undo Move" disabled> <i class="fas fa-undo"></i> </button>
        <button id="hint-button" class="settings-icon-button" title="Hint"> <i class="fas fa-lightbulb"></i> </button>
        <button id="change-board-button" class="settings-icon-button" title="Change Board Design"> <i class="fas fa-chess-board"></i> </button>
        <button id="change-piece-style-button" class="settings-icon-button" title="Change Piece Style"> <i class="fas fa-puzzle-piece"></i> </button>
        <button id="logout-button" class="settings-icon-button" title="Back to Main Menu"> <i class="fas fa-sign-out-alt"></i> </button>
    </div>

    <!-- Start Screen -->
    <div id="start-screen">
        <h1 id="main-title">Checkers Game</h1>
        <h2 id="start-subtitle">Select Play Mode</h2>
        <div id="start-options">
            <button id="vs-human-button" class="start-button">Play vs Friend</button>
            <button id="vs-ai-button" class="start-button">Play vs Computer</button>
        </div>
    </div>

    <!-- AI Difficulty Selector -->
    <div id="ai-difficulty-selector-container">
        <button id="close-difficulty-selector" title="Close"><i class="fas fa-times"></i></button>
        <h3>Select Difficulty Level</h3>
        <div class="difficulty-control">
            <button id="difficulty-prev" class="difficulty-arrow-button" title="Previous"> <i class="fas fa-chevron-left"></i> </button>
            <span id="difficulty-display">Medium</span>
            <button id="difficulty-next" class="difficulty-arrow-button" title="Next"> <i class="fas fa-chevron-right"></i> </button>
        </div>
        <button id="confirm-difficulty-button" class="start-button">Start Game</button>
    </div>

    <!-- Game Container -->
    <div id="game-container">
        <div id="status-bar">
            <div class="status-section capture-count white">
                <i class="fas fa-chess-pawn status-icon" style="color: #eee;"></i>
                <span>Captured:</span> <span id="captured-by-black">0</span>
                <div id="white-timer" class="timer-display">--:--</div>
            </div>
            <div id="turn-indicators">
                <div id="white-indicator" class="turn-indicator"><div class="piece-visual white piece white-piece"></div></div>
                <div id="black-indicator" class="turn-indicator"><div class="piece-visual black piece black-piece"></div></div>
            </div>
            <div class="status-section capture-count black">
                <div id="black-timer" class="timer-display">--:--</div>
                <span>Captured:</span> <span id="captured-by-white">0</span>
                <i class="fas fa-chess-pawn status-icon" style="color: #444;"></i>
            </div>
        </div>
        <div id="board"></div>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen">
        <div id="game-over-content">
            <div id="game-over-message"></div>
            <button id="back-to-menu-button" class="close-selection-button">Back to Main Menu</button>
        </div>
    </div>

    <!-- Board Selection Screen -->
    <div id="board-selection-screen" class="overlay-screen">
        <div id="board-selection-content" class="selection-content">
            <h2>Choose Your Preferred Board Design</h2>
            <div id="board-options-container" class="options-container">
                <button class="board-option option-button" data-style="wood" title="Wood"><div class="board-preview board-preview-wood"><div class="sq light"></div><div class="sq dark"></div> <div class="sq dark"></div><div class="sq light"></div></div> <span>Wood</span></button>
                <button class="board-option option-button" data-style="desert" title="Desert"><div class="board-preview board-preview-desert"><div class="sq light"></div><div class="sq dark"></div> <div class="sq dark"></div><div class="sq light"></div></div> <span>Desert</span></button>
                <button class="board-option option-button" data-style="stone-path" title="Stone Path"><div class="board-preview board-preview-stone-path"><div class="sq light"></div><div class="sq dark"></div> <div class="sq dark"></div><div class="sq light"></div></div> <span>Stone Path</span></button>
                <button class="board-option option-button" data-style="emerald" title="Emerald"><div class="board-preview board-preview-emerald"><div class="sq light"></div><div class="sq dark"></div> <div class="sq dark"></div><div class="sq light"></div></div> <span>Emerald</span></button>
                <button class="board-option option-button" data-style="volcano" title="Volcano"><div class="board-preview board-preview-volcano"><div class="sq light"></div><div class="sq dark"></div> <div class="sq dark"></div><div class="sq light"></div></div> <span>Volcano</span></button>
                <button class="board-option option-button" data-style="royal" title="Royal"><div class="board-preview board-preview-royal"><div class="sq light"></div><div class="sq dark"></div> <div class="sq dark"></div><div class="sq light"></div></div> <span>Royal</span></button>
             </div>
            <button id="close-board-selection" class="close-selection-button">Close</button>
        </div>
    </div>

    <!-- Piece Style Selection Screen -->
    <div id="piece-style-selection-screen" class="overlay-screen">
        <div id="piece-style-selection-content" class="selection-content">
            <h2>Choose Your Preferred Piece Style</h2>
            <div id="piece-options-container" class="options-container">
                <button class="piece-option option-button" data-style="classic" title="Classic"><div class="piece-preview-container"><div class="piece-preview white classic"></div> <div class="piece-preview black classic"></div></div> <span>Classic</span></button>
                <button class="piece-option option-button" data-style="flat" title="Flat"><div class="piece-preview-container"><div class="piece-preview white flat"></div> <div class="piece-preview black flat"></div></div> <span>Flat</span></button>
                <button class="piece-option option-button" data-style="crimson" title="Crimson"><div class="piece-preview-container"><div class="piece-preview white crimson"></div> <div class="piece-preview black crimson"></div></div> <span>Crimson</span></button>
                <button class="piece-option option-button" data-style="azure" title="Azure"><div class="piece-preview-container"><div class="piece-preview white azure"></div> <div class="piece-preview black azure"></div></div> <span>Azure</span></button>
                <button class="piece-option option-button" data-style="forest" title="Forest"><div class="piece-preview-container"><div class="piece-preview white forest"></div> <div class="piece-preview black forest"></div></div> <span>Forest</span></button>
                <button class="piece-option option-button" data-style="royal" title="Royal"><div class="piece-preview-container"><div class="piece-preview white royal"></div> <div class="piece-preview black royal"></div></div> <span>Royal</span></button>
             </div>
            <button id="close-piece-selection" class="close-selection-button">Close</button>
        </div>
    </div>

    <!-- Confirmation Modal -->
    <div id="confirmation-modal" class="overlay-screen">
        <div id="confirmation-content" class="selection-content">
            <p id="confirmation-message">Are you sure you want to return to the main menu? Your current game progress will be lost.</p>
            <div id="confirmation-buttons">
                <button id="confirm-logout-button" class="close-selection-button">Yes, Confirm</button>
                <button id="cancel-logout-button" class="close-selection-button">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // --- Element References ---
        const bodyElement = document.body;
        const startScreen = document.getElementById('start-screen');
        const mainTitle = document.getElementById('main-title');
        const startSubtitle = document.getElementById('start-subtitle');
        const startOptions = document.getElementById('start-options');
        const vsHumanButton = document.getElementById('vs-human-button');
        const vsAiButton = document.getElementById('vs-ai-button');
        const aiDifficultySelectorContainer = document.getElementById('ai-difficulty-selector-container');
        const difficultyPrevButton = document.getElementById('difficulty-prev');
        const difficultyNextButton = document.getElementById('difficulty-next');
        const difficultyDisplay = document.getElementById('difficulty-display');
        const confirmDifficultyButton = document.getElementById('confirm-difficulty-button');
        const gameContainer = document.getElementById('game-container');
        const statusBar = document.getElementById('status-bar');
        const whiteCapturedDisplay = document.getElementById('captured-by-black');
        const blackCapturedDisplay = document.getElementById('captured-by-white');
        const whiteTimerDisplay = document.getElementById('white-timer');
        const blackTimerDisplay = document.getElementById('black-timer');
        const boardElement = document.getElementById('board');
        const whiteIndicator = document.getElementById('white-indicator');
        const blackIndicator = document.getElementById('black-indicator');
        const gameOverScreen = document.getElementById('game-over-screen');
        const gameOverMessage = document.getElementById('game-over-message');
        const backToMenuButton = document.getElementById('back-to-menu-button');
        const settingsButton = document.getElementById('settings-button');
        const settingsPanel = document.getElementById('settings-panel');
        const settingsOverlay = document.getElementById('settings-overlay');
        const soundToggleButton = document.getElementById('sound-toggle-button');
        const timerToggleButton = document.getElementById('timer-toggle-button');
        const undoButton = document.getElementById('undo-button');
        const hintButton = document.getElementById('hint-button');
        const logoutButton = document.getElementById('logout-button');
        const changeBoardButton = document.getElementById('change-board-button');
        const changePieceStyleButton = document.getElementById('change-piece-style-button');
        const boardSelectionScreen = document.getElementById('board-selection-screen');
        const boardOptionsContainer = document.getElementById('board-options-container');
        const closeBoardSelectionButton = document.getElementById('close-board-selection');
        const pieceStyleSelectionScreen = document.getElementById('piece-style-selection-screen');
        const pieceOptionsContainer = document.getElementById('piece-options-container');
        const closePieceSelectionButton = document.getElementById('close-piece-selection');
        const confirmationModal = document.getElementById('confirmation-modal');
        const confirmLogoutButton = document.getElementById('confirm-logout-button');
        const cancelLogoutButton = document.getElementById('cancel-logout-button');
        const closeDifficultySelectorButton = document.getElementById('close-difficulty-selector');

        // --- Audio ---
        let audioCtx;
        function getAudioContext() {
            if (!audioCtx && (window.AudioContext || window.webkitAudioContext)) {
                try {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.error("Web Audio API not supported", e);
                }
            }
            return audioCtx;
        }
        let isSoundEnabled = localStorage.getItem('isSoundEnabled') !== 'false';

        // Function to play sound effect
        function playSound(type, options = {}) {
            if (!isSoundEnabled) return;
            const ctx = getAudioContext();
            if (!ctx) return;

            // Check if context is suspended (e.g., before user interaction)
            if (ctx.state === 'suspended') {
                // Attempt to resume context
                ctx.resume().then(() => {
                    // If successful, play sound
                    if (ctx.state === 'running') {
                        playSoundInternal(ctx, type, options);
                    }
                }).catch(e => console.error("Error resuming AudioContext:", e));
                return; // Exit for now, sound will play after resume
            }

            // If context is running, play sound immediately
            if (ctx.state === 'running') {
                playSoundInternal(ctx, type, options);
            }
        }

        // Internal function to handle the actual sound creation
        function playSoundInternal(ctx, type, options) {
            try {
                const time = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();

                osc.connect(gain);
                gain.connect(ctx.destination);

                gain.gain.setValueAtTime(options.volume || 0.2, time); // Default volume

                switch (type) {
                    case 'select':
                        osc.type = 'triangle';
                        osc.frequency.setValueAtTime(1500, time);
                        gain.gain.setValueAtTime(options.volume || 0.15, time);
                        gain.gain.linearRampToValueAtTime(0.001, time + 0.05);
                        osc.start(time);
                        osc.stop(time + 0.05);
                        break;
                    case 'move':
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(600, time);
                        osc.frequency.linearRampToValueAtTime(400, time + 0.08);
                        gain.gain.setValueAtTime(options.volume || 0.2, time);
                        gain.gain.linearRampToValueAtTime(0.001, time + 0.08);
                        osc.start(time);
                        osc.stop(time + 0.08);
                        break;
                    case 'capture':
                        osc.type = 'square';
                        osc.frequency.setValueAtTime(500, time);
                        gain.gain.setValueAtTime(options.volume || 0.25, time);
                        gain.gain.exponentialRampToValueAtTime(0.001, time + 0.12);
                        osc.start(time);
                        osc.stop(time + 0.12);
                        break;
                    case 'king':
                        osc.type = 'sine';
                        gain.gain.setValueAtTime(options.volume || 0.25, time);
                        osc.frequency.setValueAtTime(880, time); // A5 note
                        osc.frequency.linearRampToValueAtTime(1318.51, time + 0.15); // E6 note
                        gain.gain.linearRampToValueAtTime(0.001, time + 0.2);
                        osc.start(time);
                        osc.stop(time + 0.2);
                        break;
                    case 'win':
                        gain.gain.setValueAtTime(options.volume || 0.3, time);
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(523.25, time); // C5 note
                        osc.start(time);
                        osc.stop(time + 0.15);
                        // Add a second note for a simple melody
                        const osc2 = ctx.createOscillator();
                        const gain2 = ctx.createGain();
                        osc2.connect(gain2);
                        gain2.connect(ctx.destination);
                        gain2.gain.setValueAtTime(options.volume || 0.3, time + 0.15);
                        osc2.type = 'sine';
                        osc2.frequency.setValueAtTime(783.99, time + 0.15); // G5 note
                         gain2.gain.linearRampToValueAtTime(0.001, time + 0.4);
                        osc2.start(time + 0.15);
                        osc2.stop(time + 0.4);
                        break;
                    case 'undo':
                        osc.type = 'sawtooth';
                        osc.frequency.setValueAtTime(300, time);
                        osc.frequency.linearRampToValueAtTime(500, time + 0.1);
                        gain.gain.setValueAtTime(options.volume || 0.15, time);
                        gain.gain.linearRampToValueAtTime(0.001, time + 0.1);
                        osc.start(time);
                        osc.stop(time + 0.1);
                        break;
                    case 'hint':
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(1200, time);
                        gain.gain.setValueAtTime(options.volume || 0.1, time);
                        gain.gain.linearRampToValueAtTime(0.001, time + 0.08);
                        osc.start(time);
                        osc.stop(time + 0.08);
                        break;
                    case 'timer_tick':
                         osc.type = 'sine';
                         osc.frequency.setValueAtTime(900, time);
                         gain.gain.setValueAtTime(options.volume || 0.05, time);
                         gain.gain.linearRampToValueAtTime(0.001, time + 0.05);
                         osc.start(time);
                         osc.stop(time + 0.05);
                         break;
                    case 'timeout':
                         osc.type = 'square';
                         osc.frequency.setValueAtTime(440, time); // A4
                         gain.gain.setValueAtTime(options.volume || 0.3, time);
                         gain.gain.linearRampToValueAtTime(0.001, time + 0.3);
                         osc.start(time);
                         osc.stop(time + 0.3);
                         break;

                    default:
                        console.warn("Unknown sound type:", type);
                        break;
                }
            } catch (e) {
                console.error("Error playing sound:", type, e);
            }
        }


        // --- Game Constants & State ---
        const BOARD_SIZE = 8;
        const PLAYER_BLACK = 'black';
        const PLAYER_WHITE = 'white';
        const AI_PLAYER = PLAYER_WHITE; // AI plays as White

        const DIFFICULTIES = {
            EASY: 'easy',
            MEDIUM: 'medium',
            HARD: 'hard'
        };
        const MINIMAX_DEPTH = {
            MEDIUM: 3, // Depth for Medium difficulty
            HARD: 5    // Depth for Hard difficulty
        };
        const TIMER_DURATION = 60; // Seconds per turn

        const difficultyLevels = [DIFFICULTIES.EASY, DIFFICULTIES.MEDIUM, DIFFICULTIES.HARD];
        const difficultyLabels = {
            easy: 'Easy',
            medium: 'Medium',
            hard: 'Hard'
        };
        let currentDifficultyIndex = 1; // Start at Medium

        let chosenAiDifficulty = difficultyLevels[currentDifficultyIndex];

        let boardState = [];
        let currentPlayer = PLAYER_BLACK;
        let selectedPiece = null;
        let possibleMoves = []; // Moves for the selected piece
        let continuousJumpPossible = false; // Flag for multi-jump turns

        let gameMode = 'human'; // 'human' or 'ai'
        let aiDifficulty = chosenAiDifficulty;
        let isAiThinking = false;
        let isGameOver = true; // Start in game over state (menu visible)
        let isSettingsPanelVisible = false;

        let currentBoardStyle = localStorage.getItem('boardStyle') || 'wood';
        let currentPieceStyle = localStorage.getItem('pieceStyle') || 'classic';

        let capturedByBlack = 0;
        let capturedByWhite = 0;
        let moveHistory = []; // To store board states for undo

        let isTimerEnabled = localStorage.getItem('isTimerEnabled') === 'true'; // Default to off unless explicitly true in storage
        let currentTurnTimeRemaining = TIMER_DURATION;
        let timerIntervalId = null;
        let hintTimeoutId = null; // To clear hint highlights after a delay

        // --- Utility Functions ---
        function isValidSquare(row, col) {
            return row >= 0 && row < BOARD_SIZE && col >= 0 && col < BOARD_SIZE;
        }

        // Helper to create a deep copy of the board state
        function deepCopyBoard(board) {
            return JSON.parse(JSON.stringify(board));
        }

        function getOpponent(player) {
            return player === PLAYER_BLACK ? PLAYER_WHITE : PLAYER_BLACK;
        }

        // --- UI Update Functions ---
        function updateSoundButtonIcon() {
            const icon = soundToggleButton.querySelector('i');
            if (isSoundEnabled) {
                icon.classList.remove('fa-volume-mute');
                icon.classList.add('fa-volume-up');
                soundToggleButton.classList.remove('sound-off');
                soundToggleButton.title = "Toggle Sound (On)";
            } else {
                icon.classList.remove('fa-volume-up');
                icon.classList.add('fa-volume-mute');
                soundToggleButton.classList.add('sound-off');
                soundToggleButton.title = "Toggle Sound (Off)";
            }
        }

        function updateTimerButtonIcon() {
             const icon = timerToggleButton.querySelector('i');
             if (isTimerEnabled) {
                 icon.classList.remove('fa-stopwatch');
                 icon.classList.add('fa-clock');
                 timerToggleButton.classList.remove('timer-off');
                 timerToggleButton.title = "Toggle Turn Timer (On)";
             } else {
                 icon.classList.remove('fa-clock');
                 icon.classList.add('fa-stopwatch');
                 timerToggleButton.classList.add('timer-off');
                 timerToggleButton.title = "Toggle Turn Timer (Off)";
             }
         }

        // Update piece appearance on turn indicators based on selected style
        function updateTurnIndicatorVisuals() {
            const whiteVisual = whiteIndicator.querySelector('.piece-visual');
            const blackVisual = blackIndicator.querySelector('.piece-visual');

            // Clear existing inline styles and classes related to previous style
            whiteVisual.style = '';
            blackVisual.style = '';
            whiteVisual.className = `piece-visual white piece white-piece`; // Add base classes
            blackVisual.className = `piece-visual black piece black-piece`;

            // Apply current piece style classes
            whiteVisual.classList.add(currentPieceStyle);
            blackVisual.classList.add(currentPieceStyle);
        }


        function updateCapturedCounters() {
            whiteCapturedDisplay.textContent = capturedByBlack;
            blackCapturedDisplay.textContent = capturedByWhite;
        }

        function updateUndoButton() {
            // Disable undo if:
            // - No moves in history
            // - AI is thinking
            // - Game is over
            // - Game mode is AI and it's not human's turn (only allow human to undo their last move)
            // - Game mode is AI and there's only one state (initial state)
            undoButton.disabled = moveHistory.length === 0 || isAiThinking || isGameOver || (gameMode === 'ai' && currentPlayer !== AI_PLAYER && moveHistory.length < 1);
        }

        function updateHintButton() {
            // Disable hint if:
            // - AI is thinking
            // - Game is over
            // - Game mode is AI and it's AI's turn
             hintButton.disabled = isAiThinking || isGameOver || (gameMode === 'ai' && currentPlayer === AI_PLAYER);
        }

        function formatTime(seconds) {
            if (seconds < 0) seconds = 0; // Should not happen with interval clear, but safety
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        function updateTimerDisplay() {
             if (!isTimerEnabled) {
                 whiteTimerDisplay.textContent = '--:--';
                 blackTimerDisplay.textContent = '--:--';
                 return;
             }
             // Only update the display for the current player's timer
             const display = currentPlayer === PLAYER_WHITE ? whiteTimerDisplay : blackTimerDisplay;
             const otherDisplay = currentPlayer === PLAYER_WHITE ? blackTimerDisplay : whiteTimerDisplay; // The timer that is paused
             display.textContent = formatTime(currentTurnTimeRemaining);
             otherDisplay.textContent = formatTime(TIMER_DURATION); // Show full time for the player whose turn is not active
         }

         function updateDifficultySelectorDisplay() {
             chosenAiDifficulty = difficultyLevels[currentDifficultyIndex];
             difficultyDisplay.textContent = difficultyLabels[chosenAiDifficulty];
         }


        // --- Timer Logic ---
         function stopTurnTimer() {
             if (timerIntervalId) {
                 clearInterval(timerIntervalId);
                 timerIntervalId = null;
             }
         }

         function startTurnTimer() {
             stopTurnTimer(); // Stop any existing timer first
             if (!isTimerEnabled || isGameOver) {
                 updateTimerDisplay(); // Ensure displays are consistent when timer is off
                 return;
             }

             currentTurnTimeRemaining = TIMER_DURATION; // Reset timer for the new turn
             updateTimerDisplay(); // Update display immediately

             timerIntervalId = setInterval(() => {
                 currentTurnTimeRemaining--;
                 updateTimerDisplay();

                 // Play warning sound for last few seconds
                 if (currentTurnTimeRemaining <= 5 && currentTurnTimeRemaining > 0) {
                     playSound('timer_tick', { volume: 0.1 });
                 }

                 if (currentTurnTimeRemaining <= 0) {
                     handleTimeout();
                 }
             }, 1000); // Update every second
         }

         function handleTimeout() {
             stopTurnTimer(); // Stop the timer interval
             if (isGameOver) return; // Prevent multiple game over calls

             playSound('timeout');

             const winner = getOpponent(currentPlayer);
             const winnerText = winner === PLAYER_BLACK ? "Black" : "White";
             endGame(`${winnerText} Wins (Opponent ran out of time)!`);
         }


        // --- Game Flow Functions ---
        function initGame() {
            stopTurnTimer(); // Ensure timer is stopped before starting a new game
            isGameOver = false;
            gameOverScreen.classList.remove('visible');
            // Ensure overlays are hidden
            settingsOverlay.style.display = 'none';
            document.querySelectorAll('.dark-square').forEach(sq => { sq.style.cursor = 'pointer'; }); // Reset cursor

            boardState = createInitialBoardState();
            currentPlayer = PLAYER_BLACK;
            selectedPiece = null;
            possibleMoves = [];
            continuousJumpPossible = false;
            isAiThinking = false;
            isSettingsPanelVisible = false;
            settingsPanel.classList.remove('visible');
            boardSelectionScreen.classList.remove('visible');
            pieceStyleSelectionScreen.classList.remove('visible');
            confirmationModal.classList.remove('visible');

            capturedByBlack = 0;
            capturedByWhite = 0;
            moveHistory = []; // Clear history for a new game

            loadBoardStyle(); // Apply saved/default styles
            loadPieceStyle();
            updateTurnIndicatorVisuals(); // Ensure indicators show correct piece style

            createBoardUI(); // Create the board DOM elements
            renderBoard(); // Populate the board with pieces

            updateStatus(); // Update turn indicator
            updateCapturedCounters(); // Reset captured piece counts
            updateUndoButton(); // Update undo button state
            updateHintButton(); // Update hint button state

            settingsButton.style.display = 'block'; // Show settings button in game

            startTurnTimer(); // Start the timer for the first player (Black)

            // If AI is Black (not the case here) or first player is AI in other game modes, start AI move
            // Currently, Black is always human/first player
            if (gameMode === 'ai' && currentPlayer === AI_PLAYER) {
                 // This case shouldn't happen with AI as white, but kept for robustness
                 isAiThinking = true;
                 requestAnimationFrame(() => { setTimeout(makeAiMove, 500); }); // Small delay before AI thinks
            }
        }


        function startGame(mode) {
            playSound('select', { volume: 0.4 }); // Play sound on button click
            gameMode = mode;

            if (gameMode === 'human') {
                aiDifficulty = DIFFICULTIES.EASY; // AI difficulty doesn't matter for human mode, but set a default
                // Hide start screen and show game container
                startScreen.classList.add('hidden-completely');
                aiDifficultySelectorContainer.classList.remove('visible'); // Ensure selector is hidden
                gameContainer.style.display = 'flex';
                initGame();
            } else {
                // AI mode: first show difficulty selector
                showDifficultySelector();
            }
        }

        function startAiGame() {
            playSound('select', { volume: 0.4 }); // Play sound on button click
            gameMode = 'ai';
            aiDifficulty = chosenAiDifficulty; // Use the selected difficulty

            // Hide start screen and difficulty selector, show game container
            startScreen.classList.add('hidden-completely');
            aiDifficultySelectorContainer.classList.remove('visible');
            gameContainer.style.display = 'flex';
            settingsButton.style.display = 'block'; // Show settings button

            initGame(); // Initialize the game state and UI
        }


        function returnToStartScreen() {
            playSound('select');
            stopTurnTimer(); // Stop timer when returning to menu

            // Hide game elements and overlays
            gameOverScreen.classList.remove('visible');
            gameContainer.style.display = 'none';
            aiDifficultySelectorContainer.classList.remove('visible'); // Ensure selector is hidden

            // Show start screen
            startScreen.classList.remove('hidden-completely');

            // Hide settings related elements
            settingsButton.style.display = 'none';
            settingsPanel.classList.remove('visible');
            settingsOverlay.style.display = 'none';
            isSettingsPanelVisible = false; // Reset panel state

            // Reset game state variables
            boardState = [];
            currentPlayer = PLAYER_BLACK;
            selectedPiece = null;
            possibleMoves = [];
            continuousJumpPossible = false;
            isAiThinking = false;
            isGameOver = true; // Mark game as over
            capturedByBlack = 0;
            capturedByWhite = 0;
            moveHistory = [];

            // Reset UI elements
            whiteIndicator.classList.remove('active-turn');
            blackIndicator.classList.remove('active-turn');
            updateStatus(""); // Clear status text if any
            updateCapturedCounters(); // Reset displayed counts
            updateUndoButton(); // Disable undo
            updateHintButton(); // Disable hint
            updateTimerDisplay(); // Reset timer display

            // Ensure start screen elements are visible/animated correctly if needed
            mainTitle.style.opacity = 1; // Ensure title is visible
            startSubtitle.style.opacity = 1; // Ensure subtitle is visible
            startOptions.style.opacity = 1; // Ensure options are visible
            startSubtitle.textContent = "Select Play Mode"; // Reset subtitle text
             // Animations (fadeInTitle, fadeInSubtitle, fadeInUpButton) will replay due to display: none -> flex,
             // but explicitly setting opacity=1 above helps ensure they are immediately visible if animation is skipped/fast.
        }


        function endGame(message) {
            if (isGameOver) return; // Prevent calling multiple times
            isGameOver = true;
            stopTurnTimer(); // Stop the timer
            playSound('win');
            isAiThinking = false; // Ensure AI stops thinking if it was the AI's turn

            gameOverMessage.textContent = message;
            gameOverScreen.classList.add('visible');

            // Hide settings button and panel to prevent interaction during game over
            settingsButton.style.display = 'none';
            settingsPanel.classList.remove('visible');
            settingsOverlay.style.display = 'none';

            // Ensure no other overlays are visible
            boardSelectionScreen.classList.remove('visible');
            pieceStyleSelectionScreen.classList.remove('visible');
            confirmationModal.classList.remove('visible');


            // Update status/buttons one last time
            updateStatus(); // Status bar should reflect game over (no active player)
            updateUndoButton(); // Undo should be disabled
            updateHintButton(); // Hint should be disabled

            renderBoard(); // Re-render board to clear possible moves/selection
        }


        // --- Modal/Overlay Functions ---
        function showConfirmationModal() {
            if (isGameOver) return; // Don't show modal if game is already over
            stopTurnTimer(); // Pause timer
            settingsPanel.classList.remove('visible'); // Hide settings panel
            settingsOverlay.style.display = 'none'; // Hide settings overlay
            isSettingsPanelVisible = false; // Reset settings state
            confirmationModal.classList.add('visible');
            renderBoard(); // Re-render board to dim/disable interaction behind modal
        }

        function hideConfirmationModal() {
            confirmationModal.classList.remove('visible');
            // Resume timer only if game is NOT over and settings panel is NOT open
            if (!isGameOver && !isSettingsPanelVisible) {
                 startTurnTimer();
            }
             renderBoard(); // Re-render board to re-enable interaction/clear dimming
        }

        function showOverlay(overlayElement) {
             if (isGameOver) return; // Don't show overlay if game is already over
             stopTurnTimer(); // Pause timer
             settingsPanel.classList.remove('visible'); // Hide settings panel
             settingsOverlay.style.display = 'none'; // Hide settings overlay
             isSettingsPanelVisible = false; // Reset settings state
             overlayElement.classList.add('visible');
             renderBoard(); // Re-render board to dim/disable interaction behind overlay
         }

         function hideOverlay(overlayElement) {
             overlayElement.classList.remove('visible');
             // Resume timer only if game is NOT over and settings panel is NOT open
             if (!isGameOver && !isSettingsPanelVisible) {
                 startTurnTimer();
             }
             renderBoard(); // Re-render board to re-enable interaction/clear dimming
         }


        // --- Event Listeners ---
        vsHumanButton.addEventListener('click', () => startGame('human'));
        vsAiButton.addEventListener('click', () => {
             playSound('select'); // Play sound immediately on AI button click
             showDifficultySelector();
         });

        difficultyPrevButton.addEventListener('click', () => {
             playSound('select', {volume: 0.1}); // Softer click sound for arrows
             currentDifficultyIndex = (currentDifficultyIndex - 1 + difficultyLevels.length) % difficultyLevels.length;
             updateDifficultySelectorDisplay();
         });

        difficultyNextButton.addEventListener('click', () => {
             playSound('select', {volume: 0.1}); // Softer click sound for arrows
             currentDifficultyIndex = (currentDifficultyIndex + 1) % difficultyLevels.length;
             updateDifficultySelectorDisplay();
         });

        confirmDifficultyButton.addEventListener('click', startAiGame);

        closeDifficultySelectorButton.addEventListener('click', () => {
             playSound('select');
             aiDifficultySelectorContainer.classList.remove('visible');
             startScreen.classList.remove('hidden-completely'); // Go back to main start screen
         });

        // Helper function to show the difficulty selector
        function showDifficultySelector() {
            startScreen.classList.add('hidden-completely');
            aiDifficultySelectorContainer.classList.add('visible');
            updateDifficultySelectorDisplay(); // Ensure correct difficulty is shown
        }


        backToMenuButton.addEventListener('click', returnToStartScreen);
        logoutButton.addEventListener('click', () => { playSound('select'); showConfirmationModal(); });
        confirmLogoutButton.addEventListener('click', () => { playSound('select'); hideConfirmationModal(); returnToStartScreen(); });
        cancelLogoutButton.addEventListener('click', () => { playSound('select'); hideConfirmationModal(); });

        // Close modal if clicking outside the content area
        confirmationModal.addEventListener('click', (event) => {
            if (event.target === confirmationModal) {
                playSound('select');
                hideConfirmationModal();
            }
        });

        settingsButton.addEventListener('click', () => {
             playSound('select');
             isSettingsPanelVisible = !isSettingsPanelVisible;
             if (isSettingsPanelVisible) {
                 if (!isGameOver) stopTurnTimer(); // Pause timer if settings are opened during a game
                 settingsPanel.classList.add('visible');
                 settingsOverlay.style.display = 'block'; // Show transparent overlay
                 // Hide any other open overlays/modals when settings opens
                 boardSelectionScreen.classList.remove('visible');
                 pieceStyleSelectionScreen.classList.remove('visible');
                 confirmationModal.classList.remove('visible');
             } else {
                 if (!isGameOver) startTurnTimer(); // Resume timer if settings are closed and game is ongoing
                 settingsPanel.classList.remove('visible');
                 settingsOverlay.style.display = 'none'; // Hide transparent overlay
             }
             renderBoard(); // Re-render to update pointer-events on board
         });

         settingsOverlay.addEventListener('click', () => {
             // Only close settings if it was the overlay click that hid it
             if(isSettingsPanelVisible) {
                 playSound('select');
                 isSettingsPanelVisible = false;
                 settingsPanel.classList.remove('visible');
                 settingsOverlay.style.display = 'none';
                 if (!isGameOver) startTurnTimer(); // Resume timer
                 renderBoard(); // Re-render board to enable interaction
             }
         });

        soundToggleButton.addEventListener('click', () => {
             isSoundEnabled = !isSoundEnabled;
             localStorage.setItem('isSoundEnabled', isSoundEnabled);
             updateSoundButtonIcon();
             if (isSoundEnabled) {
                  // Attempt to resume AudioContext if it's suspended
                 const ctx = getAudioContext();
                 if (ctx && ctx.state === 'suspended') {
                     ctx.resume(); // Browsers require user interaction to resume AudioContext
                 }
                 playSound('select', { volume: 0.4 }); // Play sound after enabling
             }
         });

        timerToggleButton.addEventListener('click', () => {
             isTimerEnabled = !isTimerEnabled;
             localStorage.setItem('isTimerEnabled', isTimerEnabled);
             updateTimerButtonIcon();
             playSound('select'); // Play sound on toggle
             // Start/Stop timer based on new state and game state
             if (isTimerEnabled && !isGameOver && !isSettingsPanelVisible && !confirmationModal.classList.contains('visible')) {
                 startTurnTimer();
             } else {
                 stopTurnTimer();
                 updateTimerDisplay(); // Update display to --:-- if stopped
             }
         });


        undoButton.addEventListener('click', () => {
            if (!undoButton.disabled) {
                playSound('undo');
                undoMove();
            }
        });

        hintButton.addEventListener('click', () => {
             if (!hintButton.disabled) {
                 playSound('hint');
                 showHint();
             }
         });


        changeBoardButton.addEventListener('click', () => { playSound('select'); updateSelectedBoardOption(); showOverlay(boardSelectionScreen); });
        changePieceStyleButton.addEventListener('click', () => { playSound('select'); updateSelectedPieceOption(); showOverlay(pieceStyleSelectionScreen); });
        closeBoardSelectionButton.addEventListener('click', () => { playSound('select'); hideOverlay(boardSelectionScreen); });
        closePieceSelectionButton.addEventListener('click', () => { playSound('select'); hideOverlay(pieceStyleSelectionScreen); });

        // Event delegation for board option clicks
        boardOptionsContainer.addEventListener('click', (event) => {
            const targetOption = event.target.closest('.board-option');
            if (targetOption) {
                const selectedStyle = targetOption.dataset.style;
                if (selectedStyle && selectedStyle !== currentBoardStyle) {
                    applyBoardStyle(selectedStyle);
                    playSound('select'); // Play sound when style changes
                }
                updateSelectedBoardOption(); // Update selection highlight
            }
        });

        // Event delegation for piece style option clicks
        pieceOptionsContainer.addEventListener('click', (event) => {
            const targetOption = event.target.closest('.piece-option');
            if (targetOption) {
                const selectedStyle = targetOption.dataset.style;
                if (selectedStyle && selectedStyle !== currentPieceStyle) {
                    applyPieceStyle(selectedStyle);
                    playSound('select'); // Play sound when style changes
                }
                updateSelectedPieceOption(); // Update selection highlight
            }
        });


        // --- Board Setup and Rendering ---
        function createInitialBoardState() {
            const state = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(null));
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    // Only place pieces on dark squares
                    if ((r + c) % 2 !== 0) {
                        // White pieces in the first 3 rows
                        if (r < 3) {
                            state[r][c] = { player: PLAYER_WHITE, isKing: false };
                        }
                        // Black pieces in the last 3 rows
                        else if (r > 4) {
                            state[r][c] = { player: PLAYER_BLACK, isKing: false };
                        }
                    }
                }
            }
            return state;
        }

        function createBoardUI() {
            boardElement.innerHTML = ''; // Clear previous board UI

            // Get the current calculated square size
            const squareSize = parseFloat(getComputedStyle(boardElement).getPropertyValue('--square-size'));

            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const sq = document.createElement('div');
                    sq.classList.add('square', (r + c) % 2 === 0 ? 'light-square' : 'dark-square');
                    sq.dataset.row = r;
                    sq.dataset.col = c;

                    // Store position for potential drag/drop calculations (though CSS transform is used for animation)
                    sq.dataset.x = c * squareSize;
                    sq.dataset.y = r * squareSize;

                    // Add click listener only to dark squares (where pieces can be and moves end)
                    if ((r + c) % 2 !== 0) {
                         sq.addEventListener('click', handleSquareClick);
                     }

                    boardElement.appendChild(sq);
                }
            }
        }

        function getSquareElement(row, col) {
             if (!isValidSquare(row, col)) return null;
             return boardElement.querySelector(`.square[data-row="${row}"][data-col="${col}"]`);
        }

        // Use a timeout to batch render requests and prevent flickering
        let renderTimeout;
        function requestRender() {
            clearTimeout(renderTimeout);
            renderTimeout = setTimeout(renderBoard, 0); // Render on the next animation frame
        }

        function renderBoard() {
            clearHintHighlights(); // Clear any active hints

            // Determine if user interaction on the board should be blocked
            const isInteractionBlocked = isGameOver || isAiThinking || isSettingsPanelVisible || boardSelectionScreen.classList.contains('visible') || pieceStyleSelectionScreen.classList.contains('visible') || confirmationModal.classList.contains('visible') || (gameMode === 'ai' && currentPlayer === AI_PLAYER);

            const allSquares = boardElement.querySelectorAll('.square');

            // Remove previous possible move indicators and reset cursors
            allSquares.forEach(sq => {
                sq.classList.remove('possible-move');
                // Reset cursor based on interaction state
                const isDarkSquare = sq.classList.contains('dark-square');
                 sq.style.cursor = (isDarkSquare && !isInteractionBlocked && !isSettingsPanelVisible) ? 'pointer' : 'default';

                // Remove piece elements that are not currently moving
                // This is crucial for correctly updating piece positions and appearance
                const existingPiece = sq.querySelector('.piece');
                if (existingPiece && !existingPiece.classList.contains('moving')) {
                    existingPiece.remove();
                }
            });

            // Check if any jump is possible for the current player (for jump hints)
            const allPossibleJumps = !isInteractionBlocked ? getAllPossibleMoves(currentPlayer, true, boardState) : [];
            const jumpIsPossibleAnywhere = allPossibleJumps.length > 0;


            // Add pieces to the board based on current state
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const pieceData = boardState[r][c];
                    const square = getSquareElement(r, c);

                    if (pieceData && square) {
                        // Check if a piece element for this position already exists (e.g., from a previous render or animation)
                        let pieceEl = square.querySelector(`.piece[data-piece-id="${r}-${c}"]`);

                        if (!pieceEl) {
                            // If not, create a new piece element
                            pieceEl = document.createElement('div');
                            pieceEl.dataset.pieceId = `${r}-${c}`; // Unique ID for the piece element
                            pieceEl.className = `piece ${pieceData.player}-piece ${currentPieceStyle} ${pieceData.isKing ? 'king' : ''}`;
                            // Position centrally using transform
                            pieceEl.style.transform = `translate(-50%, -50%)`;
                            square.appendChild(pieceEl); // Add to the square
                        } else {
                             // If it exists, update its classes
                             pieceEl.className = `piece ${pieceData.player}-piece ${currentPieceStyle} ${pieceData.isKing ? 'king' : ''}`;
                        }

                        // Determine if the piece is currently interactive (clickable/draggable)
                        const canInteractPiece = !isInteractionBlocked && pieceData.player === currentPlayer && !(continuousJumpPossible && selectedPiece && (selectedPiece.row !== r || selectedPiece.col !== c));

                        pieceEl.classList.toggle('interactive', canInteractPiece);
                        pieceEl.style.cursor = (canInteractPiece && !isSettingsPanelVisible) ? 'grab' : 'default'; // Set cursor
                        pieceEl.style.pointerEvents = (canInteractPiece && !isSettingsPanelVisible) ? 'auto' : 'none'; // Enable/disable pointer events

                        // Add click handler for selection only if interactive and not in settings/overlays
                        pieceEl.onclick = (canInteractPiece && !isSettingsPanelVisible) ? (e) => {
                             e.stopPropagation(); // Prevent square click handler from firing
                             handlePieceClick(e);
                            } : null; // Remove handler if not interactive

                        // Add jump hint class if a jump is required and this piece can jump
                        pieceEl.classList.remove('jump-hint'); // Remove any previous hint class
                        if (jumpIsPossibleAnywhere && !continuousJumpPossible && pieceData.player === currentPlayer) {
                             const thisPieceCanJump = allPossibleJumps.some(jump => jump.origin.r === r && jump.origin.c === c);
                             if (thisPieceCanJump) {
                                 pieceEl.classList.add('jump-hint');
                             }
                         }

                        // Add selected class if this is the currently selected piece
                        pieceEl.classList.toggle('selected', selectedPiece && selectedPiece.row === r && selectedPiece.col === c);

                        // Store the element reference in the selectedPiece object if it exists
                        if(selectedPiece && selectedPiece.row === r && selectedPiece.col === c){
                            selectedPiece.element = pieceEl;
                        }
                    }
                }
            }

            // Highlight possible moves for the selected piece
            if (selectedPiece && !isInteractionBlocked) {
                // Calculate moves based on whether a continuous jump is required
                const movesToHighlight = continuousJumpPossible
                    ? calculateMovesForPieceInternal(selectedPiece.row, selectedPiece.col, true, boardState) // Only jumps
                    : calculateMovesForPieceInternal(selectedPiece.row, selectedPiece.col, false, boardState); // All moves (jumps and regular)

                movesToHighlight.forEach(move => {
                    const sq = getSquareElement(move.row, move.col);
                    if (sq) {
                        sq.classList.add('possible-move'); // Add class for visual indicator
                         sq.style.cursor = 'pointer'; // Set cursor to pointer for valid move squares
                    }
                });
            }

            // Add hover effects to interactive pieces
            if (!isInteractionBlocked && !isSettingsPanelVisible) {
                 addHoverEffects();
            } else {
                 removeHoverEffects(); // Ensure hover effects are removed when interaction is blocked
            }
        }


        // --- Board & Piece Style Functions ---
        function applyBoardStyle(styleName) {
            const validStyles = ['wood', 'desert', 'stone-path', 'emerald', 'volcano', 'royal'];
            if (!validStyles.includes(styleName)) styleName = 'wood'; // Default to wood if style is invalid

            // Remove all existing board-style classes
            const allPossibleStyles = ['classic', 'modern', 'wood', 'marble', 'minimal', 'stone', 'forest', 'ice', 'dark', 'desert', 'ocean', 'stone-path', 'emerald', 'volcano', 'royal']; // List all potential board styles you might have CSS for
            boardElement.classList.remove(...allPossibleStyles.map(s => `board-style-${s}`));

            // Add the new style class
            boardElement.classList.add(`board-style-${styleName}`);
            currentBoardStyle = styleName; // Update state variable
            localStorage.setItem('boardStyle', styleName); // Save to local storage
        }

        function updateSelectedBoardOption() {
             const options = boardOptionsContainer.querySelectorAll('.board-option');
             options.forEach(option => {
                 option.classList.toggle('selected-style', option.dataset.style === currentBoardStyle);
             });
         }

        function loadBoardStyle() {
            let loadedStyle = localStorage.getItem('boardStyle') || 'wood'; // Get from storage or default
             const validStyles = ['wood', 'desert', 'stone-path', 'emerald', 'volcano', 'royal'];
             if (!validStyles.includes(loadedStyle)) { // Validate loaded style
                 loadedStyle = 'wood';
                 localStorage.setItem('boardStyle', loadedStyle); // Save default if invalid
             }
            applyBoardStyle(loadedStyle);
        }

        function applyPieceStyle(styleName) {
            const validStyles = ['classic', 'flat', 'crimson', 'azure', 'forest', 'royal'];
            if (!validStyles.includes(styleName)) styleName = 'classic'; // Default to classic

            // Remove all existing piece-style classes from the body
            const allPossibleStyles = ['classic', 'flat', 'glossy', 'wood', 'metal', 'gemstone', 'stone', 'simple', 'marble', 'neon', 'glass', 'crimson', 'azure', 'forest', 'royal']; // List all potential piece styles
            bodyElement.classList.remove(...allPossibleStyles.map(s => `piece-style-${s}`));

            // Add the new style class to the body
            bodyElement.classList.add(`piece-style-${styleName}`);
            currentPieceStyle = styleName; // Update state
            localStorage.setItem('pieceStyle', styleName); // Save to local storage

            // Update the visuals of the turn indicators as they also use the piece style class
            updateTurnIndicatorVisuals();

            // Re-render the board to apply the new style to all pieces
            if (gameContainer.style.display === 'flex') { // Only re-render if game is active
                 renderBoard();
            }
        }

        function updateSelectedPieceOption() {
             const options = pieceOptionsContainer.querySelectorAll('.piece-option');
             options.forEach(option => {
                 option.classList.toggle('selected-style', option.dataset.style === currentPieceStyle);
             });
         }

        function loadPieceStyle() {
            let loadedStyle = localStorage.getItem('pieceStyle') || 'classic'; // Get from storage or default
             const validStyles = ['classic', 'flat', 'crimson', 'azure', 'forest', 'royal'];
             if (!validStyles.includes(loadedStyle)) { // Validate loaded style
                 loadedStyle = 'classic';
                 localStorage.setItem('pieceStyle', loadedStyle); // Save default if invalid
             }
            applyPieceStyle(loadedStyle); // Apply the loaded/default style
        }


        // --- Game Logic ---

        // Handle click on a piece element
        function handlePieceClick(event) {
            const pieceElement = event.target;
            const squareElement = pieceElement.closest('.square'); // Find the parent square

            if (!squareElement) return; // Should not happen

            const row = parseInt(squareElement.dataset.row);
            const col = parseInt(squareElement.dataset.col);

            // Check if interaction is blocked (game over, AI thinking, settings open, etc.)
            const isInteractionBlocked = isGameOver || isAiThinking || isSettingsPanelVisible || boardSelectionScreen.classList.contains('visible') || pieceStyleSelectionScreen.classList.contains('visible') || confirmationModal.classList.contains('visible') || (gameMode === 'ai' && currentPlayer === AI_PLAYER);

            if (isInteractionBlocked) return; // If blocked, do nothing

            const pieceData = boardState[row][col];

            // Only allow clicking pieces of the current player
            if (!pieceData || pieceData.player !== currentPlayer) {
                 // Maybe add a sound or visual cue for clicking an invalid piece?
                 return;
            }

            // If a continuous jump is required, only allow selecting the piece that must jump again
            if (continuousJumpPossible && selectedPiece && (selectedPiece.row !== row || selectedPiece.col !== col)) {
                 // Add a visual cue here too? Like shaking the piece that *must* move?
                 return;
            }

            // Select or deselect the piece
            if (selectedPiece && selectedPiece.row === row && selectedPiece.col === col) {
                // Clicked the already selected piece -> deselect
                deselectPiece();
            } else {
                // Clicked a different piece or no piece was selected -> select this one
                selectPiece(row, col, pieceElement);
            }
        }


        // Handle click on a square element
        function handleSquareClick(event) {
            const targetSquare = event.target.closest('.square');

            // Only process clicks on dark squares
            if (!targetSquare || !targetSquare.classList.contains('dark-square')) return;

            // Check if interaction is blocked
            const isInteractionBlocked = isGameOver || isAiThinking || isSettingsPanelVisible || boardSelectionScreen.classList.contains('visible') || pieceStyleSelectionScreen.classList.contains('visible') || confirmationModal.classList.contains('visible') || (gameMode === 'ai' && currentPlayer === AI_PLAYER);

            if (isInteractionBlocked) return; // If blocked, do nothing

            const row = parseInt(targetSquare.dataset.row);
            const col = parseInt(targetSquare.dataset.col);

            // If a piece is selected and the clicked square is empty, attempt to move
            if (selectedPiece && !boardState[row][col]) {
                let move = null;

                // Find the potential move from the selected piece to the clicked square
                if (continuousJumpPossible) {
                    // If a jump is required, only consider jump moves
                    const possibleJumps = calculateMovesForPieceInternal(selectedPiece.row, selectedPiece.col, true, boardState);
                    move = possibleJumps.find(m => m.row === row && m.col === col);
                } else {
                    // Otherwise, consider all possible moves (regular moves and jumps)
                    const allMovesForSelected = calculateMovesForPieceInternal(selectedPiece.row, selectedPiece.col, false, boardState);

                    // Check if a jump is available anywhere on the board for the current player
                    const allPossibleJumps = getAllPossibleMoves(currentPlayer, true, boardState);
                    const jumpIsMandatory = allPossibleJumps.length > 0;

                    if (jumpIsMandatory) {
                        // If jumps are mandatory, only allow jump moves from the selected piece
                        move = allMovesForSelected.filter(m => m.isJump).find(m => m.row === row && m.col === col);
                    } else {
                        // If no jumps are mandatory, allow any move (regular or jump)
                         move = allMovesForSelected.find(m => m.row === row && m.col === col);
                    }
                }


                if (move) {
                    // If the move is found and valid
                    saveCurrentStateToHistory(); // Save state before the move
                    animateAndMovePiece(selectedPiece.row, selectedPiece.col, move); // Execute and animate the move
                } else {
                    // If no valid move to the clicked square, deselect the piece
                    deselectPiece();
                }
            } else {
                // If no piece is selected, or the clicked square is not empty, deselect
                // (Clicking an occupied square will be handled by handlePieceClick if it's the current player's piece)
                deselectPiece();
            }
        }


        function deselectPiece() {
            if (selectedPiece && selectedPiece.element && boardElement.contains(selectedPiece.element)) {
                selectedPiece.element.classList.remove('selected');
            }
            selectedPiece = null;
            requestRender(); // Re-render to remove possible move highlights
        }


        function selectPiece(row, col, element) {
             // Play sound only if selecting a *new* piece, not re-selecting the same one
            if (!selectedPiece || selectedPiece.row !== row || selectedPiece.col !== col) {
                 playSound('select');
            }

            deselectPiece(); // Deselect any previously selected piece
            selectedPiece = { row, col, element: element }; // Store piece info and element reference

            // Add selected class to the piece element for styling
            if (element && boardElement.contains(element)) {
                element.classList.add('selected');
            }

            requestRender(); // Re-render to show possible moves for the selected piece
        }


        // Calculate all possible moves (regular or jump) for a given piece at (r, c)
        // Returns an array of move objects {row, col, isJump, captured?, origin}
        function calculateMovesForPieceInternal(r, c, onlyJumps = false, currentBoard = boardState) {
            const piece = currentBoard[r]?.[c]; // Use optional chaining for safety
            if (!piece) return []; // No piece at this location

            let moves = [];
            const directions = []; // Directions the piece can move (1 for white, -1 for black)
            const playerDirection = (piece.player === PLAYER_BLACK) ? -1 : 1; // Black moves up, White moves down

            directions.push(playerDirection); // Add player's forward direction

            if (piece.isKing) {
                directions.push(-playerDirection); // Kings can move backwards
            }

            for (const dir of directions) {
                for (const dc of [-1, 1]) { // Check both diagonal directions (left and right)
                    const jumpedPieceRow = r + dir;
                    const jumpedPieceCol = c + dc;
                    const jumpLandingRow = r + dir * 2;
                    const jumpLandingCol = c + dc * 2;

                    // Check for possible jumps
                    if (isValidSquare(jumpLandingRow, jumpLandingCol) && !currentBoard[jumpLandingRow][jumpLandingCol]) {
                        const jumpedPiece = isValidSquare(jumpedPieceRow, jumpedPieceCol) ? currentBoard[jumpedPieceRow][jumpedPieceCol] : null;
                        // If there's an opponent piece to jump over
                        if (jumpedPiece && jumpedPiece.player !== piece.player) {
                            moves.push({
                                row: jumpLandingRow,
                                col: jumpLandingCol,
                                isJump: true,
                                captured: { row: jumpedPieceRow, col: jumpedPieceCol },
                                origin: { r, c } // Store original position for move execution
                            });
                        }
                    }

                    // Check for possible regular moves (only if not strictly looking for jumps)
                    if (!onlyJumps) {
                        const nr = r + dir;
                        const nc = c + dc;
                        if (isValidSquare(nr, nc) && !currentBoard[nr][nc]) {
                            moves.push({
                                row: nr,
                                col: nc,
                                isJump: false,
                                origin: { r, c }
                            });
                        }
                    }
                }
            }
            return moves; // Return the list of valid moves for this piece
        }


        // Get all possible moves (including jumps) for the current player
        // If onlyJumps is true, it only returns jump moves.
        // If any jump is possible on the board, only jump moves are returned (Draughts rule).
        function getAllPossibleMoves(player, onlyJumps = false, currentBoard = boardState) {
            let allMoves = [];
            let allPossibleJumps = []; // Store jumps separately to check for mandatory jumps

            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const piece = currentBoard[r][c];
                    if (piece && piece.player === player) {
                        const movesForPiece = calculateMovesForPieceInternal(r, c, false, currentBoard); // Calculate all moves first
                        const jumpsForPiece = movesForPiece.filter(m => m.isJump);

                        allMoves.push(...movesForPiece);
                        allPossibleJumps.push(...jumpsForPiece);
                    }
                }
            }

            // If 'onlyJumps' was specifically requested, return only jumps found
            if (onlyJumps) {
                return allPossibleJumps;
            }

            // Otherwise, if any jump is possible on the board, return only the jump moves
            if (allPossibleJumps.length > 0) {
                return allPossibleJumps;
            }

            // If no jumps are possible, return all regular moves
            return allMoves.filter(m => !m.isJump);
        }

        // Animate piece movement and then execute the move logic
        function animateAndMovePiece(fromRow, fromCol, move) {
             const pieceData = boardState[fromRow][fromCol];
             const movingPieceElement = getSquareElement(fromRow, fromCol)?.querySelector(`.piece[data-piece-id="${fromRow}-${fromCol}"]`);
             const targetSquareElement = getSquareElement(move.row, move.col);

             // Fallback: if elements aren't found, just execute logic
             if (!pieceData || !movingPieceElement || !targetSquareElement) {
                 console.warn("Animation elements not found, executing move logic directly.");
                 executeMoveLogic(fromRow, fromCol, move);
                 handlePostMoveChecks(move);
                 return;
             }

             // Add a class to indicate the piece is moving (disables render clearing it)
             movingPieceElement.classList.add('moving');

             // Calculate the distance to move based on square positions
             const startRect = movingPieceElement.getBoundingClientRect();
             const endRect = targetSquareElement.getBoundingClientRect();

             const offsetX = endRect.left - startRect.left;
             const offsetY = endRect.top - startRect.top;

             // Apply the transform to move the piece visually
             movingPieceElement.style.transform = `translate(calc(-50% + ${offsetX}px), calc(-50% + ${offsetY}px))`;

             // Play sounds
             if (move.isJump) {
                 playSound('capture');
                 // Animate captured piece removal slightly after move starts
                 setTimeout(() => {
                     const capturedSquare = getSquareElement(move.captured.row, move.captured.col);
                     const capturedPieceEl = capturedSquare?.querySelector('.piece');
                     if (capturedPieceEl) {
                         capturedPieceEl.classList.add('captured-fade'); // Start fade animation
                         setTimeout(() => capturedPieceEl.remove(), 400); // Remove from DOM after animation
                     }
                 }, 100); // Small delay
             } else {
                 playSound('move');
             }

             deselectPiece(); // Deselect the piece immediately after starting the move

             // After the animation duration, execute the actual board state update
             setTimeout(() => {
                 // Reset transform and remove moving class
                 movingPieceElement.classList.remove('moving');
                 movingPieceElement.style.transform = 'translate(-50%, -50%)'; // Reset to center of parent square

                 // Update the DOM structure: move the piece element to the target square
                 executeMoveLogic(fromRow, fromCol, move); // Update boardState

                 // Re-append the element to the *new* parent square
                 targetSquareElement.appendChild(movingPieceElement);
                 // Update the piece ID to reflect its new position
                 movingPieceElement.dataset.pieceId = `${move.row}-${move.col}`;

                 // Update king status visuals if necessary
                 const finalPieceData = boardState[move.row][move.col];
                 if(finalPieceData?.isKing && !movingPieceElement.classList.contains('king')) {
                     movingPieceElement.classList.add('king');
                 }

                 // Perform checks after the move is completed
                 handlePostMoveChecks(move);

             }, 300); // Match this duration to the CSS transition duration for the piece transform
        }


        // Update the boardState array and captured counts after a move
        function executeMoveLogic(fromRow, fromCol, move) {
            const pieceData = boardState[fromRow][fromCol];
            if (!pieceData) {
                console.error("No piece found at starting position", fromRow, fromCol);
                return; // Should not happen if logic is correct
            }

            const toRow = move.row;
            const toCol = move.col;

            // Move the piece data in the state array
            boardState[toRow][toCol] = pieceData;
            boardState[fromRow][fromCol] = null;

            // Handle captured piece if it was a jump
            if (move.isJump && move.captured) {
                const capR = move.captured.row;
                const capC = move.captured.col;

                // Ensure the captured position is valid and actually contains a piece
                if (isValidSquare(capR, capC) && boardState[capR][capC]) {
                    // Increment captured count for the correct player
                    if (boardState[capR][capC].player === PLAYER_WHITE) {
                        capturedByWhite++;
                    } else {
                        capturedByBlack++;
                    }
                    boardState[capR][capC] = null; // Remove captured piece from state
                    updateCapturedCounters(); // Update the UI display
                }
            }

            // Check if the piece became a king after the move
            checkForKing(toRow, toCol);
        }

        // Handle checks and state updates after a move animation completes
        function handlePostMoveChecks(move) {
            const toRow = move.row;
            const toCol = move.col;
            const movedPieceData = boardState[toRow][toCol];

            // If the last move was a jump, check for mandatory next jumps from the landing square
            if (move.isJump && movedPieceData) {
                const nextJumps = calculateMovesForPieceInternal(toRow, toCol, true, boardState);

                if (nextJumps.length > 0) {
                    // Mandatory continuous jump is possible
                    continuousJumpPossible = true;
                    selectPiece(toRow, toCol, getSquareElement(toRow, toCol)?.querySelector('.piece')); // Auto-select the piece for the next jump
                    updateStatus("Complete the jump!"); // Update status bar

                    requestRender(); // Re-render to highlight next jump options

                     // If it's AI's turn and a multi-jump is possible, continue AI turn
                    if (gameMode === 'ai' && currentPlayer === AI_PLAYER && !isGameOver) {
                         isAiThinking = true; // Keep AI thinking state active
                         renderBoard(); // Update board to reflect AI thinking status
                         // Small delay before AI makes the next jump
                         setTimeout(makeAiMove, 1000 + Math.random() * 50);
                     }

                    return; // Stay on the same player's turn
                }
            }

            // If no mandatory continuous jump (or if the move wasn't a jump)
            continuousJumpPossible = false; // Reset flag
            endTurn(); // Proceed to end the turn
        }


        // Check if a piece should become a king
        function checkForKing(row, col) {
            const piece = boardState[row]?.[col];
            // If there's no piece, or it's already a king, do nothing
            if (!piece || piece.isKing) return false;

            // Check if black piece reached the first row (row 0)
            if (piece.player === PLAYER_BLACK && row === 0) {
                piece.isKing = true;
                playSound('king'); // Play king sound
                return true;
            }
            // Check if white piece reached the last row (row 7)
            if (piece.player === PLAYER_WHITE && row === BOARD_SIZE - 1) {
                piece.isKing = true;
                playSound('king'); // Play king sound
                return true;
            }
            return false; // Piece did not become a king
        }

        // End the current turn and switch player
        function endTurn() {
            deselectPiece(); // Deselect any piece
            clearHintHighlights(); // Clear any active hint

            // Check for win condition *before* switching players
            if (checkWinCondition()) {
                 return; // Game over, don't switch player
            }

            switchPlayer(); // Switch to the next player
        }

        // Switch the current player
        function switchPlayer() {
            currentPlayer = getOpponent(currentPlayer); // Toggle player
            continuousJumpPossible = false; // Reset continuous jump flag for the new turn

            updateStatus(); // Update status bar and turn indicator
            startTurnTimer(); // Start the timer for the new player

            // If it's the AI's turn and the game is not over
            if (gameMode === 'ai' && currentPlayer === AI_PLAYER && !isGameOver) {
                isAiThinking = true; // Set AI thinking state
                updateUndoButton(); // Disable undo button while AI thinks
                updateHintButton(); // Disable hint button while AI thinks
                renderBoard(); // Update board visuals (e.g., disable clicks)

                // Use requestAnimationFrame + setTimeout to allow UI updates before AI starts calculation
                requestAnimationFrame(() => {
                    // Small delay to make AI feel less instantaneous
                     setTimeout(makeAiMove, 1000 + Math.random() * 50); // Add a little randomness to AI delay
                });
            } else {
                isAiThinking = false; // Ensure AI thinking state is off for human player
                updateUndoButton(); // Update undo button state for human player
                updateHintButton(); // Update hint button state for human player
            }
        }

        // Update status bar text and turn indicator highlighting
        function updateStatus(message = null) {
            // Remove active class from both indicators
            whiteIndicator.classList.remove('active-turn');
            blackIndicator.classList.remove('active-turn');

            if (!isGameOver) {
                 // Add active class to the current player's indicator
                 if (currentPlayer === PLAYER_WHITE) {
                     whiteIndicator.classList.add('active-turn');
                 } else {
                     blackIndicator.classList.add('active-turn');
                 }
             }
            // Optionally update text status here if needed
            // For now, turn is indicated visually and messages are only for game end
             if(message) console.log("Status Update:", message); // Log messages for debugging
        }


        // Check if the game has ended (no pieces left or no valid moves)
        function checkWinCondition() {
            if (isGameOver) return true; // Already game over

            let blackPieces = 0;
            let whitePieces = 0;
            let blackCanMove = false;
            let whiteCanMove = false;

            // Calculate all possible moves for both players
            const blackMoves = getAllPossibleMoves(PLAYER_BLACK, false, boardState);
            const whiteMoves = getAllPossibleMoves(PLAYER_WHITE, false, boardState);

            // Check if players have any moves
            blackCanMove = blackMoves.length > 0;
            whiteCanMove = whiteMoves.length > 0;

            // Count remaining pieces
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (boardState[r][c]?.player === PLAYER_BLACK) {
                        blackPieces++;
                    }
                    if (boardState[r][c]?.player === PLAYER_WHITE) {
                        whitePieces++;
                    }
                }
            }

            let gameOverTriggered = false;
            let winMessage = "";

            // Win condition 1: Opponent has no pieces left
            if (whitePieces === 0) {
                winMessage = "Black Wins (No White pieces left)!";
                gameOverTriggered = true;
            } else if (blackPieces === 0) {
                winMessage = "White Wins (No Black pieces left)!";
                gameOverTriggered = true;
            }
            // Win condition 2: Current player has no valid moves
             else if (currentPlayer === PLAYER_BLACK && !blackCanMove) {
                winMessage = "White Wins (Black has no moves)!";
                gameOverTriggered = true;
            } else if (currentPlayer === PLAYER_WHITE && !whiteCanMove) {
                winMessage = "Black Wins (White has no moves)!";
                gameOverTriggered = true;
            }
            // Note: Stalemate (no moves for either player) results in a draw in some variants,
            // but here it's treated as a win for the player whose turn it ISN'T if the current player has no moves.

            // If any win condition was met, end the game
            if (gameOverTriggered) {
                endGame(winMessage);
                return true; // Game is over
            }

            return false; // Game is not over
        }

        // Save the current state of the game to history for undo
        function saveCurrentStateToHistory() {
            const stateToSave = {
                boardState: deepCopyBoard(boardState), // Save a deep copy of the board
                currentPlayer: currentPlayer,
                capturedByBlack: capturedByBlack,
                capturedByWhite: capturedByWhite,
                continuousJumpPossible: continuousJumpPossible,
                // Note: selectedPiece and possibleMoves are transient UI state, not saved
            };
            moveHistory.push(stateToSave);
            updateUndoButton(); // Update button state after saving
        }

        // Undo the last move
        function undoMove() {
             // Cannot undo if history is empty or AI is thinking
             if (moveHistory.length === 0 || isAiThinking) return;

             stopTurnTimer(); // Stop the timer before undoing

             // For AI mode, undoing once means undoing the human's last move
             // We need to undo one more time to get back to the state before AI moved
             if (gameMode === 'ai' && moveHistory.length > 0) {
                 moveHistory.pop(); // Undo human's move
                 if (moveHistory.length > 0) { // If there's a state before AI's move
                     moveHistory.pop(); // Undo AI's move
                 } else {
                     // If undoing the human move resulted in empty history, go back to initial state
                     returnToStartScreen(); // This clears everything and goes to start
                     return;
                 }
             }

            const previousState = moveHistory.pop(); // Get the previous state from history

            // Restore game state from history
            boardState = previousState.boardState;
            currentPlayer = previousState.currentPlayer;
            capturedByBlack = previousState.capturedByBlack;
            capturedByWhite = previousState.capturedByWhite;
            continuousJumpPossible = previousState.continuousJumpPossible;

            selectedPiece = null; // Clear any selected piece after undo
            isGameOver = false; // Ensure game over state is reset if undoing a game-ending move
            gameOverScreen.classList.remove('visible'); // Hide game over screen

            // Update UI elements
            updateCapturedCounters();
            updateStatus(); // Update turn indicator
            updateUndoButton(); // Update button state
            updateHintButton(); // Update hint button state

            // Re-create and re-render the board based on the restored state
            // Creating the UI again is simpler than trying to move/remove DOM elements
            createBoardUI();
            renderBoard();

            startTurnTimer(); // Restart the timer for the restored player's turn

            // If it's now AI's turn again after undo (only possible if human was Black and undid)
             if (gameMode === 'ai' && currentPlayer === AI_PLAYER && !isGameOver) {
                 isAiThinking = true;
                  requestAnimationFrame(() => { setTimeout(makeAiMove, 500); });
             } else {
                  isAiThinking = false; // Ensure AI is not thinking if it's human's turn
             }
        }

        function clearHintHighlights() {
             if (hintTimeoutId) {
                 clearTimeout(hintTimeoutId);
                 hintTimeoutId = null;
             }
             // Remove hint classes from all potential elements
             document.querySelectorAll('.hint-piece-suggestion, .hint-move-suggestion').forEach(el => {
                 el.classList.remove('hint-piece-suggestion', 'hint-move-suggestion');
             });
             // Ensure possible-move class added by hint is also removed if it wasn't already
             document.querySelectorAll('.square.possible-move.hint-move-suggestion').forEach(sq => {
                 sq.classList.remove('hint-move-suggestion'); // Only remove the hint-specific part
             });
         }

         function showHint() {
             clearHintHighlights(); // Clear any previous hint

             // Don't show hint if game is over, AI is thinking, or it's AI's turn
             if (isGameOver || isAiThinking || (gameMode === 'ai' && currentPlayer === AI_PLAYER)) {
                 return;
             }

             let bestHintMove;

             // For AI mode or Medium/Hard difficulty, use Minimax to find the best move
             if (gameMode === 'ai' || aiDifficulty !== DIFFICULTIES.EASY) {
                 // Minimax searches from the current board state for the current player
                 bestHintMove = findBestMoveMinimax(currentPlayer, aiDifficulty === DIFFICULTIES.HARD ? MINIMAX_DEPTH.HARD : MINIMAX_DEPTH.MEDIUM).move;
             } else {
                 // For Easy difficulty (or human vs human), provide a random hint
                 // Prioritize jumps if mandatory
                 const allPossibleJumps = getAllPossibleMoves(currentPlayer, true, boardState);
                 if (allPossibleJumps.length > 0) {
                     // Hint a random jump
                     bestHintMove = allPossibleJumps[Math.floor(Math.random() * allPossibleJumps.length)];
                 } else {
                     // If no jumps, hint a random regular move
                     const regularMoves = getAllPossibleMoves(currentPlayer, false, boardState); // This already excludes non-mandatory jumps
                     if (regularMoves.length > 0) {
                          bestHintMove = regularMoves[Math.floor(Math.random() * regularMoves.length)];
                     }
                 }
             }


             if (bestHintMove) {
                 // Highlight the piece and the destination square
                 const pieceSquare = getSquareElement(bestHintMove.origin.r, bestHintMove.origin.c);
                 const targetSquare = getSquareElement(bestHintMove.row, bestHintMove.col);

                 const pieceElement = pieceSquare?.querySelector('.piece');

                 if (pieceElement && targetSquare) {
                     pieceElement.classList.add('hint-piece-suggestion');
                     targetSquare.classList.add('hint-move-suggestion');
                     // Also ensure the target square is marked as a possible move visually
                      targetSquare.classList.add('possible-move'); // Add possible-move class if not already there

                     // Clear the hint highlights after a few seconds
                     hintTimeoutId = setTimeout(clearHintHighlights, 2500); // Highlight for 2.5 seconds
                 }
             } else {
                 console.log("No hint available (no moves for the current player).");
                 // Could potentially provide a "No moves" message to the user
             }
         }


        // --- AI Logic ---

        // AI makes a move
        function makeAiMove() {
            // Ensure it's AI's turn and game is not over
            if (isGameOver || currentPlayer !== AI_PLAYER) {
                isAiThinking = false; // Ensure AI thinking state is off
                requestRender(); // Re-render to update UI (e.g., re-enable buttons)
                return;
            }

            let bestMoveResult;

            // If a continuous jump is required, AI must choose from the available jumps for the selected piece
            if (continuousJumpPossible && selectedPiece && selectedPiece.player === AI_PLAYER) {
                const nextJumps = calculateMovesForPieceInternal(selectedPiece.row, selectedPiece.col, true, boardState);
                if (nextJumps.length > 0) {
                    // For simplicity, AI just takes the first available jump in a multi-jump sequence
                    // A more complex AI could evaluate which multi-jump sequence is best
                     bestMoveResult = { move: nextJumps[0], score: 0 }; // Score doesn't matter for multi-jump follow-up
                } else {
                     // This case should theoretically not be reached if continuousJumpPossible is true and the piece can jump,
                     // but as a fallback, find the best move from all available moves.
                     console.warn("AI expected continuous jump but found none. Searching all moves.");
                     continuousJumpPossible = false; // Reset flag as no jumps were found
                     bestMoveResult = findBestMoveForAI(); // Find the best move (which might be a regular move if jumps weren't mandatory initially)
                }
            } else {
                // If no continuous jump is required, find the overall best move for the AI
                bestMoveResult = findBestMoveForAI();
            }

            // If a move was found
            if (bestMoveResult && bestMoveResult.move) {
                const chosenMove = bestMoveResult.move;

                saveCurrentStateToHistory(); // Save state before AI move

                // Animate and execute the chosen move
                const aiPieceSquare = getSquareElement(chosenMove.origin.r, chosenMove.origin.c);
                const aiPieceElement = aiPieceSquare?.querySelector('.piece');

                 // Select the piece programmatically for visual feedback and animation function
                selectedPiece = { row: chosenMove.origin.r, col: chosenMove.origin.c, player: AI_PLAYER, element: aiPieceElement };


                animateAndMovePiece(chosenMove.origin.r, chosenMove.origin.c, chosenMove);

                // handlePostMoveChecks is called inside animateAndMovePiece's setTimeout
            } else {
                // If no move was found (shouldn't happen if game state is valid and not over)
                console.warn("AI could not find a move. Ending turn.");
                isAiThinking = false; // Ensure AI thinking state is off
                endTurn(); // End turn (which will check for game over if needed)
            }
        }

        // Find the best move for the AI player using Minimax (for Medium/Hard) or random (for Easy)
        function findBestMoveForAI() {
            if (aiDifficulty === DIFFICULTIES.EASY) {
                // Easy AI: Choose a random move. Prioritize jumps if mandatory.
                const allPossibleJumps = getAllPossibleMoves(AI_PLAYER, true, boardState);
                let possibleAiMoves;

                if (allPossibleJumps.length > 0) {
                    // If jumps are possible, AI must jump (easy or not)
                    possibleAiMoves = allPossibleJumps;
                } else {
                    // If no jumps, AI can make any regular move
                    possibleAiMoves = getAllPossibleMoves(AI_PLAYER, false, boardState); // This returns regular moves if no jumps exist
                }

                if (possibleAiMoves.length === 0) {
                    // No moves available
                    return null;
                }

                // Pick a random move from the possible moves
                const randomMove = possibleAiMoves[Math.floor(Math.random() * possibleAiMoves.length)];
                return { move: randomMove, score: 0 }; // Score doesn't matter for random
            } else {
                // Medium or Hard AI: Use Minimax search
                const depth = (aiDifficulty === DIFFICULTIES.HARD) ? MINIMAX_DEPTH.HARD : MINIMAX_DEPTH.MEDIUM;
                return findBestMoveMinimax(AI_PLAYER, depth);
            }
        }


        // Minimax algorithm implementation
        // Returns { move: bestMove, score: bestScore }
        function findBestMoveMinimax(player, depth) {
            let bestScore = -Infinity;
            let bestMove = null;

            // Get all possible moves for the current player (respecting mandatory jumps)
            const possibleMoves = getAllPossibleMoves(player, false, boardState);

            // If no moves are possible, evaluate the current board state immediately
            if (possibleMoves.length === 0) {
                 return { move: null, score: evaluateBoard(boardState, player, depth) };
            }

            // Iterate through all possible moves to find the one yielding the best score
            for (const move of possibleMoves) {
                // Simulate the move on a temporary copy of the board
                const tempBoard = deepCopyBoard(boardState);
                simulateMove(tempBoard, move);

                 let finalBoardState = tempBoard; // The board state after the initial move

                 // Handle potential subsequent mandatory jumps for the same player
                 if (move.isJump) {
                     const nextJumps = calculateMovesForPieceInternal(move.row, move.col, true, tempBoard);

                     // If there are more jumps from the landing square,
                     // the minimax search needs to continue from this state for the *same* player
                     if (nextJumps.length > 0) {
                          // Evaluate this jump as the first part of a multi-jump sequence
                          // Recursively call minimax assuming the same player continues, but don't decrease depth for the follow-up jumps
                          // A true multi-jump minimax would need to explore all sequences, which is more complex.
                          // For simplicity here, we assume the AI will take *a* mandatory jump if available and evaluate the resulting state.
                          // A better approach would be to implement iterative deepening or explore multi-jumps fully within the move generation.
                          // For this simplified minimax, we evaluate the state after *this* jump, but we need to continue from here for the same player.
                          // This requires a modification to the standard minimax structure to handle the "same player turn" case.

                          // A more accurate (but more complex) way would be:
                          // if (nextJumps.length > 0) {
                          //    // Need to find the *best sequence* of jumps starting from this move
                          //    // This would involve a separate search specifically for jump sequences
                          //    let bestSequenceScore = -Infinity; // Or handle it within the minimax recursion
                          //    // For now, let's use a simpler approach: just evaluate the state *after* the first jump
                          //    // and assume the best outcome from the remaining jumps for this player.
                          //    // This is an approximation for multi-jumps within the minimax.
                          //    // Let's just recursively call minimax from the new state for the *same* player, but maybe with slightly reduced depth?
                          //    // Or just assume the player will take *a* jump and evaluate the resulting state.
                          //    // Let's stick to the simpler model: evaluate after THIS move, but recognize player doesn't switch.
                          //    // The standard minimax below assumes player always switches.
                          //    // To handle multi-jump turns, we need to adapt the minimax recursive step.

                           // Let's adjust the minimax recursive call: if a jump happened and more jumps are possible,
                           // the recursive call should be for the *same* player (`currentPlayerMM`),
                           // and possibly with the same depth or a slightly reduced one specific to the jump sequence.
                           // This requires modifying the minimax function's parameters. Let's pass `currentPlayerMM` and `originalPlayer`.

                            // Recursive call for the *same* player (as turn doesn't end) with the same depth (evaluating the jump sequence)
                            // The score here represents the value *if* the AI takes this initial jump and plays optimally from there
                            // This is still an approximation without a full jump sequence search.
                             const score = minimax(finalBoardState, depth, alpha, beta, isMaximizingPlayer, currentPlayerMM, originalPlayer); // Still maximizing/minimizing for the original player's turn outcome

                              if (isMaximizingPlayer) {
                                 if (score > bestScore) {
                                     bestScore = score;
                                     bestMove = move; // Keep this initial move as the start of the best sequence
                                 }
                                 alpha = Math.max(alpha, bestScore);
                              } else { // isMinimizingPlayer (opponent)
                                 if (score < bestScore) { // Should be minEval vs minEval
                                      // This branch seems wrong in the original minimax structure if multi-jump is handled this way.
                                      // Minimax always alternates players.
                                      // A common simplification: just evaluate the board state after the FIRST jump,
                                      // assuming the AI will take *some* sequence of jumps.
                                      // Or, evaluate after the first jump and then call minimax for the OPPONENT,
                                      // slightly overestimating the value of the multi-jump.
                                      // Let's try the simpler approach for now: evaluate after the first jump as if the turn *might* end,
                                      // but recognize the player doesn't switch in the recursive call.

                                      // Let's rethink the recursive step for jumps.
                                      // If a jump occurs and more jumps are possible:
                                      // The state changes (piece moved, captured piece removed).
                                      // The *same* player continues the turn from the new position.
                                      // The minimax evaluation needs to continue from this new state for the *same* player.

                                      // Corrected recursive call for a jump where more jumps are possible:
                                      // minimax(newState, depth, alpha, beta, isMaximizingPlayer, SAME_PLAYER, originalPlayer)
                                      // This is different from the standard minimax structure where player always flips.

                                      // Let's use the standard Minimax structure and add a check *within* the minimax function
                                      // after a simulated move to see if more jumps are possible for the same player.
                                      // This is cleaner than trying to handle it externally.

                                      // Abandoning the external multi-jump handling here and will integrate it into the minimax function below.

                                      // For now, just simulate the first jump and evaluate as if the turn ended
                                      // (This is a common simplification but not perfectly accurate for checkers)
                                      // Let's remove the 'continue' and let the standard minimax evaluate after 1 jump.
                                      // The 'handlePostMoveChecks' takes care of actual game logic multi-jumps.
                                 }
                                 beta = Math.min(beta, score); // Should be minEval vs minEval
                              }
                              // If it was a jump and more jumps were possible, we *shouldn't* break the loop here based on standard alpha-beta pruning,
                              // because the score from this move represents the value of the *entire sequence* starting from this move.
                              // We must explore all possible *first* moves (including jumps) to find the best *start* to a turn.
                              // The minimax function itself will handle the depth/player switching logic correctly,
                              // but it needs to be aware that a jump might lead to another turn for the same player.

                              // Let's stick to the simpler evaluation after the first jump for now within the loop,
                              // and refine the minimax function below to handle the turn continuation logic.
                              // The score calculation should then be the result of the minimax call from the state after the move.
                     }
                 }

                // Standard recursive call: evaluate the state after the move by calling minimax for the opponent
                const score = minimax(finalBoardState, depth - 1, alpha, beta, !isMaximizingPlayer, getOpponent(currentPlayerMM), originalPlayer);


                // Update best score and move
                if (isMaximizingPlayer) {
                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = move;
                    }
                    alpha = Math.max(alpha, score); // Alpha-beta pruning
                } else { // isMinimizingPlayer
                    if (score < bestScore) { // Error: this should be minEval, not bestScore comparison
                         // This 'else' block is incorrect for finding the BEST move (which is done outside this function).
                         // Minimax function *returns* the evaluated score. The calling function (findBestMoveMinimax)
                         // uses this score to find the move that maximizes/minimizes based on the player whose turn it is.

                         // Let's correct the minimax logic within the minimax function itself below.
                         // The logic here in findBestMoveMinimax is correct for updating bestMove/bestScore.
                         // It compares the scores returned by the minimax function.

                         // Correction: The line `if (score < bestScore)` was likely leftover from old logic.
                         // The findBestMoveMinimax function is finding the move that maximizes the score for the `player` it was called with.
                         // So the `else` block for minimizing player is not needed *here*.
                         // The score returned by minimax is the evaluation from the `originalPlayer`'s perspective.
                         // We want to find the move that maximizes this score for the `player` (which is the originalPlayer).
                         // The logic inside the loop should only be for the maximizing player's perspective
                         // to find the best move, using the score returned by the recursive call.
                         // The minimax function itself alternates between maximizing (original player) and minimizing (opponent).

                         // Let's simplify this loop assuming the minimax function returns the score from the `originalPlayer`'s perspective.
                         // We are finding the move that maximizes this score for `player` (who is `originalPlayer`).

                         // Revert to simpler update logic based on maximizing player
                         // The `isMaximizingPlayer` flag passed to the first minimax call *from here* should be true.
                         // The minimax function itself will handle the alternating `isMaximizingPlayer` for recursion.

                         // Let's assume the first call to minimax from findBestMoveMinimax is always `minimax(..., true, ..., player, player)`

                          // The loop logic for updating bestScore/bestMove seems correct for a maximizing player (which is `player`).
                          // The `else` block inside the loop for minimizing player is logically wrong in this context.
                          // We are always trying to maximize the final outcome for the player whose turn it is now.

                          // The original code had:
                          // if (score > bestScore) { bestScore = score; bestMove = move; }
                          // alpha = Math.max(alpha, score); if (beta <= alpha) break;
                          // This is correct for a maximizing player. The loop is finding the move that maximizes the result.

                          // The minimax function recursive call needs to be correct.
                     }
                     beta = Math.min(beta, score); // Alpha-beta pruning (for minimizing player's branch evaluation, happens inside minimax)
                }

                // Alpha-beta pruning check *outside* the maximizing/minimizing update
                 if (beta <= alpha) break; // Prune this branch
            }

            // Fallback: If no moves found (should be handled before the loop) or if no move was selected by the score (unlikely),
            // return the first move as a default.
            if (!bestMove && possibleMoves.length > 0) {
                bestMove = possibleMoves[0]; // Just take the first legal move as a fallback
                 // console.warn("Minimax found no best move, returning first legal move.");
            }


            return { move: bestMove, score: bestScore }; // Return the best move found and its score
        }


        // The Minimax recursive function
        // currentBoard: the board state for this node
        // depth: remaining search depth
        // alpha: alpha value for pruning
        // beta: beta value for pruning
        // isMaximizingPlayer: true if the current player is the maximizing player (AI), false otherwise
        // currentPlayerMM: the player whose turn is being evaluated at *this* recursive level
        // originalPlayer: the player who called the initial minimax search (the AI player)
        function minimax(currentBoard, depth, alpha, beta, isMaximizingPlayer, currentPlayerMM, originalPlayer) {

            // Base Case:
            // 1. Depth is zero
            // 2. Game is over in this simulated state
            if (depth === 0 || checkGameOverSimulated(currentBoard, currentPlayerMM)) {
                 // Evaluate the board state from the *original player's* perspective
                 return evaluateBoard(currentBoard, originalPlayer, depth);
            }

            // Get all possible moves for the player whose turn it is in this simulated state
            const possibleMoves = getAllPossibleMoves(currentPlayerMM, false, currentBoard);

             // If no moves are possible for the current player in this simulated state, it's a game over state
             // Evaluate this state immediately
             if (possibleMoves.length === 0) {
                 return evaluateBoard(currentBoard, originalPlayer, depth);
             }


            if (isMaximizingPlayer) { // Maximize for the AI player (originalPlayer if isMaximizingPlayer true initially)
                let maxEval = -Infinity;
                for (const move of possibleMoves) {
                    // Simulate the move
                    const tempBoard = deepCopyBoard(currentBoard);
                    simulateMove(tempBoard, move);

                    let evalScore;

                    // Check for mandatory subsequent jumps for the same player
                    const nextJumps = calculateMovesForPieceInternal(move.row, move.col, true, tempBoard);
                    if (move.isJump && nextJumps.length > 0) {
                         // If more jumps are possible, the turn continues for currentPlayerMM.
                         // Recursively call minimax for the *same* player (currentPlayerMM), *same* maximizing state, but reduce depth.
                         // This treats the jump sequence as part of the same turn's evaluation.
                         evalScore = minimax(tempBoard, depth, alpha, beta, isMaximizingPlayer, currentPlayerMM, originalPlayer); // Pass depth, not depth - 1
                    } else {
                        // If no more jumps, the turn ends.
                        // Recursively call minimax for the *opponent* (getOpponent(currentPlayerMM)), with the opposite maximizing state, and reduced depth.
                         evalScore = minimax(tempBoard, depth - 1, alpha, beta, !isMaximizingPlayer, getOpponent(currentPlayerMM), originalPlayer);
                    }


                    maxEval = Math.max(maxEval, evalScore);
                    alpha = Math.max(alpha, evalScore); // Update alpha

                    if (beta <= alpha) {
                        // Beta cut-off: The minimizing player can already force a better (lower) score
                        // in a different branch, so this branch is irrelevant.
                        break;
                    }
                }
                return maxEval; // Return the best score found in this branch
            } else { // Minimize for the Opponent player (originalPlayer's opponent)
                let minEval = Infinity;
                for (const move of possibleMoves) {
                    // Simulate the move
                    const tempBoard = deepCopyBoard(currentBoard);
                    simulateMove(tempBoard, move);

                     let evalScore;

                     // Check for mandatory subsequent jumps for the same player (the minimizing player here)
                     const nextJumps = calculateMovesForPieceInternal(move.row, move.col, true, tempBoard);
                     if (move.isJump && nextJumps.length > 0) {
                          // Turn continues for currentPlayerMM (the minimizing player)
                          // Recursively call minimax for the *same* player, *same* minimizing state, but same depth.
                          evalScore = minimax(tempBoard, depth, alpha, beta, isMaximizingPlayer, currentPlayerMM, originalPlayer); // Pass depth, not depth - 1
                     } else {
                         // Turn ends. Recursively call minimax for the *opponent* (which is originalPlayer),
                         // with the opposite maximizing state (true), and reduced depth.
                          evalScore = minimax(tempBoard, depth - 1, alpha, beta, !isMaximizingPlayer, getOpponent(currentPlayerMM), originalPlayer);
                     }


                    minEval = Math.min(minEval, evalScore);
                    beta = Math.min(beta, evalScore); // Update beta

                    if (beta <= alpha) {
                        // Alpha cut-off: The maximizing player can already force a worse (higher) score
                        // in a different branch, so this branch is irrelevant.
                        break;
                    }
                }
                return minEval; // Return the worst score (from AI's perspective) found in this branch
            }
        }


        // Evaluate the current board state from the perspective of the originalPlayer
        // A higher score is better for originalPlayer.
        function evaluateBoard(currentBoard, originalPlayer, depth = 0) {
            let score = 0;
            const opponent = getOpponent(originalPlayer);

            // Constants for scoring
            const WIN_SCORE = 1000; // Score for winning - needs to be higher than any piece value combo
            const KING_VALUE = 3;   // Kings are more valuable
            const PIECE_VALUE = 1;  // Regular pieces value
            const ADVANCEMENT_VALUE = 0.1; // Value for pieces moving towards king row

            let myPieces = 0, oppPieces = 0;
            let myKings = 0, oppKings = 0;
            let myMoves = 0, oppMoves = 0; // Number of possible moves
             let oppCanMove = false, myCanMove = false; // Whether player *has* any moves

            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const piece = currentBoard[r][c];
                    if (piece) {
                         // Calculate moves for this piece for mobility score
                         const pieceMoves = calculateMovesForPieceInternal(r,c,false, currentBoard).length;

                        if (piece.player === originalPlayer) {
                            myPieces++;
                            if (pieceMoves > 0) myCanMove = true;
                            myMoves += pieceMoves; // Add piece's moves to total
                            score += PIECE_VALUE; // Add base value for the piece

                            if (piece.isKing) {
                                myKings++;
                                score += KING_VALUE - PIECE_VALUE; // Add extra value for king
                            } else {
                                // Add value for advancement towards opponent's king row
                                // Black advances by decreasing row index, White by increasing
                                score += (originalPlayer === PLAYER_WHITE ? r : (BOARD_SIZE - 1 - r)) * ADVANCEMENT_VALUE;
                            }
                        } else { // Opponent's piece
                            oppPieces++;
                             if (pieceMoves > 0) oppCanMove = true;
                             oppMoves += pieceMoves; // Add piece's moves to total
                            score -= PIECE_VALUE; // Subtract base value for opponent's piece

                            if (piece.isKing) {
                                oppKings++;
                                score -= KING_VALUE - PIECE_VALUE; // Subtract extra value for opponent's king
                            } else {
                                // Subtract value for opponent's advancement
                                score -= (opponent === PLAYER_WHITE ? r : (BOARD_SIZE - 1 - r)) * ADVANCEMENT_VALUE;
                            }
                        }
                    }
                }
            }

            // Check for simulated game over scenarios
            // If opponent has no pieces or no moves, it's a win for originalPlayer
             // Passing the remaining depth adds value to quicker wins found earlier in the search tree
             let currentDepthPassed = depth; // Use remaining depth

            if (oppPieces === 0 || !oppCanMove) {
                return WIN_SCORE + currentDepthPassed;
            }
            // If originalPlayer has no pieces or no moves, it's a win for opponent
            if (myPieces === 0 || !myCanMove) {
                return -WIN_SCORE - currentDepthPassed; // Negative score for opponent win
            }

             // Mobility score: Value having more moves than the opponent
             // score += (myMoves - oppMoves) * 0.05; // Small value for mobility

            // Piece difference + King difference
            score += (myKings * KING_VALUE + (myPieces - myKings) * PIECE_VALUE); // Value of originalPlayer's pieces/kings
            score -= (oppKings * KING_VALUE + (oppPieces - oppKings) * PIECE_VALUE); // Value of opponent's pieces/kings

             // Add a small random element to break ties and make AI less predictable on easy difficulties
             // if (originalPlayer === AI_PLAYER && aiDifficulty === DIFFICULTIES.EASY) {
             //     score += Math.random() * 0.1; // Small random offset
             // }


            return score; // Return the calculated score
        }


        // Simulate a move on a board state array (does not modify DOM)
        function simulateMove(board, move) {
            const pieceData = board[move.origin.r][move.origin.c];
            if (!pieceData) return; // Should not happen in valid move simulation

            // Move the piece
            board[move.row][move.col] = pieceData;
            board[move.origin.r][move.origin.c] = null;

            // Remove captured piece if it's a jump
            if (move.isJump && move.captured) {
                // Don't update captured counts in simulation, just remove from board
                board[move.captured.row][move.captured.col] = null;
            }

            // Check for king promotion in simulation
            if (!pieceData.isKing) { // Only check if not already a king
                 if ((pieceData.player === PLAYER_BLACK && move.row === 0) || (pieceData.player === PLAYER_WHITE && move.row === BOARD_SIZE - 1)) {
                     pieceData.isKing = true;
                 }
            }
             // Note: No multi-jump logic is handled *within* simulateMove.
             // The minimax function decides if the turn continues based on the state *after* simulateMove.
        }

        // Check if the game is over in a simulated board state for a given player
        // Used within the minimax evaluation.
        function checkGameOverSimulated(board, playerToCheck) {
            let pieces = 0;
            let canMove = false;

            // Count pieces and check if the player has any moves
            for(let r=0; r<BOARD_SIZE; r++){
                for(let c=0; c<BOARD_SIZE; c++){
                    if(board[r][c]?.player === playerToCheck){
                        pieces++;
                        // If we find at least one piece with a move, the player can move
                        if(!canMove && calculateMovesForPieceInternal(r, c, false, board).length > 0){
                            canMove = true;
                            // Optimization: If we found a piece and it can move, we don't need to check other pieces for mobility
                            // continue; // We still need to count total pieces though, so no continue here.
                        }
                    }
                }
            }

            // Game is over for this player if they have no pieces left OR no possible moves
            return pieces === 0 || !canMove;
        }

        // --- Drag and Drop Logic (Conceptual - Needs Full Implementation) ---
        // (The provided code does not include full drag-and-drop JS logic,
        // but the CSS classes like .dragging and the structure are ready for it)
        // The current implementation relies on click-to-select and click-to-move.

        // Example placeholder for drag start (would be added to piece element)
        /*
        function handleDragStart(event) {
             const pieceElement = event.target;
             const squareElement = pieceElement.closest('.square');
             const r = parseInt(squareElement.dataset.row);
             const c = parseInt(squareElement.dataset.col);

             // Ensure it's a valid piece to drag
             if (!pieceElement.classList.contains('interactive')) {
                 event.preventDefault(); // Prevent drag if not interactive
                 return;
             }

             selectedPiece = { row: r, col: c, element: pieceElement };
             pieceElement.classList.add('dragging');
             // event.dataTransfer.setData('text/plain', `${r},${c}`); // Set data for drop

             // Add ghost image (optional)
             // event.dataTransfer.setDragImage(pieceElement, pieceElement.offsetWidth / 2, pieceElement.offsetHeight / 2);

             requestRender(); // Highlight possible drop targets
         }

         // Example placeholder for drag over (would be added to square element)
         function handleDragOver(event) {
             event.preventDefault(); // Necessary to allow dropping
             const targetSquare = event.target.closest('.square');
             if (!targetSquare) return;

             const row = parseInt(targetSquare.dataset.row);
             const col = parseInt(targetSquare.dataset.col);

             // Check if this square is a valid drop target (i.e., a possible move)
             if (targetSquare.classList.contains('possible-move')) {
                 // Optional: Add a visual cue to the target square during drag over
                 // targetSquare.classList.add('drag-over-target');
             }
         }

         // Example placeholder for drag leave
          function handleDragLeave(event) {
             const targetSquare = event.target.closest('.square');
             if (targetSquare) {
                  // Optional: Remove visual cue
                 // targetSquare.classList.remove('drag-over-target');
             }
          }

         // Example placeholder for drop (would be added to square element)
         function handleDrop(event) {
             event.preventDefault();
             const targetSquare = event.target.closest('.square');
             if (!targetSquare) return;

             const toRow = parseInt(targetSquare.dataset.row);
             const toCol = parseInt(targetSquare.dataset.col);

              // Remove any drag over visual cue
             // targetSquare.classList.remove('drag-over-target');

             // Get the original piece position from dataTransfer (or from selectedPiece)
             // const [fromRow, fromCol] = event.dataTransfer.getData('text/plain').split(',').map(Number);
             const fromRow = selectedPiece.row;
             const fromCol = selectedPiece.col;

             // Find the corresponding move from the possible moves for the selected piece
             let move = null;
             if (continuousJumpPossible) {
                  const possibleJumps = calculateMovesForPieceInternal(fromRow, fromCol, true, boardState);
                  move = possibleJumps.find(m => m.row === toRow && m.col === toCol);
             } else {
                  const allMoves = calculateMovesForPieceInternal(fromRow, fromCol, false, boardState);
                   const jumpIsMandatory = getAllPossibleMoves(currentPlayer, true, boardState).length > 0;

                   if(jumpIsMandatory) {
                        move = allMoves.filter(m => m.isJump).find(m => m.row === toRow && m.col === toCol);
                   } else {
                        move = allMoves.find(m => m.row === toRow && m.col === toCol);
                   }
             }


             if (move) {
                 // Valid drop location - execute the move
                 saveCurrentStateToHistory();
                 animateAndMovePiece(fromRow, fromCol, move); // Re-use animation
             } else {
                 // Invalid drop - deselect the piece (piece will snap back visually via CSS/render)
                 deselectPiece(); // This will trigger a render that resets piece position
             }

             // Remove the dragging class after drop is attempted (success or failure)
             if(selectedPiece && selectedPiece.element) {
                  selectedPiece.element.classList.remove('dragging');
             }

             // selectedPiece will be handled by deselectPiece or handlePostMoveChecks
         }

         // Example placeholder for drag end
         function handleDragEnd(event) {
             // Clean up dragging class and reset selected piece state if necessary
             if (selectedPiece && selectedPiece.element) {
                  selectedPiece.element.classList.remove('dragging');
             }
             // Note: deselectPiece() might be called in drop or click handlers,
             // so this might not always be needed if the drop/click logic handles selection reset.
         }
         */


         // Function to add event listeners for hover effects (pointer-events auto/none)
         function addHoverEffects() {
              // Remove existing hoverable classes first
             removeHoverEffects();

             const isInteractionBlocked = isGameOver || isAiThinking || isSettingsPanelVisible || boardSelectionScreen.classList.contains('visible') || pieceStyleSelectionScreen.classList.contains('visible') || confirmationModal.classList.contains('visible') || (gameMode === 'ai' && currentPlayer === AI_PLAYER);

             if (isInteractionBlocked) return; // Do not add hover effects if interaction is blocked


              // Add hoverable class to pieces of the current player that can be selected/moved
              boardElement.querySelectorAll(`.piece.${currentPlayer}-piece:not(.selected)`).forEach(piece => {
                 const square = piece.closest('.square');
                 if (!square) return;
                 const r = parseInt(square.dataset.row);
                 const c = parseInt(square.dataset.col);

                 // A piece is hoverable/interactive if:
                 // - It's the current player's piece (already filtered by selector)
                 // - Interaction is not blocked (already checked)
                 // - If a piece is already selected, only that piece is hoverable (unless multi-jump is forced)
                 // - If a multi-jump is required, only the piece that needs to jump again is hoverable.
                 // - The piece must have at least one valid move.

                 const isHoverable = (!selectedPiece || (selectedPiece.row === r && selectedPiece.col === c)) // Not selected, or is the selected piece
                                   && !continuousJumpPossible; // No mandatory jump required from a *specific* piece yet (or if selected, it's the correct one)

                 if (isHoverable) {
                      const movesForThisPiece = calculateMovesForPieceInternal(r, c, false, boardState);
                      const jumpsForThisPiece = movesForPiece.filter(m => m.isJump);
                      const allPossibleJumps = getAllPossibleMoves(currentPlayer, true, boardState);
                      const jumpIsMandatoryAnywhere = allPossibleJumps.length > 0;

                      let canThisPieceMove = false;
                      if (jumpIsMandatoryAnywhere) {
                          // If jumps are mandatory, this piece can only move if it has a jump
                          canThisPieceMove = jumpsForThisPiece.length > 0;
                      } else {
                          // If jumps are not mandatory, this piece can move if it has any move (jump or regular)
                          canThisPieceMove = movesForPiece.length > 0;
                      }

                      if (canThisPieceMove) {
                           piece.classList.add('hoverable');
                           piece.style.cursor = 'grab'; // Indicate draggable/selectable
                      } else {
                           piece.style.cursor = 'default'; // No moves, not grab
                      }
                 } else {
                      piece.style.cursor = 'default'; // Not hoverable in this state
                 }
             });

             // Ensure the selected piece itself has the correct cursor if applicable
              if (selectedPiece && selectedPiece.element && boardElement.contains(selectedPiece.element)) {
                   const r = selectedPiece.row;
                   const c = selectedPiece.col;
                   const movesForThisPiece = calculateMovesForPieceInternal(r, c, false, boardState);
                   if (movesForThisPiece.length > 0) { // Still has moves
                       selectedPiece.element.style.cursor = 'grab'; // Keep grab cursor
                   } else {
                       selectedPiece.element.style.cursor = 'default'; // Should not happen if selected piece has no moves
                   }
              }
         }

         // Function to remove hover effects (pointer-events auto/none)
         function removeHoverEffects() {
             // Remove the hoverable class from all pieces
             document.querySelectorAll('.piece.hoverable').forEach(p => p.classList.remove('hoverable'));
             // Reset cursor for all pieces (will be set correctly by renderBoard or addHoverEffects)
             document.querySelectorAll('.piece').forEach(p => p.style.cursor = 'default');
         }


        // --- Initialization on Load ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM Loaded. Initializing...");

            // Apply saved/default styles immediately
            loadBoardStyle();
            loadPieceStyle();

            // Update UI elements based on initial state (game over, settings hidden)
            updateSoundButtonIcon();
            updateTimerButtonIcon();
            settingsButton.style.display = 'none'; // Hide settings button initially
            settingsPanel.classList.remove('visible');
            settingsOverlay.style.display = 'none';
            boardSelectionScreen.classList.remove('visible');
            pieceStyleSelectionScreen.classList.remove('visible');
            confirmationModal.classList.remove('visible');

            gameContainer.style.display = 'none'; // Hide game container
            gameOverScreen.classList.remove('visible'); // Hide game over screen

            // Initial state is game over (menu visible)
            startScreen.classList.remove('hidden-completely'); // Ensure start screen is visible
            aiDifficultySelectorContainer.classList.remove('visible'); // Ensure difficulty selector is hidden

            isSettingsPanelVisible = false; // Initial state
            isGameOver = true; // Initial state is before game starts

            // Reset other game state variables
            boardState = [];
            currentPlayer = PLAYER_BLACK;
            selectedPiece = null;
            possibleMoves = [];
            continuousJumpPossible = false;
            isAiThinking = false;
            capturedByBlack = 0;
            capturedByWhite = 0;
            moveHistory = [];
            stopTurnTimer(); // Ensure no timer is running

            // Update UI elements based on the reset state
            updateTurnIndicatorVisuals();
            updateUndoButton();
            updateHintButton();
            updateCapturedCounters();
            updateTimerDisplay(); // Display --:-- when timer is off/stopped

            updateDifficultySelectorDisplay(); // Show correct difficulty label initially

            // Create the empty board UI on load (pieces are added/removed during renderBoard)
            createBoardUI();
             // No need to call renderBoard here unless we want to show an empty board visually before game starts.
             // renderBoard() is called by initGame() when a mode is selected.

            console.log("Initialization Complete. Ready.");
        });

         // Add resize listener to re-render the board if square size changes (due to vmin)
         window.addEventListener('resize', () => {
            // Re-create and re-render the board to recalculate square sizes and piece positions
            if (gameContainer.style.display === 'flex') { // Only re-render if the game is visible
                 createBoardUI(); // Re-create squares with potentially new sizes
                 renderBoard(); // Place pieces and update UI
            }
         });


    </script>

</body>
</html>
