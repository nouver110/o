<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Enhanced Checkers - Drag & Drop</title>
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        /* --- Base Styles --- */
        html, body { height: 100%; margin: 0; padding: 0; }
        body {
            font-family: 'Roboto', 'Cairo', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #321e06;
            color: #e0d6c8;
            box-sizing: border-box;
            position: relative;
            /* touch-action: none; /* Important for preventing default touch actions like zooming */
            /* Re-evaluate touch-action. Applying it globally on body might prevent needed scrolling/zooming elsewhere.
               Better to apply it specifically to draggable elements or their direct containers if needed.
               For this app structure, body might be acceptable, but be aware of limitations.
            */
        }

        /* --- Rotate Device Message (REMOVED) --- */
        /* The rotate message and its associated styles and media query have been removed */

        /* --- Start Screen --- */
        #start-screen {
            position: absolute; /* Use absolute instead of fixed if body is min-height: 100vh */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%; /* Use 100% to cover body height */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #4a3b31, #321e06, #4a3b31);
            background-size: 200% 200%;
            animation: gradientBG 15s ease infinite;
            text-align: center;
            z-index: 120;
            box-sizing: border-box;
            padding: 5vh 20px; /* Responsive vertical padding */
            transition: opacity 0.3s ease-out, visibility 0s linear 0.3s;
            opacity: 1;
            visibility: visible;
            /* Allow scrolling if content exceeds viewport height */
            overflow-y: auto;
            -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
        }
         #start-screen.hidden-completely {
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-out, visibility 0s linear 0.3s;
        }

        @keyframes gradientBG { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } }
        #main-title {
            font-size: clamp(3.5em, 13vh, 7em); /* Responsive font size */
            color: #e8d5b7;
            font-weight: 700;
            margin-bottom: clamp(30px, 7vh, 60px); /* Responsive spacing */
            text-shadow: 0 0 7px #fff, 0 0 14px #ffd700, 5px 5px 5px rgba(0,0,0,0.6);
            letter-spacing: 4px;
            font-family: 'Roboto', 'Cairo', Impact, sans-serif;
            opacity: 0;
            animation: fadeInTitle 1s ease-out 0.5s forwards;
            transition: opacity 0.4s ease-out;
            flex-shrink: 0; /* Prevent shrinking */
            word-break: break-word; /* Prevent overflow on very small widths */
            max-width: 100%; /* Ensure it respects padding */
        }
        @keyframes fadeInTitle { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }
        #start-screen h2#start-subtitle {
            font-size: clamp(1.6em, 5vh, 2.5em); /* Responsive font size */
            color: #f0e5d1;
            margin-top: 0;
            margin-bottom: clamp(25px, 5vh, 40px); /* Responsive spacing */
            opacity: 0;
            animation: fadeInSubtitle 1s ease-out 1s forwards;
            text-shadow: 1px 1px 4px rgba(0,0,0,0.5);
            transition: opacity 0.4s ease-out;
            flex-shrink: 0; /* Prevent shrinking */
            word-break: break-word; /* Prevent overflow */
            max-width: 100%;
        }
        @keyframes fadeInSubtitle { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
        #start-options {
             display: flex;
             flex-direction: column;
             align-items: center;
             width: 100%; /* Take full width */
             opacity: 1;
             transition: opacity 0.5s ease-out;
             flex-shrink: 0; /* Prevent shrinking */
             /* Add max-width to prevent buttons from becoming too wide on large screens */
             max-width: 500px; /* Example max-width */
             margin: 0 auto; /* Center the options block */
             box-sizing: border-box;
             padding: 0 10px; /* Add slight horizontal padding */
        }
        .start-button {
            font-family: 'Roboto', 'Cairo', sans-serif;
            font-size: clamp(1.4em, 4.5vh, 2em); /* Responsive font size */
            padding: clamp(12px, 3vh, 25px) clamp(25px, 6vw, 50px); /* Responsive padding */
            margin: clamp(10px, 2vh, 20px) 0; /* Responsive vertical margin, 0 horizontal */
            width: 100%; /* Take full width of parent (#start-options) */
            max-width: 380px; /* Explicit max-width for buttons */
            cursor: pointer;
            border: none;
            border-radius: 20px;
            background: linear-gradient(to bottom, #966f4d, #7a542e);
            color: #ffffff;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            box-shadow: 0 7px 12px rgba(0,0,0,0.45), inset 0 1px 2px rgba(255,255,255,0.2);
            transition: all 0.2s ease;
            opacity: 0;
            transform: translateY(20px);
            animation: fadeInUpButton 0.6s ease-out forwards;
            flex-shrink: 0;
            box-sizing: border-box; /* Include padding in width */
        }
        #vs-human-button { animation-delay: 1.3s; }
        #vs-ai-button { animation-delay: 1.5s; }
        @keyframes fadeInUpButton { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        .start-button:hover { background: linear-gradient(to bottom, #a07551, #8b5e3c); box-shadow: 0 9px 16px rgba(0,0,0,0.55), inset 0 1px 2px rgba(255,255,255,0.2); transform: translateY(-4px) scale(1.04); }
        .start-button:active { transform: translateY(0px) scale(1); box-shadow: 0 5px 8px rgba(0,0,0,0.4), inset 0 1px 2px rgba(0,0,0,0.25); }

        /* --- AI Difficulty Selector --- */
        #ai-difficulty-selector-container {
            display: none;
            flex-direction: column;
            align-items: center;
            width: 90%; /* Use percentage width */
            max-width: 480px; /* Max width limit */
            padding: 30px 35px;
            background-color: #3a281a;
            border-radius: 15px;
            border: 1px solid #6b4f3b;
            z-index: 130;
            opacity: 0;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            transition: opacity 0.3s ease-out 0.1s, transform 0.3s ease-out 0.1s;
            visibility: hidden;
            box-sizing: border-box;
        }
        #ai-difficulty-selector-container.visible {
            display: flex;
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
            visibility: visible;
        }
        #ai-difficulty-selector-container h3 { font-size: clamp(1.4em, 4vh, 1.8em); color: #f0e5d1; margin-top: 0; margin-bottom: 30px; text-shadow: 1px 1px 2px rgba(0,0,0,0.4); }
        .difficulty-control { display: flex; align-items: center; justify-content: center; gap: clamp(15px, 4vw, 30px); width: 100%; margin-bottom: 35px; } /* Responsive gap */
        .difficulty-arrow-button {
             background: linear-gradient(to bottom, #966f4d, #7a542e);
             border: none;
             color: white;
             font-size: clamp(1.4em, 4vh, 1.8em); /* Responsive font size */
             padding: clamp(8px, 2vh, 10px) clamp(15px, 3vw, 18px); /* Responsive padding */
             border-radius: 10px;
             cursor: pointer;
             box-shadow: 0 4px 6px rgba(0,0,0,0.3);
             transition: all 0.2s ease;
             flex-shrink: 0;
        }
        .difficulty-arrow-button:hover { background: linear-gradient(to bottom, #a07551, #8b5e3c); transform: scale(1.05); }
        .difficulty-arrow-button:active { transform: scale(0.98); box-shadow: 0 2px 4px rgba(0,0,0,0.3); }
        #difficulty-display {
            font-size: clamp(1.6em, 4.5vh, 2.1em); /* Responsive font size */
            font-weight: bold;
            color: #fff;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.6);
            min-width: clamp(80px, 15vw, 120px); /* Responsive min-width */
            text-align: center;
        }
        #confirm-difficulty-button {
             font-size: clamp(1.3em, 4vh, 1.9em); /* Responsive font size */
             padding: clamp(12px, 3vh, 25px) clamp(25px, 6vw, 50px); /* Responsive padding */
             width: 100%; /* Take full width of parent */
             max-width: 350px; /* Max width limit */
             opacity: 1;
             transform: none;
             animation: none;
             margin-top: 15px;
             box-sizing: border-box; /* Include padding in width */
        }
        #close-difficulty-selector {
             position: absolute; top: 15px; right: 15px; background: none; border: none;
             font-size: 1.6em; color: #e0d6c8; cursor: pointer; padding: 5px;
             transition: color 0.2s ease, transform 0.2s ease; z-index: 131;
        }
        #close-difficulty-selector:hover { color: #ffffff; transform: scale(1.1); }
         /* Correcting arrow icons - Font Awesome chevrons face the right by default */
        #difficulty-prev i { transform: none; } /* Standard left arrow */
        #difficulty-next i { transform: none; } /* Standard right arrow */


        /* --- Game Container --- */
        #game-container {
             display: none;
             flex-direction: column;
             align-items: center;
             justify-content: center; /* Changed from space-around to center */
             width: 100%;
             height: 100%;
             padding: clamp(10px, 2vmin, 20px); /* Responsive padding around the game */
             gap: clamp(10px, 2vh, 15px); /* Responsive gap between elements */
             box-sizing: border-box;
             position: relative;
             /* Remove overflow hidden to allow potential scrolling if board gets too big relative to container */
             /* overflow: hidden; */
             overflow: auto; /* Allow scrolling if content exceeds container size */
             -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
        }

        /* --- Status Bar --- */
        #status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center; /* Vertically center items */
            width: var(--board-size); /* Match board width */
            max-width: 95vmin; /* Max width based on smaller dimension */
            margin: 0 auto; /* Center the status bar */
            padding: 5px clamp(8px, 2vw, 15px); /* Responsive horizontal padding */
            background-color: rgba(0,0,0,0.2);
            border-radius: 8px;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.3);
            flex-wrap: wrap; /* Allow items to wrap on smaller screens */
            gap: clamp(5px, 1vw, 10px) clamp(10px, 2vw, 20px); /* Responsive gap (row-gap col-gap) */
            flex-shrink: 0; /* Don't shrink */
            box-sizing: border-box;
            min-height: 40px; /* Ensure minimum height even when wrapping */
        }
         /* Adjust order for wrapped layout if needed (current order is fine) */
        .status-section.capture-count.white { order: 1; }
        #turn-indicators { order: 2; }
        .status-section.capture-count.black { order: 3; text-align: right; }

        .status-section {
             display: flex;
             align-items: center;
             gap: clamp(5px, 1vw, 8px); /* Responsive gap within section */
             font-size: clamp(0.8em, 2.5vh, 1.1em); /* Responsive font size */
             flex-shrink: 0; /* Prevent shrinking */
             /* Allow sections to grow if needed, but basis of 0 */
             flex-basis: 0;
             flex-grow: 1; /* Allow growth */
             min-width: 100px; /* Minimum width to prevent crushing */
        }
        .status-section.capture-count.black { justify-content: flex-end; } /* Align right section to the right */


        .status-icon { font-size: 1.2em; width: 20px; text-align: center; flex-shrink: 0; } /* Fixed width is okay for icon */
        .timer-display {
             min-width: clamp(40px, 8vw, 60px); /* Responsive min-width for timer */
             text-align: right;
             background-color: rgba(0,0,0,0.3);
             padding: 2px 6px;
             border-radius: 4px;
             font-variant-numeric: tabular-nums;
             flex-shrink: 0; /* Prevent shrinking */
        }
        /* Adjust timer margin based on section alignment */
        .status-section.capture-count.white .timer-display { margin-left: clamp(5px, 1vw, 10px); margin-right: 0; }
        .status-section.capture-count.black .timer-display { margin-right: clamp(5px, 1vw, 10px); margin-left: 0; }
        .capture-count span:first-of-type { margin-right: 3px; margin-left: 0; }
        .capture-count span:last-of-type { font-weight: bold; }


        #turn-indicators {
             display: flex;
             justify-content: center;
             align-items: center;
             margin-bottom: 0;
             flex-shrink: 0;
             height: 40px;
             flex-basis: auto; /* Allow indicator block to size based on content */
             flex-grow: 0; /* Don't grow */
        }
        .turn-indicator {
             width: clamp(25px, 5vmin, 35px); /* Responsive size */
             height: clamp(25px, 5vmin, 35px); /* Responsive size */
             border-radius: 50%;
             margin: 0 clamp(4px, 1vw, 8px); /* Responsive horizontal margin */
             box-sizing: border-box;
             display: flex;
             align-items: center;
             justify-content: center;
             position: relative;
             border: 2px solid rgba(255, 50, 50, 0.6);
             box-shadow: 0 0 4px rgba(255, 50, 50, 0.4);
             transition: border-color 0.3s ease, box-shadow 0.3s ease, transform 0.3s ease;
        }
        .turn-indicator .piece-visual { width: 85%; height: 85%; border-radius: 50%; box-shadow: 0 1px 3px rgba(0,0,0,0.4); }
        .turn-indicator.active-turn { border-color: rgba(50, 255, 50, 0.8); box-shadow: 0 0 8px rgba(50, 255, 50, 0.7); transform: scale(1.1); }

        /* --- Board & Piece Styles --- */
        #board {
             display: grid;
             /* Use clamp for base square size relative to vmin, with min/max limits */
             --square-size: clamp(40px, 9.5vmin, 75px);
             --board-size: calc(var(--square-size) * 8);
             grid-template-columns: repeat(8, var(--square-size));
             grid-template-rows: repeat(8, var(--square-size));
             width: var(--board-size);
             height: var(--board-size);
             box-shadow: 0 8px 16px rgba(0,0,0,0.5), inset 0 0 10px rgba(0,0,0,0.4);
             border-radius: 8px;
             position: relative;
             margin: 0 auto;
             max-width: 95vmin;
             max-height: 95vmin;
             aspect-ratio: 1 / 1;
             flex-shrink: 1; /* Allow board to shrink within flex container */
             /* Border size will be adjusted in media queries */
             border: 10px solid transparent; /* Default border */
             background-color: #4a311c;
             transition: border-color 0.3s ease, background-color 0.3s ease;
             user-select: none;
             touch-action: none; /* Disable default touch actions specifically on the board */
        }

         /* Adjust board border on smaller screens */
         @media (max-width: 600px), (max-height: 600px) {
             #board {
                 border-width: 6px; /* Smaller border on smaller screens */
             }
         }
          @media (max-width: 400px), (max-height: 400px) {
             #board {
                 border-width: 4px; /* Even smaller border */
             }
         }


        .square {
            width: var(--square-size);
            height: var(--square-size);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            transition: background-color 0.15s ease, box-shadow 0.2s ease, background 0.2s ease;
            overflow: visible; /* Needed for piece outline animation */
            box-sizing: border-box; /* Include border/padding in element's total width and height */
        }
        .piece {
            width: 85%;
            height: 85%;
            border-radius: 50%;
            cursor: grab;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            transition: transform 0.15s ease, box-shadow 0.2s ease, background 0.3s ease, border-color 0.3s ease, outline-color 0.3s ease;
            border: 2px solid rgba(255, 255, 255, 0.1);
            overflow: hidden;
            animation: none;
            outline: 0px solid transparent;
            outline-offset: 2px;
            will-change: transform;
            /* touch-action: none; /* Already on board, but can add here too for safety */
            box-sizing: border-box; /* Include border/outline in potential size calculations */
        }
        .piece.dragging { cursor: grabbing; z-index: 1000 !important; transform: translate(calc(-50% + var(--drag-dx, 0)), calc(-50% + var(--drag-dy, 0))) scale(1.1); box-shadow: 0 10px 25px rgba(0,0,0,0.5) !important; opacity: 0.85; transition: none !important; } /* Adjusted transform for drag offset */
        .piece.ghost { opacity: 0.3 !important; }
        .piece.captured-fade { animation: fadeOutPiece 0.4s ease-out forwards; z-index: 5; }
        @keyframes fadeOutPiece { from { opacity: 1; transform: translate(-50%, -50%) scale(0.9); } to { opacity: 0; transform: translate(-50%, -50%) scale(0.5); } }
        .piece.jump-hint { outline-color: rgba(0, 255, 0, 0.7); outline-width: 3px; animation: hintPulseGreen 1.5s infinite ease-in-out !important; }
        @keyframes hintPulseGreen { 0%, 100% { outline-color: rgba(0, 255, 0, 0.7); box-shadow: 0 0 8px rgba(0, 255, 0, 0.4); } 50% { outline-color: rgba(150, 255, 150, 0.9); box-shadow: 0 0 15px rgba(150, 255, 150, 0.7); } }

        /* --- King Crown Style --- */
        .piece.king::after {
             content: '‚ôï';
             position: absolute;
             font-size: calc(var(--square-size) * 0.35); /* Responsive size based on square */
             top: 50%;
             left: 50%;
             transform: translate(-50%, -50%);
             pointer-events: none;
             z-index: 11;
             opacity: 1;
             line-height: 1;
             text-align: center;
             /* Ensure consistent spacing regardless of square size */
             display: flex;
             align-items: center;
             justify-content: center;
             width: 100%; height: 100%; /* Added width/height to center content reliably */
        }
        .piece.king.white-piece::after { color: #000000; text-shadow: 0 0 2px rgba(255, 255, 255, 0.6); }
        .piece.king.black-piece::after { color: #FFD700; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.6); }

        /* --- Piece Style Variations (Simplified) --- */
        /* ... (Existing piece style variations CSS remains the same) ... */
        /* Note: These styles primarily affect colors and shadows, which scale with the piece size */
        body.piece-style-classic .piece.black-piece { background: linear-gradient(to bottom right, #444 0%, #111 100%); box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.2), 0 4px 8px rgba(0, 0, 0, 0.7); border-color: rgba(0, 0, 0, 0.2); } body.piece-style-classic .piece.white-piece { background: linear-gradient(to bottom right, #eee 0%, #ccc 100%); box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.2), 0 4px 8px rgba(0, 0, 0, 0.5); border-color: rgba(255, 255, 255, 0.3); } body.piece-style-classic .piece.selected { box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.3), 0 4px 12px rgba(0, 0, 0, 0.9), 0 0 0 5px rgba(52, 152, 219, 0.8) !important; } body.piece-style-classic .piece.white-piece.selected { box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3), 0 4px 12px rgba(0, 0, 0, 0.6), 0 0 0 5px rgba(52, 152, 219, 0.8) !important; } body.piece-style-classic .piece.hoverable:hover { box-shadow: inset 0 0 12px rgba(255, 255, 255, 0.3), 0 6px 15px rgba(0, 0, 0, 0.8); } body.piece-style-classic .piece.white-piece.hoverable:hover { box-shadow: inset 0 0 12px rgba(0, 0, 0, 0.2), 0 6px 15px rgba(0, 0, 0, 0.5); }
        body.piece-style-flat .piece { border: 1px solid rgba(0,0,0,0.3); box-shadow: none; } body.piece-style-flat .piece.black-piece { background: #2c2c2c; } body.piece-style-flat .piece.white-piece { background: #f0f0f0; } body.piece-style-flat .piece.selected { box-shadow: 0 0 0 5px rgba(52, 152, 219, 0.8) !important; } body.piece-style-flat .piece.hoverable:hover { transform: translate(-50%, -50%) translateY(-3px) scale(1.04); opacity: 0.9; }
        body.piece-style-crimson .piece.black-piece { background: linear-gradient(to bottom right, #b71c1c 0%, #7f0000 100%); box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.25), 0 4px 8px rgba(0, 0, 0, 0.7); border-color: rgba(50, 0, 0, 0.3); } body.piece-style-crimson .piece.white-piece { background: linear-gradient(to bottom right, #fffde7 0%, #fff8e1 100%); box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.1), 0 4px 8px rgba(0, 0, 0, 0.4); border-color: rgba(200, 190, 170, 0.4); } body.piece-style-crimson .piece.selected { box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.3), 0 4px 12px rgba(0, 0, 0, 0.9), 0 0 0 5px rgba(255, 82, 82, 0.8) !important; } body.piece-style-crimson .piece.white-piece.selected { box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.2), 0 4px 12px rgba(0, 0, 0, 0.5), 0 0 0 5px rgba(255, 82, 82, 0.8) !important; } body.piece-style-crimson .piece.hoverable:hover { box-shadow: inset 0 0 12px rgba(255, 255, 255, 0.3), 0 6px 15px rgba(0, 0, 0, 0.8); } body.piece-style-crimson .piece.white-piece.hoverable:hover { box-shadow: inset 0 0 12px rgba(0, 0, 0, 0.2), 0 6px 15px rgba(0, 0, 0, 0.5); }
        body.piece-style-azure .piece { border: 1px solid rgba(0,0,0,0.3); box-shadow: none; } body.piece-style-azure .piece.black-piece { background: #1976d2; border-color: #0d47a1; } body.piece-style-azure .piece.white-piece { background: #e3f2fd; border-color: #90caf9; } body.piece-style-azure .piece.selected { box-shadow: 0 0 0 5px rgba(66, 165, 245, 0.8) !important; } body.piece-style-azure .piece.hoverable:hover { transform: translate(-50%, -50%) translateY(-3px) scale(1.04); opacity: 0.9; }
        body.piece-style-forest .piece.black-piece { background: linear-gradient(to bottom right, #388e3c 0%, #1b5e20 100%); box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.2), 0 4px 8px rgba(0, 0, 0, 0.7); border-color: rgba(0, 50, 0, 0.3); } body.piece-style-forest .piece.white-piece { background: linear-gradient(to bottom right, #f5f5dc 0%, #d2b48c 100%); box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.15), 0 4px 8px rgba(0, 0, 0, 0.4); border-color: rgba(180, 160, 130, 0.4); } body.piece-style-forest .piece.selected { box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.3), 0 4px 12px rgba(0, 0, 0, 0.9), 0 0 0 5px rgba(102, 187, 106, 0.8) !important; } body.piece-style-forest .piece.white-piece.selected { box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.2), 0 4px 12px rgba(0, 0, 0, 0.5), 0 0 0 5px rgba(102, 187, 106, 0.8) !important; } body.piece-style-forest .piece.hoverable:hover { box-shadow: inset 0 0 12px rgba(255, 255, 255, 0.3), 0 6px 15px rgba(0, 0, 0, 0.8); } body.piece-style-forest .piece.white-piece.hoverable:hover { box-shadow: inset 0 0 12px rgba(0, 0, 0, 0.2), 0 6px 15px rgba(0, 0, 0, 0.5); }
        body.piece-style-royal .piece.black-piece { background: linear-gradient(to bottom right, #6a1b9a 0%, #4a148c 100%); box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.25), 0 4px 8px rgba(0, 0, 0, 0.7); border-color: rgba(30, 0, 50, 0.4); } body.piece-style-royal .piece.white-piece { background: linear-gradient(to bottom right, #fff59d 0%, #ffee58 100%); box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.1), 0 4px 8px rgba(0, 0, 0, 0.4); border-color: rgba(190, 180, 100, 0.5); } body.piece-style-royal .piece.selected { box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.3), 0 4px 12px rgba(0, 0, 0, 0.9), 0 0 0 5px rgba(255, 238, 88, 0.8) !important; } body.piece-style-royal .piece.white-piece.selected { box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.2), 0 4spx 12px rgba(0, 0, 0, 0.5), 0 0 0 5px rgba(255, 238, 88, 0.8) !important; } body.piece-style-royal .piece.hoverable:hover { box-shadow: inset 0 0 12px rgba(255, 255, 255, 0.3), 0 6px 15px rgba(0, 0, 0, 0.8); } body.piece-style-royal .piece.white-piece.hoverable:hover { box-shadow: inset 0 0 12px rgba(0, 0, 0, 0.2), 0 6px 15px rgba(0, 0, 0, 0.5); }


        /* --- General Piece Modifiers --- */
        .selected { z-index: 20; transform: translate(-50%, -50%) scale(1.05); outline-width: 0px !important; animation: none !important; }
        .possible-move::before { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 255, 0, 0.15); border: 2px solid rgba(0, 255, 0, 0.4); border-radius: 50%; pointer-events: none; z-index: 5; box-sizing: border-box; animation: pulsePossible 1.8s infinite ease-in-out; }
        @keyframes pulsePossible { 0% { transform: scale(0.5); opacity: 0.5; } 50% { transform: scale(0.7); opacity: 0.8; } 100% { transform: scale(0.5); opacity: 0.5; } }
        .hint-piece-suggestion { outline: 4px dashed #ffdd00 !important; outline-offset: 3px; animation: hintPulseYellow 1s infinite !important; z-index: 22 !important; }
        .hint-move-suggestion::before { background-color: rgba(255, 221, 0, 0.3) !important; border-color: #ffdd00 !important; animation: pulsePossible 1s infinite ease-in-out !important; z-index: 6 !important; }
        @keyframes hintPulseYellow { 0%, 100% { outline-color: #ffdd00; } 50% { outline-color: #fff3a0; } }
        .piece.hoverable:hover { transform: translate(-50%, -50%) translateY(-3px) scale(1.04); }
         /* Added style for drag-target square */
         .square.drag-target {
             background-color: rgba(255, 255, 0, 0.2) !important; /* Highlight possible drop target */
             box-shadow: 0 0 10px rgba(255, 255, 0, 0.5) !important;
         }


        /* --- Game Over Screen --- */
        #game-over-screen {
             position: fixed; top: 0; left: 0; width: 100%; height: 100%;
             background: radial-gradient(circle, rgba(0, 0, 0, 0.7) 0%, rgba(0, 0, 0, 0.9) 100%);
             display: none; flex-direction: column; align-items: center; justify-content: center;
             z-index: 100; text-align: center; opacity: 0; transition: opacity 0.6s ease-in-out;
             /* Allow scrolling if content somehow exceeds height on tiny screens */
             overflow-y: auto;
             -webkit-overflow-scrolling: touch;
             padding: 20px; /* Add padding */
             box-sizing: border-box;
        }
        #game-over-screen.visible { display: flex; opacity: 1; }
        #game-over-content {
            background-color: rgba(60, 40, 20, 0.8);
            padding: 30px 40px; /* Fixed padding */
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.6);
            transform: scale(0.8);
            transition: transform 0.4s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            border: 1px solid #a07551;
            width: 90%; /* Responsive width */
            max-width: 450px; /* Max width limit */
            box-sizing: border-box;
        }
        #game-over-screen.visible #game-over-content { transform: scale(1); }
        #game-over-message {
             font-size: clamp(1.8em, 5vh, 2.2em); /* Responsive font size */
             color: #fff; text-shadow: 1px 1px 0px #ffeb3b, 3px 3px 5px rgba(0,0,0,0.7);
             margin-bottom: 25px; font-weight: 700; line-height: 1.4; /* Added line height */
        }
        #game-over-message::before { content: 'üèÜ'; display: block; font-size: 2em; margin-bottom: 10px; text-shadow: 0 0 10px #ffd700; }
        #back-to-menu-button {
            font-family: 'Roboto', 'Cairo', sans-serif;
            font-size: clamp(1em, 2.5vh, 1.2em); /* Responsive font size */
            padding: clamp(8px, 2vh, 10px) clamp(20px, 4vw, 25px); /* Responsive padding */
            cursor: pointer; border: none; border-radius: 8px;
            background: linear-gradient(to bottom, #e0d6c8, #c1b2a3); color: #321e06;
            font-weight: bold; box-shadow: 0 3px 5px rgba(0,0,0,0.25), inset 0 -2px 1px rgba(0,0,0,0.1);
            transition: all 0.2s ease;
            margin-top: 20px; /* Add margin-top */
        }
        #back-to-menu-button:hover { background: linear-gradient(to bottom, #f7f2e8, #e8e0d0); box-shadow: 0 4px 7px rgba(0,0,0,0.3), inset 0 -2px 1px rgba(0,0,0,0.1); transform: translateY(-1px); }
        #back-to-menu-button:active { transform: translateY(0px); box-shadow: 0 2px 4px rgba(0,0,0,0.25), inset 0 -1px 1px rgba(0,0,0,0.15); }

        /* --- Settings Button & Panel Styles --- */
        #settings-button {
             position: fixed; top: 15px; right: 15px; z-index: 110;
             font-size: clamp(1.5em, 3vh, 1.8em); /* Responsive size */
             background: none; border: none; color: rgba(255, 255, 255, 0.7);
             cursor: pointer; padding: 5px; transition: color 0.2s ease, transform 0.2s ease;
        }
        #settings-button:hover { color: rgba(255, 255, 255, 1); transform: rotate(15deg); }
        #settings-panel {
             position: fixed; top: clamp(50px, 8vh, 60px); right: 15px; /* Responsive top positioning */
             transform: none;
             background-color: rgba(40, 25, 10, 0.9);
             padding: clamp(10px, 2vh, 15px); /* Responsive padding */
             border-radius: 10px; box-shadow: 0 5px 10px rgba(0, 0, 0, 0.4);
             z-index: 115; display: none; flex-direction: column; align-items: center;
             gap: clamp(8px, 1.5vh, 10px); /* Responsive gap */
             border: 1px solid #7a542e;
             max-height: calc(100vh - clamp(70px, 10vh, 80px)); /* Responsive max-height */
             overflow-y: auto; /* Allow scrolling */
             -webkit-overflow-scrolling: touch;
        }
        #settings-panel.visible { display: flex; }
        #settings-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: transparent; z-index: 114; display: none; }
        .settings-icon-button {
            display: flex; align-items: center; justify-content: center;
            width: clamp(40px, 7vmin, 45px); /* Responsive size */
            height: clamp(40px, 7vmin, 45px); /* Responsive size */
            font-size: clamp(1.1em, 2.5vmin, 1.3em); /* Responsive font size */
            border: none; border-radius: 8px; cursor: pointer;
            background: linear-gradient(to bottom, #966f4d, #7a542e); color: #ffffff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3); transition: all 0.2s ease; text-align: center;
            flex-shrink: 0;
        }
        .settings-icon-button:hover { background: linear-gradient(to bottom, #a07551, #8b5e3c); box-shadow: 0 3px 6px rgba(0,0,0,0.4); transform: translateY(-1px); }
        .settings-icon-button:active { transform: translateY(0); box-shadow: 0 1px 3px rgba(0,0,0,0.3); }
        .settings-icon-button:disabled { background: #aaa; color: #666; cursor: not-allowed; box-shadow: 0 1px 2px rgba(0,0,0,0.2); transform: none; }
        #sound-toggle-button.sound-off { background: linear-gradient(to bottom, #c1b2a3, #a39588); color: #321e06; }
        #sound-toggle-button.sound-off:hover { background: linear-gradient(to bottom, #d0c5b8, #b8a99a); }
        #timer-toggle-button.timer-off { background: linear-gradient(to bottom, #c1b2a3, #a39588); color: #321e06; }
        #timer-toggle-button.timer-off:hover { background: linear-gradient(to bottom, #d0c5b8, #b8a99a); }

        /* --- Overlay Screen Styles (Board/Piece selection) --- */
        .overlay-screen {
             position: fixed; top: 0; left: 0; width: 100%; height: 100%;
             background-color: rgba(0, 0, 0, 0.85);
             display: none; flex-direction: column; align-items: center; justify-content: center;
             z-index: 150; opacity: 0; transition: opacity 0.4s ease-in-out;
             padding: 20px; box-sizing: border-box;
             overflow-y: auto; /* Allow scrolling if content exceeds height */
             -webkit-overflow-scrolling: touch;
        }
        .overlay-screen.visible { display: flex; opacity: 1; }
        .selection-content {
            background-color: rgba(60, 40, 20, 0.9);
            padding: 25px 35px; /* Fixed padding */
            border-radius: 15px;
            box-shadow: 0 6px 25px rgba(0,0,0,0.6);
            text-align: center;
            width: 90%; /* Responsive width */
            max-width: 700px; /* Max width limit */
            transform: scale(0.9);
            transition: transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            border: 1px solid #966f4d;
            margin: 10px auto; /* Center and add vertical margin */
            display: flex;
            flex-direction: column;
            max-height: 90vh; /* Responsive max height */
            box-sizing: border-box;
        }
        #confirmation-modal .selection-content {
            width: 90%; /* Responsive width */
            max-width: 450px; /* Max width limit */
            max-height: none; /* Remove max-height constraint */
            display: block; /* Use block layout */
            padding: 30px 35px; /* Fixed padding */
        }
        .overlay-screen.visible .selection-content { transform: scale(1); }
        .selection-content h2 {
            font-size: clamp(1.6em, 4vh, 1.8em); /* Responsive font size */
            color: #f0e5d1;
            margin-top: 0; margin-bottom: 20px;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
            flex-shrink: 0; word-break: break-word; /* Prevent overflow */
        }
        .options-container {
            display: grid;
            /* Responsive grid: auto-fit columns with minmax size */
            grid-template-columns: repeat(auto-fit, minmax(clamp(90px, 18vw, 120px), 1fr));
            gap: clamp(10px, 3vw, 20px); /* Responsive gap */
            margin-bottom: 20px;
            overflow-y: auto; /* Allow scrolling if options exceed height */
            flex-shrink: 1; flex-grow: 1;
            padding-left: 5px; padding-right: 15px; padding-bottom: 15px;
            scrollbar-width: thin; scrollbar-color: #966f4d rgba(0,0,0,0.2);
        }
        .options-container::-webkit-scrollbar { width: 8px; }
        .options-container::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); border-radius: 4px; }
        .options-container::-webkit-scrollbar-thumb { background-color: #966f4d; border-radius: 4px; border: 2px solid transparent; background-clip: content-box;}

        .option-button {
            font-family: 'Roboto', 'Cairo', sans-serif;
            cursor: pointer;
            border: 2px solid #7a542e;
            border-radius: 8px;
            background-color: rgba(255, 255, 255, 0.05);
            padding: clamp(8px, 2vh, 10px); /* Responsive padding */
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: #e0d6c8;
            font-size: clamp(0.9em, 2vh, 1em); /* Responsive font size */
            min-height: clamp(80px, 16vmin, 100px); /* Responsive min-height */
            justify-content: space-between;
            box-sizing: border-box;
        }
        .option-button:hover { background-color: rgba(255, 255, 255, 0.15); border-color: #a07551; transform: translateY(-3px); box-shadow: 0 4px 8px rgba(0,0,0,0.3); }
        .option-button.selected-style { border-color: #ffd700; background-color: rgba(255, 215, 0, 0.15); box-shadow: 0 0 10px rgba(255, 215, 0, 0.4); }

        .close-selection-button {
            font-family: 'Roboto', 'Cairo', sans-serif;
            font-size: clamp(1em, 2.5vh, 1.1em); /* Responsive font size */
            padding: clamp(10px, 2.5vh, 12px) clamp(24px, 5vw, 28px); /* Responsive padding */
            cursor: pointer; border: none; border-radius: 10px;
            background: linear-gradient(to bottom, #e0d6c8, #c1b2a3); color: #321e06;
            font-weight: bold; box-shadow: 0 3px 5px rgba(0,0,0,0.25), inset 0 -2px 1px rgba(0,0,0,0.1);
            transition: all 0.2s ease;
            margin-top: auto; /* Push to bottom in flex column */
            flex-shrink: 0; word-break: break-word; /* Prevent overflow */
        }
        #confirmation-buttons button { margin-top: 0; }
        .close-selection-button:hover { background: linear-gradient(to bottom, #f7f2e8, #e8e0d0); box-shadow: 0 4px 7px rgba(0,0,0,0.3), inset 0 -2px 1px rgba(0,0,0,0.1); transform: translateY(-2px); }
        .close-selection-button:active { transform: translateY(0px); box-shadow: 0 2px 4px rgba(0,0,0,0.25), inset 0 -1px 1px rgba(0,0,0,0.15); }

        /* --- Board Selection Screen --- */
        .board-preview {
             width: clamp(40px, 8vmin, 50px); /* Responsive size */
             height: clamp(40px, 8vmin, 50px); /* Responsive size */
             display: grid;
             grid-template-columns: repeat(2, 1fr);
             grid-template-rows: repeat(2, 1fr);
             border: 1px solid rgba(0,0,0,0.3);
             margin-bottom: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.2);
             border-radius: 3px; overflow: hidden; flex-shrink: 0;
        }
        .board-preview .sq { width: 100%; height: 100%; }
        .board-preview-wood .light { background-color: #DEB887; } .board-preview-wood .dark { background-color: #A0522D; }
        .board-preview-desert .light { background-color: #f4a460; } .board-preview-desert .dark { background-color: #8b4513; }
        .board-preview-stone-path .light { background-color: #e0e0e0; } .board-preview-stone-path .dark { background-color: #616161; }
        .board-preview-emerald .light { background-color: #e0f2f1; } .board-preview-emerald .dark { background-color: #00695c; }
        .board-preview-volcano .light { background-color: #d3d3d3; } .board-preview-volcano .dark { background-color: #dc143c; }
        .board-preview-royal .light { background-color: #fffacd; } .board-preview-royal .dark { background-color: #4b0082; }

        /* --- Board Styles (Remain largely the same, borders adjusted via media query above) --- */
        #board.board-style-wood { border-color: #8B4513; background-color: #A0522D; } #board.board-style-wood .light-square { background: #DEB887; box-shadow: inset 1px 1px 3px rgba(255, 255, 255, 0.3); } #board.board-style-wood .dark-square { background: #A0522D; box-shadow: inset 1px 1px 4px rgba(0, 0, 0, 0.6); cursor: pointer; } #board.board-style-wood .dark-square:hover:not(:has(.piece)):not(.possible-move) { background: #b3623f; }
        #board.board-style-desert { border-color: #a0522d; background-color: #cd853f; } #board.board-style-desert .light-square { background: linear-gradient(135deg, #f4a460 0%, #deb887 100%); box-shadow: inset 1px 1px 3px rgba(255, 255, 255, 0.25); } #board.board-style-desert .dark-square { background: linear-gradient(135deg, #8b4513 0%, #a0522d 100%); box-shadow: inset 1px 1px 4px rgba(0, 0, 0, 0.5); cursor: pointer; } #board.board-style-desert .dark-square:hover:not(:has(.piece)):not(.possible-move) { background: linear-gradient(135deg, #9e5624 0%, #b3623f 100%); }
        #board.board-style-stone-path { border-color: #5d4037; background-color: #795548; } #board.board-style-stone-path .light-square { background: linear-gradient(135deg, #e0e0e0 0%, #bdbdbd 100%); box-shadow: inset 1px 1px 3px rgba(255, 255, 255, 0.2); } #board.board-style-stone-path .dark-square { background: linear-gradient(135deg, #616161 0%, #424242 100%); box-shadow: inset 1px 1px 4px rgba(0, 0, 0, 0.5); cursor: pointer; } #board.board-style-stone-path:hover:not(:has(.piece)):not(.possible-move) { background: linear-gradient(135deg, #757575 0%, #5a5a5a 100%); }
        #board.board-style-emerald { border-color: #004d40; background-color: #00695c; } #board.board-style-emerald .light-square { background: linear-gradient(135deg, #e0f2f1 0%, #ffffff 100%); box-shadow: inset 1px 1px 3px rgba(0, 0, 0, 0.1); } #board.board-style-emerald .dark-square { background: linear-gradient(135deg, #00695c 0%, #004d40 100%); box-shadow: inset 1px 1px 4px rgba(0, 0, 0, 0.6); cursor: pointer; } #board.board-style-emerald .dark-square:hover:not(:has(.piece)):not(.possible-move) { background: linear-gradient(135deg, #00796b 0%, #005f51 100%); }
        #board.board-style-volcano { border-color: #696969; background-color: #8B0000; } #board.board-style-volcano .light-square { background: linear-gradient(135deg, #d3d3d3 0%, #f5f5f5 100%); box-shadow: inset 1px 1px 2px rgba(0, 0, 0, 0.1); } #board.board-style-volcano .dark-square { background: linear-gradient(135deg, #dc143c 0%, #b22222 100%); box-shadow: inset 1px 1px 4px rgba(0, 0, 0, 0.5); cursor: pointer; } #board.board-style-volcano .dark-square:hover:not(:has(.piece)):not(.possible-move) { background: linear-gradient(135deg, #e82e4f 0%, #c53030 100%); }
        #board.board-style-royal { border-color: #483d8b; background-color: #6a5acd; } #board.board-style-royal .light-square { background: linear-gradient(135deg, #fffacd 0%, #eee8aa 100%); box-shadow: inset 1px 1px 3px rgba(0, 0, 0, 0.15); } #board.board-style-royal .dark-square { background: linear-gradient(135deg, #4b0082 0%, #8a2be2 100%); box-shadow: inset 1px 1px 4px rgba(0, 0, 0, 0.6); cursor: pointer; } #board.board-style-royal .dark-square:hover:not(:has(.piece)):not(.possible-move) { background: linear-gradient(135deg, #5c1092 0%, #9d3fe5 100%); }


        /* Piece Selection Screen specific styles */
        #piece-options-container { grid-template-columns: repeat(auto-fit, minmax(clamp(80px, 16vw, 100px), 1fr)); } /* Adjusted minmax for piece options */
        .piece-preview-container { display: flex; justify-content: center; align-items: center; gap: clamp(5px, 1vw, 8px); margin-bottom: 10px; width: 100%; height: clamp(30px, 6vmin, 45px); /* Responsive height */ }
        .piece-preview {
            width: clamp(25px, 5vmin, 35px); /* Responsive size */
            height: clamp(25px, 5vmin, 35px); /* Responsive size */
            border-radius: 50%;
            border: 1px solid rgba(0,0,0,0.2);
            box-shadow: 0 1px 2px rgba(0,0,0,0.3);
            position: relative;
            display: flex; align-items: center; justify-content: center;
            flex-shrink: 0;
        }
         .piece-preview.black.classic { background: linear-gradient(to bottom right, #444 0%, #111 100%); box-shadow: inset 0 0 5px rgba(255, 255, 255, 0.1), 0 2px 4px rgba(0, 0, 0, 0.5); border-color: rgba(0, 0, 0, 0.2); } .piece-preview.white.classic { background: linear-gradient(to bottom right, #eee 0%, #ccc 100%); box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.1), 0 2px 4px rgba(0, 0, 0, 0.3); border-color: rgba(255, 255, 255, 0.3); }
         .piece-preview.black.flat { background: #2c2c2c; border: 1px solid #555; box-shadow: none; } .piece-preview.white.flat { background: #f0f0f0; border: 1px solid #ccc; box-shadow: none; }
         .piece-preview.black.crimson { background: linear-gradient(to bottom right, #b71c1c 0%, #7f0000 100%); border-color: rgba(50, 0, 0, 0.3); } .piece-preview.white.crimson { background: linear-gradient(to bottom right, #fffde7 0%, #fff8e1 100%); border-color: rgba(200, 190, 170, 0.4); }
         .piece-preview.black.azure { background: #1976d2; border-color: #0d47a1; box-shadow: none; } .piece-preview.white.azure { background: #e3f2fd; border-color: #90caf9; box-shadow: none; }
         .piece-preview.black.forest { background: linear-gradient(to bottom right, #388e3c 0%, #1b5e20 100%); border-color: rgba(0, 50, 0, 0.3); } .piece-preview.white.forest { background: linear-gradient(to bottom right, #f5f5dc 0%, #d2b48c 100%); border-color: rgba(180, 160, 130, 0.4); }
         .piece-preview.black.royal { background: linear-gradient(to bottom right, #6a1b9a 0%, #4a148c 100%); border-color: rgba(30, 0, 50, 0.4); } .piece-preview.white.royal { background: linear-gradient(to bottom right, #fff59d 0%, #ffee58 100%); border-color: rgba(190, 180, 100, 0.5); }

        /* Confirmation Modal Styles */
        #confirmation-modal .selection-content {
             width: 90%; /* Responsive width */
             max-width: 450px; /* Max width limit */
             padding: clamp(20px, 4vh, 30px) clamp(25px, 5vw, 35px); /* Responsive padding */
             border-width: 2px; border-color: #b58863; background-color: #4a311c;
             box-shadow: 0 10px 30px rgba(0,0,0,0.6);
             max-height: none; display: block;
             margin: auto; /* Center block */
        }
        #confirmation-message {
             font-size: clamp(1.1em, 3vh, 1.3em); /* Responsive font size */
             color: #f0e5d1; margin-bottom: clamp(20px, 4vh, 35px); /* Responsive margin */
             line-height: 1.6; text-shadow: 1px 1px 3px rgba(0,0,0,0.6);
        }
        #confirmation-buttons {
            display: flex; flex-direction: column; align-items: center;
            margin-top: 20px; gap: 15px; /* Fixed gap is okay here */
        }
        #confirmation-buttons button {
            width: 80%; max-width: 250px; /* Fixed max-width */
            margin-top: 0;
            font-size: clamp(0.9em, 2.2vh, 1.1em); /* Responsive font size */
            padding: clamp(8px, 2vh, 10px) clamp(18px, 4vw, 25px); /* Responsive padding */
        }
        #confirm-logout-button { background: linear-gradient(to bottom, #b75656, #913434); color: #ffffff; text-shadow: 1px 1px 2px rgba(0,0,0,0.4); border: 1px solid #7a2a2a; }
        #confirm-logout-button:hover { background: linear-gradient(to bottom, #c96e6e, #a04a4a); border-color: #8b3a3a; }
        #cancel-logout-button { /* Style already inherited */ }

        /* --- Media Queries --- */
        /* Existing media queries were largely redundant or could be simplified by clamp/flex-wrap.
           Keeping them only if they provide specific necessary overrides.
           Based on the analysis, the clamp(), vmin, flexbox, and grid(auto-fit/minmax)
           already provide good responsiveness.
           The custom media queries for board border size were added above.
           Let's review the original media queries and remove/simplify unnecessary ones.
        */

        /* Original Media Queries Review:
         @media (max-height: 850px), (max-width: 700px) { ... } - Adjusts --square-size, .selection-content, .options-container, #status-bar.
           - --square-size is already handled by clamp(..., 9.5vmin, ...). This query's adjustment might make it less responsive or override clamp unintentionally. REMOVE or update clamp.
           - .selection-content width/max-width/max-height - Can use percentage width, max-width, vh units directly without this query. REMOVE or integrate.
           - .options-container grid/gap - Already using auto-fit/minmax and clamp for gap. This query's adjustment is redundant. REMOVE.
           - #status-bar width - Already uses var(--board-size) which is tied to vmin. This query is redundant. REMOVE.
         @media (max-height: 680px), (max-width: 550px) { ... } - Adjusts --square-size, .selection-content, .options-container, .option-button, .board-preview, .piece-preview, h2 font, button font/padding, #status-bar.
           - --square-size: Same issue as above. REMOVE or update clamp.
           - .selection-content: Can use percentages/vh. REMOVE or integrate.
           - .options-container: Redundant grid/gap. REMOVE.
           - .option-button: Font/min-height already using clamp. Redundant. REMOVE.
           - .board-preview, .piece-preview: Sizes already using clamp. Redundant. REMOVE.
           - h2 font, button font/padding: Already using clamp. Redundant. REMOVE.
           - #status-bar: Redundant width/flex-direction/align-items. REMOVE.
         @media (max-height: 600px), (max-width: 450px) { ... } - Similar adjustments, even more aggressive.
           - All adjustments here seem redundant or potentially conflicting with the more robust clamp/vmin/flex/grid methods applied directly. REMOVE.
           - The exception is the specific padding adjustments or slight layout tweaks *if* the base responsive design doesn't handle extremes well. Let's keep the general structure but simplify the rules within them, relying on clamp/vmin where possible.

           Let's keep the media query breakpoints but clean up the *rules* inside them, focusing on things like padding or specific element spacing that might need fine-tuning beyond clamp().

        */
         /* Keeping media query structure but simplifying content */
         @media (max-width: 700px) {
             /* Adjust padding on larger overlays */
            .selection-content {
                padding: 20px 25px;
            }
             /* Adjust padding on difficulty selector */
             #ai-difficulty-selector-container {
                padding: 25px 30px;
             }
              /* Adjust font size slightly if clamp isn't enough */
             .status-section { font-size: clamp(0.8em, 2.5vh, 1em); }
         }

         @media (max-width: 550px) {
             /* Further adjust padding */
             .selection-content {
                 padding: 15px 20px;
             }
             #ai-difficulty-selector-container {
                 padding: 20px 25px;
             }
             /* Adjust button padding slightly */
             .start-button { padding: clamp(10px, 2.5vh, 20px) clamp(20px, 5vw, 40px); }
             /* Adjust font size slightly */
             .status-section { font-size: clamp(0.75em, 2vh, 0.9em); }
             .timer-display { min-width: clamp(35px, 7vw, 50px); }
             .turn-indicator { width: clamp(20px, 4vmin, 30px); height: clamp(20px, 4vmin, 30px); }
         }

         @media (max-width: 450px) {
             /* Even further adjust padding */
             .selection-content {
                 padding: 10px 15px;
             }
              #ai-difficulty-selector-container {
                 padding: 15px 20px;
              }
             /* Adjust button padding */
             .start-button { padding: clamp(8px, 2vh, 15px) clamp(15px, 4vw, 30px); }
             .close-selection-button { padding: clamp(8px, 2vh, 10px) clamp(15px, 4vw, 20px); }
             /* Adjust font size */
             .status-section { font-size: clamp(0.7em, 1.8vh, 0.85em); }
             .timer-display { min-width: clamp(30px, 6vw, 45px); }
             .turn-indicator { width: clamp(18px, 3.5vmin, 25px); height: clamp(18px, 3.5vmin, 25px); }
              /* Confirmation modal adjustments */
             #confirmation-modal .selection-content {
                padding: clamp(15px, 3vh, 20px) clamp(15px, 4vw, 25px);
             }
             #confirmation-message { font-size: clamp(1em, 2.5vh, 1.2em); margin-bottom: clamp(15px, 3vh, 25px); }
             #confirmation-buttons button { font-size: clamp(0.85em, 2vh, 1em); padding: clamp(6px, 1.5vh, 8px) clamp(15px, 3vw, 18px); }

         }


    </style>
</head>
<body class="piece-style-classic">

     <!-- Message to rotate device (REMOVED) -->
     <!-- <div id="rotate-device-message">...</div> -->

    <!-- Settings Button -->
    <button id="settings-button" title="Settings"> <i class="fas fa-cog"></i> </button>

    <!-- Settings Overlay -->
    <div id="settings-overlay"></div>

    <!-- Settings Panel -->
    <div id="settings-panel">
        <button id="sound-toggle-button" class="settings-icon-button" title="Toggle Sound"> <i class="fas fa-volume-up"></i> </button>
        <button id="timer-toggle-button" class="settings-icon-button" title="Toggle Turn Timer"> <i class="fas fa-clock"></i> </button>
        <button id="undo-button" class="settings-icon-button" title="Undo Move" disabled> <i class="fas fa-undo"></i> </button>
        <button id="hint-button" class="settings-icon-button" title="Hint"> <i class="fas fa-lightbulb"></i> </button>
        <button id="change-board-button" class="settings-icon-button" title="Change Board Design"> <i class="fas fa-chess-board"></i> </button>
        <button id="change-piece-style-button" class="settings-icon-button" title="Change Piece Style"> <i class="fas fa-puzzle-piece"></i> </button>
        <button id="logout-button" class="settings-icon-button" title="Back to Main Menu"> <i class="fas fa-sign-out-alt"></i> </button>
    </div>

    <!-- Start Screen -->
    <div id="start-screen">
        <h1 id="main-title">Checkers Game</h1>
        <h2 id="start-subtitle">Select Play Mode</h2>
        <div id="start-options">
            <button id="vs-human-button" class="start-button">Play vs Friend</button>
            <button id="vs-ai-button" class="start-button">Play vs Computer</button>
        </div>
    </div>

    <!-- AI Difficulty Selector -->
    <div id="ai-difficulty-selector-container">
        <button id="close-difficulty-selector" title="Close"><i class="fas fa-times"></i></button>
        <h3>Select Difficulty Level</h3>
        <div class="difficulty-control">
            <button id="difficulty-prev" class="difficulty-arrow-button" title="Previous"> <i class="fas fa-chevron-left"></i> </button>
            <span id="difficulty-display">Medium</span>
            <button id="difficulty-next" class="difficulty-arrow-button" title="Next"> <i class="fas fa-chevron-right"></i> </button>
        </div>
        <button id="confirm-difficulty-button" class="start-button">Start Game</button>
    </div>

    <!-- Game Container -->
    <div id="game-container">
        <div id="status-bar">
            <div class="status-section capture-count white">
                <i class="fas fa-chess-pawn status-icon" style="color: #eee;"></i>
                <span>Captured:</span> <span id="captured-by-black">0</span>
                <div id="white-timer" class="timer-display">--:--</div>
            </div>
            <div id="turn-indicators">
                <div id="white-indicator" class="turn-indicator"><div class="piece-visual white piece white-piece"></div></div>
                <div id="black-indicator" class="turn-indicator"><div class="piece-visual black piece black-piece"></div></div>
            </div>
            <div class="status-section capture-count black">
                <div id="black-timer" class="timer-display">--:--</div>
                <span>Captured:</span> <span id="captured-by-white">0</span>
                <i class="fas fa-chess-pawn status-icon" style="color: #444;"></i>
            </div>
        </div>
        <div id="board"></div>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen">
        <div id="game-over-content">
            <div id="game-over-message"></div>
            <button id="back-to-menu-button" class="close-selection-button">Back to Main Menu</button>
        </div>
    </div>

    <!-- Board Selection Screen -->
    <div id="board-selection-screen" class="overlay-screen">
        <div id="board-selection-content" class="selection-content">
            <h2>Choose Your Preferred Board Design</h2>
            <div id="board-options-container" class="options-container">
                <button class="board-option option-button" data-style="wood" title="Wood"><div class="board-preview board-preview-wood"><div class="sq light"></div><div class="sq dark"></div> <div class="sq dark"></div><div class="sq light"></div></div> <span>Wood</span></button>
                <button class="board-option option-button" data-style="desert" title="Desert"><div class="board-preview board-preview-desert"><div class="sq light"></div><div class="sq dark"></div> <div class="sq dark"></div><div class="sq light"></div></div> <span>Desert</span></button>
                <button class="board-option option-button" data-style="stone-path" title="Stone Path"><div class="board-preview board-preview-stone-path"><div class="sq light"></div><div class="sq dark"></div> <div class="sq dark"></div><div class="sq light"></div></div> <span>Stone Path</span></button>
                <button class="board-option option-button" data-style="emerald" title="Emerald"><div class="board-preview board-preview-emerald"><div class="sq light"></div><div class="sq dark"></div> <div class="sq dark"></div><div class="sq light"></div></div> <span>Emerald</span></button>
                <button class="board-option option-button" data-style="volcano" title="Volcano"><div class="board-preview board-preview-volcano"><div class="sq light"></div><div class="sq dark"></div> <div class="sq dark"></div><div class="sq light"></div></div> <span>Volcano</span></button>
                <button class="board-option option-button" data-style="royal" title="Royal"><div class="board-preview board-preview-royal"><div class="sq light"></div><div class="sq dark"></div> <div class="sq dark"></div><div class="sq light"></div></div> <span>Royal</span></button>
             </div>
            <button id="close-board-selection" class="close-selection-button">Close</button>
        </div>
    </div>

    <!-- Piece Style Selection Screen -->
    <div id="piece-style-selection-screen" class="overlay-screen">
        <div id="piece-style-selection-content" class="selection-content">
            <h2>Choose Your Preferred Piece Style</h2>
            <div id="piece-options-container" class="options-container">
                <button class="piece-option option-button" data-style="classic" title="Classic"><div class="piece-preview-container"><div class="piece-preview white classic"></div> <div class="piece-preview black classic"></div></div> <span>Classic</span></button>
                <button class="piece-option option-button" data-style="flat" title="Flat"><div class="piece-preview-container"><div class="piece-preview white flat"></div> <div class="piece-preview black flat"></div></div> <span>Flat</span></button>
                <button class="piece-option option-button" data-style="crimson" title="Crimson"><div class="piece-preview-container"><div class="piece-preview white crimson"></div> <div class="piece-preview black crimson"></div></div> <span>Crimson</span></button>
                <button class="piece-option option-button" data-style="azure" title="Azure"><div class="piece-preview-container"><div class="piece-preview white azure"></div> <div class="piece-preview black azure"></div></div> <span>Azure</span></button>
                <button class="piece-option option-button" data-style="forest" title="Forest"><div class="piece-preview-container"><div class="piece-preview white forest"></div> <div class="piece-preview black forest"></div></div> <span>Forest</span></button>
                <button class="piece-option option-button" data-style="royal" title="Royal"><div class="piece-preview-container"><div class="piece-preview white royal"></div> <div class="piece-preview black royal"></div></div> <span>Royal</span></button>
             </div>
            <button id="close-piece-selection" class="close-selection-button">Close</button>
        </div>
    </div>

    <!-- Confirmation Modal -->
    <div id="confirmation-modal" class="overlay-screen">
        <div id="confirmation-content" class="selection-content">
            <p id="confirmation-message">Are you sure you want to return to the main menu? Your current game progress will be lost.</p>
            <div id="confirmation-buttons">
                <button id="confirm-logout-button" class="close-selection-button">Yes, Confirm</button>
                <button id="cancel-logout-button" class="close-selection-button">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // --- Element References ---
        const bodyElement = document.body;
        const startScreen = document.getElementById('start-screen');
        const mainTitle = document.getElementById('main-title');
        const startSubtitle = document.getElementById('start-subtitle');
        const startOptions = document.getElementById('start-options');
        const vsHumanButton = document.getElementById('vs-human-button');
        const vsAiButton = document.getElementById('vs-ai-button');
        const aiDifficultySelectorContainer = document.getElementById('ai-difficulty-selector-container');
        const difficultyPrevButton = document.getElementById('difficulty-prev');
        const difficultyNextButton = document.getElementById('difficulty-next');
        const difficultyDisplay = document.getElementById('difficulty-display');
        const confirmDifficultyButton = document.getElementById('confirm-difficulty-button');
        const gameContainer = document.getElementById('game-container');
        const statusBar = document.getElementById('status-bar');
        const whiteCapturedDisplay = document.getElementById('captured-by-black');
        const blackCapturedDisplay = document.getElementById('captured-by-white');
        const whiteTimerDisplay = document.getElementById('white-timer');
        const blackTimerDisplay = document.getElementById('black-timer');
        const boardElement = document.getElementById('board');
        const whiteIndicator = document.getElementById('white-indicator');
        const blackIndicator = document.getElementById('black-indicator');
        const gameOverScreen = document.getElementById('game-over-screen');
        const gameOverMessage = document.getElementById('game-over-message');
        const backToMenuButton = document.getElementById('back-to-menu-button');
        const settingsButton = document.getElementById('settings-button');
        const settingsPanel = document.getElementById('settings-panel');
        const settingsOverlay = document.getElementById('settings-overlay');
        const soundToggleButton = document.getElementById('sound-toggle-button');
        const timerToggleButton = document.getElementById('timer-toggle-button');
        const undoButton = document.getElementById('undo-button');
        const hintButton = document.getElementById('hint-button');
        const logoutButton = document.getElementById('logout-button');
        const changeBoardButton = document.getElementById('change-board-button');
        const changePieceStyleButton = document.getElementById('change-piece-style-button');
        const boardSelectionScreen = document.getElementById('board-selection-screen');
        const boardOptionsContainer = document.getElementById('board-options-container');
        const closeBoardSelectionButton = document.getElementById('close-board-selection');
        const pieceStyleSelectionScreen = document.getElementById('piece-style-selection-screen');
        const pieceOptionsContainer = document.getElementById('piece-options-container');
        const closePieceSelectionButton = document.getElementById('close-piece-selection');
        const confirmationModal = document.getElementById('confirmation-modal');
        const confirmLogoutButton = document.getElementById('confirm-logout-button');
        const cancelLogoutButton = document.getElementById('cancel-logout-button');
        const closeDifficultySelectorButton = document.getElementById('close-difficulty-selector');
        // const rotateDeviceMessage = document.getElementById('rotate-device-message'); // Removed reference

        // --- Audio ---
        let audioCtx; function getAudioContext() { if (!audioCtx && (window.AudioContext || window.webkitAudioContext)) { try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch (e) { console.error("Web Audio API not supported", e); } } return audioCtx; }
        let isSoundEnabled = localStorage.getItem('isSoundEnabled') !== 'false';
        function playSound(type, options = {}) { if (!isSoundEnabled) return; const ctx = getAudioContext(); if (!ctx) return; if (ctx.state === 'suspended') { ctx.resume().then(() => { if (ctx.state === 'running') playSoundInternal(ctx, type, options); }).catch(e => console.error("Error resuming AudioContext:", e)); return; } if (ctx.state === 'running') { playSoundInternal(ctx, type, options); } }
        function playSoundInternal(ctx, type, options) { try { const time = ctx.currentTime; const osc = ctx.createOscillator(); const gain = ctx.createGain(); osc.connect(gain); gain.connect(ctx.destination); gain.gain.setValueAtTime(options.volume || 0.2, time); switch (type) { case 'select': osc.type = 'triangle'; osc.frequency.setValueAtTime(1500, time); gain.gain.setValueAtTime(options.volume || 0.15, time); gain.gain.linearRampToValueAtTime(0.001, time + 0.05); osc.start(time); osc.stop(time + 0.05); break; case 'move': osc.type = 'sine'; osc.frequency.setValueAtTime(600, time); osc.frequency.linearRampToValueAtTime(400, time + 0.08); gain.gain.setValueAtTime(options.volume || 0.2, time); gain.gain.linearRampToValueAtTime(0.001, time + 0.08); osc.start(time); osc.stop(time + 0.08); break; case 'capture': osc.type = 'square'; osc.frequency.setValueAtTime(500, time); gain.gain.setValueAtTime(options.volume || 0.25, time); gain.gain.exponentialRampToValueAtTime(0.001, time + 0.12); osc.start(time); osc.stop(time + 0.12); break; case 'king': osc.type = 'sine'; gain.gain.setValueAtTime(options.volume || 0.25, time); osc.frequency.setValueAtTime(880, time); osc.frequency.linearRampToValueAtTime(1318.51, time + 0.15); gain.gain.linearRampToValueAtTime(0.001, time + 0.2); osc.start(time); osc.stop(time + 0.2); break; case 'win': gain.gain.setValueAtTime(options.volume || 0.3, time); osc.frequency.setValueAtTime(523.25, time); osc.start(time); osc.stop(time + 0.15); const osc2 = ctx.createOscillator(); const gain2 = ctx.createGain(); osc2.connect(gain2); gain2.connect(ctx.destination); gain2.gain.setValueAtTime(options.volume || 0.3, time + 0.15); osc2.type = 'sine'; osc2.frequency.setValueAtTime(783.99, time + 0.15); gain2.gain.linearRampToValueAtTime(0.001, time + 0.4); osc2.start(time + 0.15); osc2.stop(time + 0.4); break; case 'undo': osc.type = 'sawtooth'; osc.frequency.setValueAtTime(300, time); osc.frequency.linearRampToValueAtTime(500, time + 0.1); gain.gain.setValueAtTime(options.volume || 0.15, time); gain.gain.linearRampToValueAtTime(0.001, time + 0.1); osc.start(time); osc.stop(time + 0.1); break; case 'hint': osc.type = 'sine'; osc.frequency.setValueAtTime(1200, time); gain.gain.setValueAtTime(options.volume || 0.1, time); gain.gain.linearRampToValueAtTime(0.001, time + 0.08); osc.start(time); osc.stop(time + 0.08); break; case 'timer_tick': osc.type = 'sine'; osc.frequency.setValueAtTime(900, time); gain.gain.setValueAtTime(options.volume || 0.05, time); gain.gain.linearRampToValueAtTime(0.001, time + 0.05); osc.start(time); osc.stop(time + 0.05); break; case 'timeout': osc.type = 'square'; osc.frequency.setValueAtTime(440, time); gain.gain.setValueAtTime(options.volume || 0.3, time); gain.gain.linearRampToValueAtTime(0.001, time + 0.3); osc.start(time); osc.stop(time + 0.3); break; default: console.warn("Unknown sound type:", type); } } catch (e) { console.error("Error playing sound:", type, e); } }

        // --- Game Constants & State ---
        const BOARD_SIZE = 8; const PLAYER_BLACK = 'black'; const PLAYER_WHITE = 'white'; const AI_PLAYER = PLAYER_WHITE;
        const DIFFICULTIES = { EASY: 'easy', MEDIUM: 'medium', HARD: 'hard' }; const MINIMAX_DEPTH = { MEDIUM: 3, HARD: 5 }; const TIMER_DURATION = 60;
        const difficultyLevels = [DIFFICULTIES.EASY, DIFFICULTIES.MEDIUM, DIFFICULTIES.HARD];
        const difficultyLabels = { easy: 'Easy', medium: 'Medium', hard: 'Hard' };
        let currentDifficultyIndex = 1;
        let chosenAiDifficulty = difficultyLevels[currentDifficultyIndex];
        let boardState = []; let currentPlayer = PLAYER_BLACK; let selectedPiece = null; let possibleMoves = []; let continuousJumpPossible = false; let gameMode = 'human'; let aiDifficulty = chosenAiDifficulty; let isAiThinking = false; let isGameOver = false; let isSettingsPanelVisible = false; let currentBoardStyle = localStorage.getItem('boardStyle') || 'wood';
        let currentPieceStyle = localStorage.getItem('pieceStyle') || 'classic';
        let capturedByBlack = 0; let capturedByWhite = 0; let moveHistory = []; let isTimerEnabled = localStorage.getItem('isTimerEnabled') === 'true'; let currentTurnTimeRemaining = TIMER_DURATION; let timerIntervalId = null; let hintTimeoutId = null;

        // --- Utility Functions ---
        function isValidSquare(row, col) { return row >= 0 && row < BOARD_SIZE && col >= 0 && col < BOARD_SIZE; }
        function deepCopyBoard(board) { return JSON.parse(JSON.stringify(board)); }
        function getOpponent(player) { return player === PLAYER_BLACK ? PLAYER_WHITE : PLAYER_BLACK; }

        // --- UI Update Functions ---
        function updateSoundButtonIcon() {
            const icon = soundToggleButton.querySelector('i');
            if (isSoundEnabled) {
                icon.classList.remove('fa-volume-mute'); icon.classList.add('fa-volume-up');
                soundToggleButton.classList.remove('sound-off'); soundToggleButton.title = "Toggle Sound (On)";
            } else {
                icon.classList.remove('fa-volume-up'); icon.classList.add('fa-volume-mute');
                soundToggleButton.classList.add('sound-off'); soundToggleButton.title = "Toggle Sound (Off)";
            }
        }
        function updateTimerButtonIcon() {
            const icon = timerToggleButton.querySelector('i');
            if (isTimerEnabled) {
                icon.classList.remove('fa-stopwatch'); icon.classList.add('fa-clock');
                timerToggleButton.classList.remove('timer-off'); timerToggleButton.title = "Toggle Turn Timer (On)";
            } else {
                icon.classList.remove('fa-clock'); icon.classList.add('fa-stopwatch');
                timerToggleButton.classList.add('timer-off'); timerToggleButton.title = "Toggle Turn Timer (Off)";
            }
        }
        function updateTurnIndicatorVisuals() { const whiteVisual = whiteIndicator.querySelector('.piece-visual'); const blackVisual = blackIndicator.querySelector('.piece-visual'); whiteVisual.style = ''; blackVisual.style = ''; whiteVisual.className = `piece-visual white piece white-piece`; blackVisual.className = `piece-visual black piece black-piece`; }
        function updateCapturedCounters() { whiteCapturedDisplay.textContent = capturedByBlack; blackCapturedDisplay.textContent = capturedByWhite; }
        function updateUndoButton() { undoButton.disabled = moveHistory.length === 0 || isAiThinking || isGameOver || (gameMode === 'ai' && currentPlayer !== AI_PLAYER && moveHistory.length < 1); }
        function updateHintButton() { hintButton.disabled = isAiThinking || isGameOver || (gameMode === 'ai' && currentPlayer === AI_PLAYER); }
        function formatTime(seconds) { if (seconds < 0) seconds = 0; const mins = Math.floor(seconds / 60); const secs = seconds % 60; return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`; }
        function updateTimerDisplay() { if (!isTimerEnabled) { whiteTimerDisplay.textContent = '--:--'; blackTimerDisplay.textContent = '--:--'; return; } const display = currentPlayer === PLAYER_WHITE ? whiteTimerDisplay : blackTimerDisplay; const otherDisplay = currentPlayer === PLAYER_WHITE ? blackTimerDisplay : whiteTimerDisplay; display.textContent = formatTime(currentTurnTimeRemaining); otherDisplay.textContent = formatTime(TIMER_DURATION); }
        function updateDifficultySelectorDisplay() { chosenAiDifficulty = difficultyLevels[currentDifficultyIndex]; difficultyDisplay.textContent = difficultyLabels[chosenAiDifficulty]; }

        // --- Timer Logic ---
        function stopTurnTimer() { if (timerIntervalId) { clearInterval(timerIntervalId); timerIntervalId = null; } }
        function startTurnTimer() { stopTurnTimer(); if (!isTimerEnabled || isGameOver) { updateTimerDisplay(); return; } currentTurnTimeRemaining = TIMER_DURATION; updateTimerDisplay(); timerIntervalId = setInterval(() => { currentTurnTimeRemaining--; updateTimerDisplay(); if (currentTurnTimeRemaining <= 5 && currentTurnTimeRemaining > 0) { playSound('timer_tick', { volume: 0.1 }); } if (currentTurnTimeRemaining <= 0) { handleTimeout(); } }, 1000); }
        function handleTimeout() {
            stopTurnTimer(); if (isGameOver) return; playSound('timeout');
            const winner = getOpponent(currentPlayer); const winnerText = winner === PLAYER_BLACK ? "Black" : "White";
            endGame(`${winnerText} Wins (Opponent ran out of time)!`);
        }

        // --- Game Flow Functions ---
        function initGame() {
            stopTurnTimer(); isGameOver = false; gameOverScreen.classList.remove('visible');
            settingsOverlay.style.display = 'none'; document.querySelectorAll('.dark-square').forEach(sq => { sq.style.cursor = 'pointer'; });
            boardState = createInitialBoardState(); currentPlayer = PLAYER_BLACK; selectedPiece = null; possibleMoves = []; continuousJumpPossible = false;
            isAiThinking = false; isSettingsPanelVisible = false; settingsPanel.classList.remove('visible');
            boardSelectionScreen.classList.remove('visible'); pieceStyleSelectionScreen.classList.remove('visible'); confirmationModal.classList.remove('visible');
            capturedByBlack = 0; capturedByWhite = 0; moveHistory = [];
            loadBoardStyle(); loadPieceStyle(); updateTurnIndicatorVisuals(); createBoardUI(); renderBoard(); updateStatus(); updateCapturedCounters();
            updateUndoButton(); updateHintButton(); settingsButton.style.display = 'block'; startTurnTimer();
        }
        function startGame(mode) {
            playSound('select', { volume: 0.4 }); gameMode = mode;
            if (gameMode === 'human') {
                aiDifficulty = DIFFICULTIES.EASY; startScreen.classList.add('hidden-completely');
                aiDifficultySelectorContainer.classList.remove('visible'); gameContainer.style.display = 'flex'; initGame();
            } else { showDifficultySelector(); }
        }
        function startAiGame() {
            playSound('select', { volume: 0.4 }); gameMode = 'ai'; aiDifficulty = chosenAiDifficulty;
            startScreen.classList.add('hidden-completely'); aiDifficultySelectorContainer.classList.remove('visible');
            gameContainer.style.display = 'flex'; settingsButton.style.display = 'block'; initGame();
        }
        function returnToStartScreen() {
            playSound('select'); stopTurnTimer(); gameOverScreen.classList.remove('visible'); gameContainer.style.display = 'none';
            startScreen.classList.remove('hidden-completely'); aiDifficultySelectorContainer.classList.remove('visible');
            settingsButton.style.display = 'none'; settingsPanel.classList.remove('visible'); settingsOverlay.style.display = 'none';
            isSettingsPanelVisible = false; boardState = []; currentPlayer = PLAYER_BLACK; selectedPiece = null; possibleMoves = []; continuousJumpPossible = false; isAiThinking = false;
            isGameOver = true; capturedByBlack = 0; capturedByWhite = 0; moveHistory = [];
            whiteIndicator.classList.remove('active-turn'); blackIndicator.classList.remove('active-turn');
            updateStatus(""); updateCapturedCounters(); updateUndoButton(); updateHintButton(); updateTimerDisplay();
            // Ensure start screen elements are visible for the fade-in animation if needed
            mainTitle.style.opacity = 1; // Or 0 if animation should replay
            startSubtitle.style.opacity = 1; // Or 0
            startOptions.style.opacity = 1; // Or 0
            startSubtitle.textContent = "Select Play Mode";
        }
        function endGame(message) {
            if (isGameOver) return; isGameOver = true; stopTurnTimer(); playSound('win'); isAiThinking = false;
            gameOverMessage.textContent = message; gameOverScreen.classList.add('visible');
            settingsButton.style.display = 'none'; settingsPanel.classList.remove('visible'); settingsOverlay.style.display = 'none';
            boardSelectionScreen.classList.remove('visible'); pieceStyleSelectionScreen.classList.remove('visible'); confirmationModal.classList.remove('visible');
            updateStatus(); updateUndoButton(); updateHintButton(); renderBoard();
        }

        // --- Modal/Overlay Functions ---
        function showConfirmationModal() { if (isGameOver) return; stopTurnTimer(); settingsPanel.classList.remove('visible'); settingsOverlay.style.display = 'none'; isSettingsPanelVisible = false; confirmationModal.classList.add('visible'); renderBoard(); }
        function hideConfirmationModal() { confirmationModal.classList.remove('visible'); if (!isGameOver && !isSettingsPanelVisible) { startTurnTimer(); } renderBoard(); }
        function showOverlay(overlayElement) { if (isGameOver) return; stopTurnTimer(); settingsPanel.classList.remove('visible'); settingsOverlay.style.display = 'none'; isSettingsPanelVisible = false; overlayElement.classList.add('visible'); renderBoard(); }
        function hideOverlay(overlayElement) { overlayElement.classList.remove('visible'); if (!isGameOver && !isSettingsPanelVisible) { startTurnTimer(); } renderBoard(); }

        // --- Event Listeners ---
        vsHumanButton.addEventListener('click', () => startGame('human'));
        vsAiButton.addEventListener('click', () => { playSound('select'); showDifficultySelector(); });
        difficultyPrevButton.addEventListener('click', () => { playSound('select', {volume: 0.1}); currentDifficultyIndex = (currentDifficultyIndex - 1 + difficultyLevels.length) % difficultyLevels.length; updateDifficultySelectorDisplay(); });
        difficultyNextButton.addEventListener('click', () => { playSound('select', {volume: 0.1}); currentDifficultyIndex = (currentDifficultyIndex + 1) % difficultyLevels.length; updateDifficultySelectorDisplay(); });
        confirmDifficultyButton.addEventListener('click', startAiGame);
        closeDifficultySelectorButton.addEventListener('click', () => {
             playSound('select'); aiDifficultySelectorContainer.classList.remove('visible'); startScreen.classList.remove('hidden-completely');
        });
        function showDifficultySelector() {
            startScreen.classList.add('hidden-completely'); aiDifficultySelectorContainer.classList.add('visible'); updateDifficultySelectorDisplay();
        }
        backToMenuButton.addEventListener('click', returnToStartScreen);
        logoutButton.addEventListener('click', () => { playSound('select'); showConfirmationModal(); });
        confirmLogoutButton.addEventListener('click', () => { playSound('select'); hideConfirmationModal(); returnToStartScreen(); });
        cancelLogoutButton.addEventListener('click', () => { playSound('select'); hideConfirmationModal(); });
        confirmationModal.addEventListener('click', (event) => { if (event.target === confirmationModal) { playSound('select'); hideConfirmationModal(); } });
        settingsButton.addEventListener('click', () => { playSound('select'); isSettingsPanelVisible = !isSettingsPanelVisible; if (isSettingsPanelVisible && !isGameOver) { stopTurnTimer(); settingsPanel.classList.add('visible'); settingsOverlay.style.display = 'block'; boardSelectionScreen.classList.remove('visible'); pieceStyleSelectionScreen.classList.remove('visible'); confirmationModal.classList.remove('visible'); } else { if (!isGameOver) startTurnTimer(); settingsPanel.classList.remove('visible'); settingsOverlay.style.display = 'none'; } renderBoard(); });
        settingsOverlay.addEventListener('click', () => { if(isSettingsPanelVisible) { playSound('select'); isSettingsPanelVisible = false; settingsPanel.classList.remove('visible'); settingsOverlay.style.display = 'none'; if (!isGameOver) startTurnTimer(); renderBoard(); } });
        soundToggleButton.addEventListener('click', () => { isSoundEnabled = !isSoundEnabled; localStorage.setItem('isSoundEnabled', isSoundEnabled); updateSoundButtonIcon(); if (isSoundEnabled) { const ctx = getAudioContext(); if (ctx && ctx.state === 'suspended') { ctx.resume(); } playSound('select', { volume: 0.4 }); } });
        timerToggleButton.addEventListener('click', () => { isTimerEnabled = !isTimerEnabled; localStorage.setItem('isTimerEnabled', isTimerEnabled); updateTimerButtonIcon(); playSound('select'); if (isTimerEnabled && !isGameOver && !isSettingsPanelVisible && !confirmationModal.classList.contains('visible')) { startTurnTimer(); } else { stopTurnTimer(); updateTimerDisplay(); } });
        undoButton.addEventListener('click', () => { if (!undoButton.disabled) { playSound('undo'); undoMove(); } });
        hintButton.addEventListener('click', () => { if (!hintButton.disabled) { playSound('hint'); showHint(); } });
        changeBoardButton.addEventListener('click', () => { playSound('select'); updateSelectedBoardOption(); showOverlay(boardSelectionScreen); });
        changePieceStyleButton.addEventListener('click', () => { playSound('select'); updateSelectedPieceOption(); showOverlay(pieceStyleSelectionScreen); });
        closeBoardSelectionButton.addEventListener('click', () => { playSound('select'); hideOverlay(boardSelectionScreen); });
        closePieceSelectionButton.addEventListener('click', () => { playSound('select'); hideOverlay(pieceStyleSelectionScreen); });
        boardOptionsContainer.addEventListener('click', (event) => { const targetOption = event.target.closest('.board-option'); if (targetOption) { const selectedStyle = targetOption.dataset.style; if (selectedStyle && selectedStyle !== currentBoardStyle) { applyBoardStyle(selectedStyle); playSound('select'); } updateSelectedBoardOption(); } });
        pieceOptionsContainer.addEventListener('click', (event) => { const targetOption = event.target.closest('.piece-option'); if (targetOption) { const selectedStyle = targetOption.dataset.style; if (selectedStyle && selectedStyle !== currentPieceStyle) { applyPieceStyle(selectedStyle); playSound('select'); } updateSelectedPieceOption(); } });

        // --- Board Setup and Rendering ---
        function createInitialBoardState() { const state = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(null)); for (let r = 0; r < BOARD_SIZE; r++) { for (let c = 0; c < BOARD_SIZE; c++) { if ((r + c) % 2 !== 0) { if (r < 3) { state[r][c] = { player: PLAYER_WHITE, isKing: false }; } else if (r > 4) { state[r][c] = { player: PLAYER_BLACK, isKing: false }; } } } } return state; }
        function createBoardUI() { boardElement.innerHTML = ''; const squareSize = parseFloat(getComputedStyle(boardElement).getPropertyValue('--square-size')); for (let r = 0; r < BOARD_SIZE; r++) { for (let c = 0; c < BOARD_SIZE; c++) { const sq = document.createElement('div'); sq.classList.add('square', (r + c) % 2 === 0 ? 'light-square' : 'dark-square'); sq.dataset.row = r; sq.dataset.col = c; /* Removed x,y dataset as they are not used for positioning */ if ((r + c) % 2 !== 0) { sq.addEventListener('click', handleSquareClick); } boardElement.appendChild(sq); } } }
        function getSquareElement(row, col) { if (!isValidSquare(row, col)) return null; return boardElement.querySelector(`.square[data-row="${row}"][data-col="${col}"]`); }
        let renderTimeout; function requestRender() { clearTimeout(renderTimeout); renderTimeout = setTimeout(renderBoard, 0); }
        function renderBoard() {
            clearHintHighlights();
            // Check if any overlay/panel is open that blocks interaction
            const isAnyOverlayOpen = isSettingsPanelVisible || boardSelectionScreen.classList.contains('visible') || pieceStyleSelectionScreen.classList.contains('visible') || confirmationModal.classList.contains('visible');
            const isInteractionBlocked = isGameOver || isAiThinking || isAnyOverlayOpen || (gameMode === 'ai' && currentPlayer === AI_PLAYER);

            const allSquares = boardElement.querySelectorAll('.square');
            allSquares.forEach(sq => {
                sq.classList.remove('possible-move', 'drag-target'); // Also remove drag-target highlight
                const isDarkSquare = sq.classList.contains('dark-square');
                // Cursor should be default if game is over or interaction is blocked by AI/overlays
                // Otherwise, pointer for dark squares if they are potential move targets (handled below) or the piece itself if it's interactive.
                sq.style.cursor = 'default'; // Default cursor, will be overridden below
                const existingPiece = sq.querySelector('.piece');
                if (existingPiece && !existingPiece.classList.contains('moving')) {
                    // Clean up pieces that might be visually rendered but not in state (edge case)
                    // This is typically handled by removing elements before rendering in createBoardUI
                    // but good to be defensive.
                    // existingPiece.remove(); // Removed - createBoardUI rebuilds the board, this is likely redundant here.
                }
            });

            const allPossibleJumps = !isInteractionBlocked ? getAllPossibleMoves(currentPlayer, true, boardState) : [];
            const jumpIsPossibleAnywhere = allPossibleJumps.length > 0;

            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const pieceData = boardState[r][c];
                    const square = getSquareElement(r, c);
                    if (pieceData && square) {
                        let pieceEl = square.querySelector(`.piece[data-piece-id="${r}-${c}"]`);
                        if (!pieceEl) {
                            // This should only happen if the board UI is completely rebuilt (e.g., createBoardUI)
                            // and renderBoard is called afterwards, or during drag-and-drop re-parenting.
                            pieceEl = document.createElement('div');
                            pieceEl.dataset.pieceId = `${r}-${c}`;
                            pieceEl.className = `piece ${pieceData.player}-piece ${pieceData.isKing ? 'king' : ''}`;
                            pieceEl.style.transform = `translate(-50%, -50%)`; // Default centered position
                            square.appendChild(pieceEl);
                             // Re-attach drag listeners to the new/re-added piece elements if needed.
                             // Event delegation on boardElement handles this already.
                        } else {
                            // Update classes if piece state changed (e.g., became king)
                             pieceEl.className = `piece ${pieceData.player}-piece ${pieceData.isKing ? 'king' : ''}`;
                        }

                        // Determine if the piece can be interacted with (clicked/dragged)
                        const canInteractPiece = !isInteractionBlocked && pieceData.player === currentPlayer && !(continuousJumpPossible && selectedPiece && (selectedPiece.row !== r || selectedPiece.col !== c));

                        pieceEl.classList.toggle('interactive', canInteractPiece);
                        pieceEl.style.pointerEvents = canInteractPiece ? 'auto' : 'none'; // Control pointer events

                        // Set cursor based on interactivity
                        pieceEl.style.cursor = canInteractPiece ? 'grab' : 'default';

                        // Add click handler only if interactive
                        // Note: Drag/Drop uses delegation, so click might be redundant or need careful handling vs touch/drag
                        // Keeping original click logic for potentially non-touchpad setups or secondary click method
                         pieceEl.onclick = canInteractPiece ? (e) => { e.stopPropagation(); handlePieceClick(e); } : null;


                        // Hint highlight
                        pieceEl.classList.remove('jump-hint');
                        if (jumpIsPossibleAnywhere && !continuousJumpPossible && pieceData.player === currentPlayer) {
                            const thisPieceCanJump = allPossibleJumps.some(jump => jump.origin.r === r && jump.origin.c === c);
                            if (thisPieceCanJump) {
                                pieceEl.classList.add('jump-hint');
                            }
                        }

                        // Selected state
                        pieceEl.classList.toggle('selected', selectedPiece && selectedPiece.row === r && selectedPiece.col === c);
                        if(selectedPiece && selectedPiece.row === r && selectedPiece.col === c){
                            selectedPiece.element = pieceEl; // Update selected piece element reference
                        }
                    }
                }
            }

            // Highlight possible move squares for the selected piece
            if (selectedPiece && !isInteractionBlocked) {
                const movesToHighlight = continuousJumpPossible
                    ? calculateMovesForPieceInternal(selectedPiece.row, selectedPiece.col, true, boardState)
                    : calculateMovesForPieceInternal(selectedPiece.row, selectedCol, false, boardState); // Use internal function consistently

                movesToHighlight.forEach(move => {
                    const sq = getSquareElement(move.row, move.col);
                    if (sq) {
                        sq.classList.add('possible-move');
                        // Ensure dark squares are clickable if they are possible moves
                        sq.style.cursor = 'pointer';
                    }
                });
            }

            // Add hover effects for clickable pieces/squares if not blocked
            if (!isInteractionBlocked) {
                addHoverEffects();
            } else {
                removeHoverEffects();
                // Ensure dark squares without pieces lose pointer cursor if blocked
                 allSquares.forEach(sq => {
                    if (sq.classList.contains('dark-square') && !sq.querySelector('.piece')) {
                         sq.style.cursor = 'default';
                    }
                 });
            }

            // Update drag-related styles if dragging is active
            if (currentDraggingPiece) {
                 // Ensure the piece being dragged remains visible and styled
                 // Its position is handled by moveDrag
                 currentDraggingPiece.classList.add('dragging');
                 // Add drag-target class to the square under the cursor in moveDrag
            }
        }


        // --- Board & Piece Style Functions ---
        function applyBoardStyle(styleName) {
            const validStyles = ['wood', 'desert', 'stone-path', 'emerald', 'volcano', 'royal'];
            if (!validStyles.includes(styleName)) styleName = 'wood';
            const allPossibleStyles = ['classic', 'modern', 'wood', 'marble', 'minimal', 'stone', 'forest', 'ice', 'dark', 'desert', 'ocean', 'stone-path', 'emerald', 'volcano', 'royal'];
            boardElement.classList.remove(...allPossibleStyles.map(s => `board-style-${s}`));
            boardElement.classList.add(`board-style-${styleName}`);
            currentBoardStyle = styleName;
            localStorage.setItem('boardStyle', styleName);
        }
        function updateSelectedBoardOption() { const options = boardOptionsContainer.querySelectorAll('.board-option'); options.forEach(option => { option.classList.toggle('selected-style', option.dataset.style === currentBoardStyle); }); }
        function loadBoardStyle() {
            let loadedStyle = localStorage.getItem('boardStyle') || 'wood';
            const validStyles = ['wood', 'desert', 'stone-path', 'emerald', 'volcano', 'royal'];
            if (!validStyles.includes(loadedStyle)) { loadedStyle = 'wood'; localStorage.setItem('boardStyle', loadedStyle); }
            applyBoardStyle(loadedStyle);
        }
        function applyPieceStyle(styleName) {
            const validStyles = ['classic', 'flat', 'crimson', 'azure', 'forest', 'royal'];
            if (!validStyles.includes(styleName)) styleName = 'classic';
            const allPossibleStyles = ['classic', 'flat', 'glossy', 'wood', 'metal', 'gemstone', 'stone', 'simple', 'marble', 'neon', 'glass', 'crimson', 'azure', 'forest', 'royal'];
            bodyElement.classList.remove(...allPossibleStyles.map(s => `piece-style-${s}`));
            bodyElement.classList.add(`piece-style-${styleName}`);
            currentPieceStyle = styleName;
            localStorage.setItem('pieceStyle', styleName);
            updateTurnIndicatorVisuals();
            if (gameContainer.style.display === 'flex') { renderBoard(); }
        }
        function updateSelectedPieceOption() { const options = pieceOptionsContainer.querySelectorAll('.piece-option'); options.forEach(option => { option.classList.toggle('selected-style', option.dataset.style === currentPieceStyle); }); }
        function loadPieceStyle() {
            let loadedStyle = localStorage.getItem('pieceStyle') || 'classic';
            const validStyles = ['classic', 'flat', 'crimson', 'azure', 'forest', 'royal'];
            if (!validStyles.includes(loadedStyle)) { loadedStyle = 'classic'; localStorage.setItem('pieceStyle', loadedStyle); }
            applyPieceStyle(loadedStyle);
        }

        // --- Game Logic ---
         function handlePieceClick(event) {
             const pieceElement = event.target.closest('.piece');
             const squareElement = pieceElement?.closest('.square');
             if (!squareElement || !pieceElement) return; // Ensure elements exist

             const row = parseInt(squareElement.dataset.row);
             const col = parseInt(squareElement.dataset.col);

             // Re-check interaction blocked state
             const isAnyOverlayOpen = isSettingsPanelVisible || boardSelectionScreen.classList.contains('visible') || pieceStyleSelectionScreen.classList.contains('visible') || confirmationModal.classList.contains('visible');
             const isInteractionBlocked = isGameOver || isAiThinking || isAnyOverlayOpen || (gameMode === 'ai' && currentPlayer === AI_PLAYER);
             if (isInteractionBlocked) return;

             const pieceData = boardState[row][col];

             if (!pieceData || pieceData.player !== currentPlayer) {
                  // Should not happen if click handler is only attached to interactive pieces, but safety check
                 deselectPiece(); // Deselect if clicking something not own piece
                 return;
             }

             // Handle continuous jump constraint
             if (continuousJumpPossible && selectedPiece && (selectedPiece.row !== row || selectedPiece.col !== col)) {
                  // If continuous jump is required and a different piece is clicked, ignore
                  return;
             }

             // Toggle selection
             if (selectedPiece && selectedPiece.row === row && selectedPiece.col === col) {
                 deselectPiece(); // Deselect if already selected
             } else {
                 // Only select if this piece has valid moves (including jumps if required)
                 const movesForThisPiece = calculateMovesForPieceInternal(row, col, continuousJumpPossible, boardState);
                 if (movesForThisPiece.length > 0) {
                      selectPiece(row, col, pieceElement);
                 } else {
                     // If clicked piece has no valid moves (but belongs to current player), deselect any previous selection
                     deselectPiece();
                 }
             }
         }

         function handleSquareClick(event) {
             const targetSquare = event.target.closest('.square');
             if (!targetSquare || !targetSquare.classList.contains('dark-square')) return; // Only interact with dark squares

             // Re-check interaction blocked state
             const isAnyOverlayOpen = isSettingsPanelVisible || boardSelectionScreen.classList.contains('visible') || pieceStyleSelectionScreen.classList.contains('visible') || confirmationModal.classList.contains('visible');
             const isInteractionBlocked = isGameOver || isAiThinking || isAnyOverlayOpen || (gameMode === 'ai' && currentPlayer === AI_PLAYER);
             if (isInteractionBlocked) return;

             const row = parseInt(targetSquare.dataset.row);
             const col = parseInt(targetSquare.dataset.col);

             // If a piece is selected, attempt to move it to this square
             if (selectedPiece && !boardState[row][col]) { // Ensure target square is empty
                 let move = null;
                 // Determine if the clicked square is a valid possible move for the selected piece
                 const movesForSelectedPiece = calculateMovesForPieceInternal(selectedPiece.row, selectedPiece.col, continuousJumpPossible, boardState);
                 move = movesForSelectedPiece.find(m => m.row === row && m.col === col);

                 if (move) {
                     saveCurrentStateToHistory(); // Save state before move
                     animateAndMovePiece(selectedPiece.row, selectedPiece.col, move);
                 } else {
                     // If not a valid move, deselect the piece unless a continuous jump is required
                     if (!continuousJumpPossible) {
                          deselectPiece();
                     } else {
                         // If continuous jump is required and they clicked an invalid square, do nothing,
                         // the piece remains selected and valid jumps are highlighted.
                         // Optional: Provide feedback that the move is invalid.
                     }
                 }
             } else {
                 // If no piece is selected, or clicking a square with a piece on it, deselect any current selection.
                 // Clicking own piece with a piece already there is handled by handlePieceClick.
                 // Clicking opponent piece or empty light square does nothing.
                 // Clicking an empty dark square with no piece selected also does nothing.
                  deselectPiece();
             }
         }

        // calculateMovesForPiece was split into internal and external for AI/Hint logic. Keeping both.
        function calculateMovesForPiece(r, c, onlyJumps = false, currentBoard = boardState) {
             // This version might be used externally (AI, Hint)
             // The internal version is used for core game logic
            return calculateMovesForPieceInternal(r, c, onlyJumps, currentBoard);
         }

        function calculateMovesForPieceInternal(r, c, onlyJumps, currentBoard) {
             const piece = currentBoard[r]?.[c];
             if (!piece) return [];

             let moves = [];
             const directions = [];
             const playerDirection = (piece.player === PLAYER_BLACK) ? -1 : 1; // -1 for black (moves up), 1 for white (moves down)

             // Regular moves
             if (!onlyJumps) {
                 directions.push(playerDirection); // Allow moving in the piece's forward direction
                 if (piece.isKing) {
                     directions.push(-playerDirection); // Kings can move backward
                 }
                 for (const dir of directions) {
                     for (const dc of [-1, 1]) { // Left and Right diagonals
                         const nr = r + dir;
                         const nc = c + dc;
                         if (isValidSquare(nr, nc) && !currentBoard[nr][nc]) {
                             moves.push({ row: nr, col: nc, isJump: false, origin: { r, c } });
                         }
                     }
                 }
                 directions.pop(); // Remove backward direction for jump calculation if added
                 if (piece.isKing) directions.push(-playerDirection); // Restore for jump check
             }


             // Jump moves (checked for both regular pieces and kings in all allowed directions)
             directions.length = 0; // Clear directions for jump check
             directions.push(playerDirection);
             if(piece.isKing) directions.push(-playerDirection); // Kings can jump backward

             let jumpMovesFound = [];

             for (const dir of directions) {
                  for (const dc of [-1, 1]) { // Left and Right diagonals
                      const jumpedPieceRow = r + dir;
                      const jumpedPieceCol = c + dc;
                      const jumpLandingRow = r + dir * 2;
                      const jumpLandingCol = c + dc * 2;

                       // Check if landing square is valid and empty
                       if (isValidSquare(jumpLandingRow, jumpLandingCol) && !currentBoard[jumpLandingRow][jumpLandingCol]) {
                           // Check if the jumped square is valid and contains an opponent piece
                           const jumpedPiece = isValidSquare(jumpedPieceRow, jumpedPieceCol) ? currentBoard[jumpedPieceRow][jumpedPieceCol] : null;
                           if (jumpedPiece && jumpedPiece.player !== piece.player) {
                                jumpMovesFound.push({ row: jumpLandingRow, col: jumpLandingCol, isJump: true, captured: { row: jumpedPieceRow, col: jumpedPieceCol }, origin: { r, c } });
                           }
                       }
                  }
             }

             // If only jumps are requested, return only jumps.
             // Otherwise, return jumps + regular moves, prioritizing jumps if any exist.
             if (onlyJumps) {
                 return jumpMovesFound;
             } else {
                 // Check if any jumps are possible on the board for the current player
                 const allPossibleJumps = getAllPossibleMoves(piece.player, true, currentBoard);
                 const jumpIsPossibleAnywhere = allPossibleJumps.length > 0;

                 // If jumps are possible anywhere on the board for this player's turn,
                 // only allow jumps for *this* piece if it can jump.
                 if (jumpIsPossibleAnywhere) {
                     // Filter the moves for the current piece to only include jumps
                      const thisPieceJumps = jumpMovesFound; // Already calculated above
                      return thisPieceJumps; // Return only jumps for this specific piece
                 } else {
                     // If no jumps are possible anywhere, allow regular moves for this piece
                     return moves; // 'moves' currently contains both jumps and regular moves
                 }
             }
         }


        function getAllPossibleMoves(player, onlyJumps = false, currentBoard = boardState) {
             let allMoves = [];
             let allJumpsFoundAcrossBoard = false; // Flag to see if any jump is possible at all

             // First pass: Check if ANY jump is possible for the current player on the board
             for (let r = 0; r < BOARD_SIZE; r++) {
                 for (let c = 0; c < BOARD_SIZE; c++) {
                     const piece = currentBoard[r][c];
                     if (piece && piece.player === player) {
                         const jumpsForPiece = calculateMovesForPieceInternal(r, c, true, currentBoard);
                         if (jumpsForPiece.length > 0) {
                             allJumpsFoundAcrossBoard = true;
                             if (onlyJumps) {
                                 // If we only want jumps, add them now
                                 allMoves.push(...jumpsForPiece);
                             }
                         }
                     }
                 }
             }

             // Second pass: If jumps were found anywhere, and onlyJumps is false, only add jumps.
             // If no jumps were found anywhere, add regular moves.
             if (allJumpsFoundAcrossBoard && !onlyJumps) {
                  allMoves = []; // Clear if we were adding jumps in the first pass for onlyJumps=true
                 for (let r = 0; r < BOARD_SIZE; r++) {
                     for (let c = 0; c < BOARD_SIZE; c++) {
                         const piece = currentBoard[r][c];
                         if (piece && piece.player === player) {
                             const jumpsForPiece = calculateMovesForPieceInternal(r, c, true, currentBoard);
                             allMoves.push(...jumpsForPiece); // Add only the jumps for this piece
                         }
                     }
                 }
             } else if (!allJumpsFoundAcrossBoard && !onlyJumps) {
                  // If no jumps found anywhere, add all moves (which will be only regular moves)
                  allMoves = []; // Clear if we added jumps in the first pass for onlyJumps=true
                 for (let r = 0; r < BOARD_SIZE; r++) {
                     for (let c = 0; c < BOARD_SIZE; c++) {
                         const piece = currentBoard[r][c];
                         if (piece && piece.player === player) {
                             const movesForPiece = calculateMovesForPieceInternal(r, c, false, currentBoard); // False will return jumps + regular
                              // Filter out jumps if they exist but weren't required (edge case, but defensive)
                             allMoves.push(...movesForPiece.filter(m => !m.isJump)); // Add only regular moves
                         }
                     }
                 }
             }

            return allMoves; // This will contain either all possible jumps OR all possible regular moves
         }

        function animateAndMovePiece(fromRow, fromCol, move) {
            const pieceData = boardState[fromRow][fromCol];
            // Get the piece element before state change
            const movingPieceElement = getSquareElement(fromRow, fromCol)?.querySelector(`.piece[data-piece-id="${fromRow}-${fromCol}"]`);
            const targetSquareElement = getSquareElement(move.row, move.col);

             // Check if animation is possible/needed
            if (!pieceData || !movingPieceElement || !targetSquareElement) {
                 console.warn("Skipping animation for move:", move);
                 executeMoveLogic(fromRow, fromCol, move);
                 handlePostMoveChecks(move);
                 return;
             }

            // Prepare for animation
            movingPieceElement.classList.add('moving');
            movingPieceElement.style.transition = 'transform 0.3s ease-in-out'; // Add transition property
            movingPieceElement.style.zIndex = 100; // Bring to front during animation

            // Calculate target position in viewport coordinates
            const targetRect = targetSquareElement.getBoundingClientRect();
            const currentRect = movingPieceElement.getBoundingClientRect();

            // Calculate the delta needed to move the piece's current position to the target square's center position
            const dx = (targetRect.left + targetRect.width / 2) - (currentRect.left + currentRect.width / 2);
            const dy = (targetRect.top + targetRect.height / 2) - (currentRect.top + currentRect.height / 2);

            // Apply transform relative to the piece's *current* location (which is already centered in its square)
            movingPieceElement.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;


            // Handle captured piece animation/removal
            if (move.isJump) {
                playSound('capture');
                const capturedSquare = getSquareElement(move.captured.row, move.captured.col);
                const capturedPieceEl = capturedSquare?.querySelector('.piece');
                if (capturedPieceEl) {
                    // Animate captured piece fading out
                    capturedPieceEl.classList.add('captured-fade');
                     // Actual removal happens after fade animation
                     capturedPieceEl.addEventListener('animationend', function handler() {
                          capturedPieceEl.remove();
                          capturedPieceEl.removeEventListener('animationend', handler);
                     });
                }
            } else {
                playSound('move');
            }

             // Deselect piece immediately visually, but keep selectedPiece state until animation ends
             if (selectedPiece && selectedPiece.element) {
                  selectedPiece.element.classList.remove('selected');
             }


            // After animation, update state and handle post-move checks
            movingPieceElement.addEventListener('transitionend', function handler() {
                movingPieceElement.classList.remove('moving');
                movingPieceElement.style.transition = ''; // Remove transition after animation
                movingPieceElement.style.zIndex = ''; // Reset z-index

                 // The piece element is currently in the DOM at the *old* square, but visually moved.
                 // Now, move the element to the new square in the DOM and reset its transform.
                 // This allows subsequent renders to place it correctly.
                targetSquareElement.appendChild(movingPieceElement);
                movingPieceElement.style.transform = 'translate(-50%, -50%)'; // Reset transform to be centered in the new square

                 // Update the piece ID to reflect its new position
                 movingPieceElement.dataset.pieceId = `${move.row}-${move.col}`;


                 // --- Execute Game Logic AFTER animation ---
                 // This updates the boardState array
                executeMoveLogic(fromRow, fromCol, move);

                // Check for king *after* the move has been executed in boardState
                const pieceAfterMove = boardState[move.row][move.col];
                if(pieceAfterMove?.isKing && !movingPieceElement.classList.contains('king')) {
                    movingPieceElement.classList.add('king');
                    // Play king sound if it wasn't played in executeMoveLogic's checkForKing
                    // Note: checkForKing in executeMoveLogic already plays the sound
                }


                // --- Handle Post-Move Checks ---
                // This checks for multi-jumps, ends turn, etc.
                handlePostMoveChecks(move);

                movingPieceElement.removeEventListener('transitionend', handler); // Clean up listener

                // Deselect piece state fully here, now that turn logic is handled
                 selectedPiece = null; // Deselect piece fully after the turn sequence

            });
        }


        function executeMoveLogic(fromRow, fromCol, move) {
             const pieceData = boardState[fromRow][fromCol];
             if (!pieceData) {
                  console.error("Attempted to move a non-existent piece at", fromRow, fromCol);
                 return; // Should not happen
             }

             const toRow = move.row;
             const toCol = move.col;

             // Move the piece in the board state
             boardState[toRow][toCol] = pieceData;
             boardState[fromRow][fromCol] = null;

             // Handle captured piece in the board state
             if (move.isJump && move.captured) {
                 const capR = move.captured.row;
                 const capC = move.captured.col;
                 if (isValidSquare(capR, capC) && boardState[capR][capC]) {
                     if (boardState[capR][capC].player === PLAYER_WHITE) {
                         capturedByWhite++;
                     } else {
                         capturedByBlack++;
                     }
                     boardState[capR][capC] = null; // Remove captured piece from state
                     updateCapturedCounters();
                 }
             }

             // Check for king *after* the move in state but *before* handling multi-jumps
             checkForKing(toRow, toCol);
         }

        function handlePostMoveChecks(move) {
            const toRow = move.row; const toCol = move.col;
            // The piece state at the new position should be the one that just moved
            const movedPieceData = boardState[toRow]?.[toCol];

            // Ensure the moved piece still exists (wasn't captured in a weird edge case, unlikely but defensive)
             if (!movedPieceData) {
                  endTurn(); // Something went wrong, end turn
                  return;
             }

            // Check for consecutive jumps for the piece that just moved
            if (move.isJump) {
                const nextJumps = calculateMovesForPieceInternal(toRow, toCol, true, boardState);
                if (nextJumps.length > 0) {
                    // If more jumps are possible for this piece, force the current player to continue
                    continuousJumpPossible = true;
                    // Select the piece at its new location to highlight next jump options
                    // Use requestAnimationFrame to ensure piece element is in new square first
                     requestAnimationFrame(() => {
                          const pieceElement = getSquareElement(toRow, toCol)?.querySelector('.piece');
                          if (pieceElement) {
                               selectPiece(toRow, toCol, pieceElement);
                               updateStatus("Complete the jump!");
                               requestRender(); // Rerender to show new selection and possible jumps
                               // If AI is playing and it's still their turn, trigger the next AI move
                               if (gameMode === 'ai' && currentPlayer === AI_PLAYER && !isGameOver) {
                                    isAiThinking = true;
                                    renderBoard(); // Update UI to show AI thinking state
                                    setTimeout(makeAiMove, 500 + Math.random() * 300); // Add slight delay
                               }
                          } else {
                               // Fallback if piece element not found (shouldn't happen after animation)
                               console.error("Piece element not found after jump animation.");
                               endTurn(); // End turn to prevent game freeze
                          }
                     });
                    return; // Don't end the turn yet
                }
            }

            // If no more jumps are possible (either wasn't a jump or no next jumps), end the turn
            continuousJumpPossible = false; // Clear the flag
            endTurn(); // Proceed to the next player's turn
        }

        function checkForKing(row, col) { const piece = boardState[row]?.[col]; if (!piece || piece.isKing) return false; if ((piece.player === PLAYER_BLACK && row === 0) || (piece.player === PLAYER_WHITE && row === BOARD_SIZE - 1)) { piece.isKing = true; playSound('king'); return true; } return false; }
        function endTurn() { deselectPiece(); if (checkWinCondition()) { return; } switchPlayer(); }
        function switchPlayer() { currentPlayer = getOpponent(currentPlayer); continuousJumpPossible = false; updateStatus(); startTurnTimer(); requestRender(); if (gameMode === 'ai' && currentPlayer === AI_PLAYER && !isGameOver) { isAiThinking = true; updateUndoButton(); updateHintButton(); renderBoard(); requestAnimationFrame(() => { setTimeout(makeAiMove, 1000 + Math.random() * 500); }); } else { isAiThinking = false; updateUndoButton(); updateHintButton(); } }
        function updateStatus(message = null) { whiteIndicator.classList.remove('active-turn'); blackIndicator.classList.remove('active-turn'); if (!isGameOver) { if (currentPlayer === PLAYER_WHITE) whiteIndicator.classList.add('active-turn'); else blackIndicator.classList.add('active-turn'); } if(message) console.log("Status Update:", message); }
        function checkWinCondition() {
            if (isGameOver) return true; let blackPieces = 0; let whitePieces = 0; let blackCanMove = false; let whiteCanMove = false;

            // Count pieces and check for moves for both players based on the current board state
            const currentBlackMoves = getAllPossibleMoves(PLAYER_BLACK, false, boardState);
            const currentWhiteMoves = getAllPossibleMoves(PLAYER_WHITE, false, boardState);

            blackCanMove = currentBlackMoves.length > 0;
            whiteCanMove = currentWhiteMoves.length > 0;

            for (let r = 0; r < BOARD_SIZE; r++) {
                 for (let c = 0; c < BOARD_SIZE; c++) {
                     const piece = boardState[r][c];
                     if (piece) {
                         if (piece.player === PLAYER_BLACK) blackPieces++;
                         if (piece.player === PLAYER_WHITE) whitePieces++;
                     }
                 }
             }

            let gameOverTriggered = false; let winMessage = "";

            // Win conditions:
            // 1. Opponent has no pieces left.
            // 2. Opponent has no legal moves left.
            if (whitePieces === 0) { winMessage = "Black Wins (No White pieces left)!"; gameOverTriggered = true; }
            else if (blackPieces === 0) { winMessage = "White Wins (No Black pieces left)!"; gameOverTriggered = true; }
            // Check if the *current player* has no moves (meaning the *other* player wins)
            else if (currentPlayer === PLAYER_BLACK && !blackCanMove) { winMessage = "White Wins (Black has no moves)!"; gameOverTriggered = true; }
            else if (currentPlayer === PLAYER_WHITE && !whiteCanMove) { winMessage = "Black Wins (White has no moves)!"; gameOverTriggered = true; }

            if (gameOverTriggered) { endGame(winMessage); return true; }
            return false;
        }
        function saveCurrentStateToHistory() { const stateToSave = { boardState: deepCopyBoard(boardState), currentPlayer: currentPlayer, capturedByBlack: capturedByBlack, capturedByWhite: capturedByWhite, continuousJumpPossible: continuousJumpPossible, }; moveHistory.push(stateToSave); updateUndoButton(); }
        function undoMove() { if (moveHistory.length === 0 || isAiThinking) return; stopTurnTimer(); const previousState = moveHistory.pop(); boardState = previousState.boardState; currentPlayer = previousState.currentPlayer; capturedByBlack = previousState.capturedByBlack; capturedByWhite = previousState.capturedByWhite; continuousJumpPossible = previousState.continuousJumpPossible; selectedPiece = null; isGameOver = false; gameOverScreen.classList.remove('visible'); updateCapturedCounters(); updateStatus(); updateUndoButton(); updateHintButton(); createBoardUI(); renderBoard(); startTurnTimer(); isAiThinking = false; }
        function clearHintHighlights() { if (hintTimeoutId) { clearTimeout(hintTimeoutId); hintTimeoutId = null; } document.querySelectorAll('.hint-piece-suggestion, .hint-move-suggestion').forEach(el => { el.classList.remove('hint-piece-suggestion', 'hint-move-suggestion'); }); document.querySelectorAll('.square.possible-move.hint-move-suggestion').forEach(sq => { sq.classList.remove('hint-move-suggestion'); }); }
        function showHint() {
             clearHintHighlights();
             const isAnyOverlayOpen = isSettingsPanelVisible || boardSelectionScreen.classList.contains('visible') || pieceStyleSelectionScreen.classList.contains('visible') || confirmationModal.classList.contains('visible');
             if (isGameOver || isAiThinking || isAnyOverlayOpen || (gameMode === 'ai' && currentPlayer === AI_PLAYER)) {
                  return; // Do not show hint if blocked
             }

            let bestHintMove;

            // For AI difficulty > EASY or if playing against AI, use minimax to find the hint
            if (gameMode === 'ai' || aiDifficulty !== DIFFICULTIES.EASY) {
                // Use the AI's logic to find the best move for the current player
                // Pass current board state and the player whose turn it is
                const aiResult = findBestMoveMinimax(currentPlayer, aiDifficulty === DIFFICULTIES.HARD ? MINIMAX_DEPTH.HARD : MINIMAX_DEPTH.MEDIUM, -Infinity, Infinity, true, currentPlayer, currentPlayer);
                bestHintMove = aiResult?.move; // Use the move suggested by minimax
             } else {
                // For Easy AI or Human vs Human, use a simpler random hint logic
                 const allPossibleJumps = getAllPossibleMoves(currentPlayer, true, boardState);
                 if (allPossibleJumps.length > 0) {
                     // Hint a random jump if jumps are possible
                     bestHintMove = allPossibleJumps[Math.floor(Math.random() * allPossibleJumps.length)];
                 } else {
                     // Otherwise, hint a random regular move
                     const regularMoves = getAllPossibleMoves(currentPlayer, false, boardState);
                     if (regularMoves.length > 0) {
                         bestHintMove = regularMoves[Math.floor(Math.random() * regularMoves.length)];
                     }
                 }
             }

            if (bestHintMove) {
                const pieceSquare = getSquareElement(bestHintMove.origin.r, bestHintMove.origin.c);
                const targetSquare = getSquareElement(bestHintMove.row, bestHintMove.col);
                const pieceElement = pieceSquare?.querySelector('.piece');

                if (pieceElement && targetSquare) {
                    pieceElement.classList.add('hint-piece-suggestion');
                    // Highlight the target square as a possible move hint
                    targetSquare.classList.add('hint-move-suggestion');
                    targetSquare.classList.add('possible-move'); // Ensure it looks like a possible move target

                    // Set a timeout to remove the highlights
                    hintTimeoutId = setTimeout(clearHintHighlights, 3000); // Hint visible for 3 seconds
                }
            } else {
                // Optional: Provide feedback if no moves are possible (should lead to game over anyway)
                 console.log("No hint available (no moves possible).");
            }
         }


        // --- AI Logic ---
        function makeAiMove() {
             // Re-check game state and turn before making move
            if (isGameOver || currentPlayer !== AI_PLAYER) {
                 isAiThinking = false; // Ensure flag is reset
                 requestRender(); // Update UI
                 return;
             }

             const allPossibleJumps = getAllPossibleMoves(AI_PLAYER, true, boardState);
             const jumpIsPossibleAnywhere = allPossibleJumps.length > 0;

            let aiMove = null;

             if (continuousJumpPossible && selectedPiece && selectedPiece.player === AI_PLAYER) {
                 // If AI is in a forced continuous jump sequence
                 const nextJumps = calculateMovesForPieceInternal(selectedPiece.row, selectedPiece.col, true, boardState);
                 if (nextJumps.length > 0) {
                      // Use minimax or just pick the first jump for simpler AIs in sequence
                      // For medium/hard, find the best next jump using minimax from current state
                      if (aiDifficulty === DIFFICULTIES.EASY) {
                         aiMove = nextJumps[0]; // Simple: pick first jump
                      } else {
                         // Minimax to choose the best *next* jump
                         const minimaxResult = findBestMoveMinimax(AI_PLAYER, 1, -Infinity, Infinity, true, AI_PLAYER, AI_PLAYER, boardState, selectedPiece); // Evaluate only one step ahead for the jump sequence
                         aiMove = minimaxResult?.move;
                      }
                 } else {
                     // Should not happen if continuousJumpPossible is true, indicates a logic error
                     console.error("AI in continuous jump state but no next jumps found!");
                     continuousJumpPossible = false; // Break out of bad state
                     isAiThinking = false;
                     endTurn(); // End AI turn
                     return;
                 }
             } else {
                 // If not in a forced jump sequence, find the best move (jump or regular)
                 const aiResult = findBestMoveMinimax(AI_PLAYER, aiDifficulty === DIFFICULTIES.HARD ? MINIMAX_DEPTH.HARD : MINIMAX_DEPTH.MEDIUM, -Infinity, Infinity, true, AI_PLAYER, AI_PLAYER, boardState);
                 aiMove = aiResult?.move;
             }

            if (aiMove) {
                saveCurrentStateToHistory(); // Save state before executing the move
                 // Before animating, update selectedPiece state for animation logic
                 const pieceElement = getSquareElement(aiMove.origin.r, aiMove.origin.c)?.querySelector('.piece');
                 selectedPiece = { row: aiMove.origin.r, col: aiMove.origin.c, player: AI_PLAYER, element: pieceElement };

                animateAndMovePiece(aiMove.origin.r, aiMove.origin.c, aiMove);

                // The post-move checks and turn ending are handled in animateAndMovePiece's transitionend callback
                // isAiThinking is reset in the endTurn() -> switchPlayer() sequence or handlePostMoveChecks for multi-jump
            } else {
                // If AI has no moves (should be caught by checkWinCondition), end turn.
                 console.warn("AI has no moves.");
                 isAiThinking = false;
                 endTurn();
            }
         }

        // Minimax implementation (needs refinement for multi-jumps)
        // currentBoard: The board state at the node being evaluated
        // depth: How many ply (half-moves) deep to search
        // alpha: Best value maximizing player can guarantee
        // beta: Best value minimizing player can guarantee
        // isMaximizingPlayer: True if it's the AI's turn in the search (maximizing), false if opponent (minimizing)
        // playerForThisNode: The player whose turn it is in the game state at this node
        // originalPlayer: The player who initiated the minimax search (the AI player)
        function minimax(currentBoard, depth, alpha, beta, isMaximizingPlayer, playerForThisNode, originalPlayer) {
            const opponentOfNodePlayer = getOpponent(playerForThisNode);

             // Base case: Check if game is over or depth is reached
            if (depth === 0 || checkGameOverSimulated(currentBoard, playerForThisNode) || checkGameOverSimulated(currentBoard, opponentOfNodePlayer)) {
                 return evaluateBoard(currentBoard, originalPlayer, depth);
             }

            let allPossibleMoves = getAllPossibleMoves(playerForThisNode, false, currentBoard);
             const possibleJumps = allPossibleMoves.filter(m => m.isJump);
             const movesToConsider = possibleJumps.length > 0 ? possibleJumps : allPossibleMoves; // Prioritize jumps

             // If no moves available for this player, the turn effectively ends or the game ends.
             // Evaluate the current state from the perspective of the *original* AI player.
             if (movesToConsider.length === 0) {
                  // If maximizing player has no moves, it's a bad state for AI.
                  // If minimizing player has no moves, it's a good state for AI (opponent is blocked).
                 return evaluateBoard(currentBoard, originalPlayer, depth);
             }


            if (isMaximizingPlayer) { // AI's turn
                 let maxEval = -Infinity;
                 for (const move of movesToConsider) {
                     const tempBoard = deepCopyBoard(currentBoard);
                     // Simulate the move, including any forced subsequent jumps for the same piece
                     const boardAfterTurn = simulateFullTurn(tempBoard, move);

                     // Recurse for the opponent's turn (minimizing)
                     const evalScore = minimax(boardAfterTurn, depth - 1, alpha, beta, false, getOpponent(playerForThisNode), originalPlayer);
                     maxEval = Math.max(maxEval, evalScore);
                     alpha = Math.max(alpha, evalEval); // Use maxEval here
                     if (beta <= alpha) {
                         break; // Beta cut-off
                     }
                 }
                 return maxEval;
             } else { // Opponent's turn (Minimizing)
                 let minEval = Infinity;
                 for (const move of movesToConsider) {
                      const tempBoard = deepCopyBoard(currentBoard);
                      // Simulate the move, including any forced subsequent jumps
                     const boardAfterTurn = simulateFullTurn(tempBoard, move);

                     // Recurse for the AI's turn (maximizing)
                     const evalScore = minimax(boardAfterTurn, depth - 1, alpha, beta, true, getOpponent(playerForThisNode), originalPlayer);
                     minEval = Math.min(minEval, evalScore);
                     beta = Math.min(beta, minEval);
                     if (beta <= alpha) {
                         break; // Alpha cut-off
                     }
                 }
                 return minEval;
             }
         }


        // Helper function to simulate a full turn including forced jumps for MINIMAX
        function simulateFullTurn(board, initialMove) {
            const tempBoard = deepCopyBoard(board);
            simulateMove(tempBoard, initialMove); // Perform the initial move
            let currentPos = { r: initialMove.row, c: initialMove.col };
            const pieceAfterInitialMove = tempBoard[currentPos.r]?.[currentPos.c];

             // Check for and perform forced jumps recursively/iteratively
             // Only continue jumping if the piece *after* the move can still jump
             if (pieceAfterInitialMove && initialMove.isJump) {
                let moreJumpsPossible = true;
                while(moreJumpsPossible) {
                    // Re-fetch piece data at the current position in the *simulated* board
                    const pieceAtCurrentPos = tempBoard[currentPos.r]?.[currentPos.c];
                    if (!pieceAtCurrentPos) {
                         moreJumpsPossible = false;
                         break; // Piece was somehow removed?
                    }
                    const nextJumps = calculateMovesForPieceInternal(currentPos.r, currentPos.c, true, tempBoard);

                    if (nextJumps.length > 0) {
                         // In simulation, pick one of the next jumps (e.g., the first)
                         // A more sophisticated AI might explore all sequences (using recursion here too)
                         const nextJump = nextJumps[0]; // Pick the first jump for simplicity in simulation
                         simulateMove(tempBoard, nextJump); // Perform the next jump
                         currentPos = { r: nextJump.row, c: nextJump.c };
                         // simulateMove should handle kinging now
                    } else {
                        moreJumpsPossible = false; // No more jumps for this piece from this position
                    }
                }
             }
         return tempBoard; // Return the board state after the full turn sequence
        }


         // Function to find the best move at the top level of the AI's turn
        function findBestMoveMinimax(player, depth, alpha, beta, isMaximizingPlayer, playerForThisNode, originalPlayer, boardStateForEvaluation = boardState, selectedPieceForEvaluation = null) {

             const currentBoard = deepCopyBoard(boardStateForEvaluation);
             let bestScore = isMaximizingPlayer ? -Infinity : Infinity;
             let bestMove = null;

             // Determine available moves for the player whose turn it is *in the simulation* (playerForThisNode)
             let movesToConsider = [];
             if (selectedPieceForEvaluation && selectedPieceForEvaluation.player === playerForThisNode && continuousJumpPossible) {
                 // If a piece is already selected for a continuous jump, only consider jumps for that piece
                 movesToConsider = calculateMovesForPieceInternal(selectedPieceForEvaluation.row, selectedPieceForEvaluation.col, true, currentBoard);
             } else {
                 // Otherwise, consider all moves (prioritizing jumps) for the playerForThisNode
                 movesToConsider = getAllPossibleMoves(playerForThisNode, false, currentBoard);
             }

             // If no moves available for this player, return null move and evaluate current state
             if (movesToConsider.length === 0) {
                  // This case should ideally be handled by checkWinCondition before calling AI,
                  // but defensive for minimax.
                 return { move: null, score: evaluateBoard(currentBoard, originalPlayer, depth) };
             }

             // Shuffle moves slightly to add some variability, especially at lower depths
             const shuffledMoves = movesToConsider.sort(() => 0.5 - Math.random());


             if (isMaximizingPlayer) { // AI is maximizing player
                 for (const move of shuffledMoves) {
                     const tempBoard = deepCopyBoard(currentBoard);
                     // Simulate the full turn sequence starting with this move
                     const boardAfterTurn = simulateFullTurn(tempBoard, move);

                     // Recursively call minimax for the minimizing player (opponent)
                     const evalScore = minimax(boardAfterTurn, depth - 1, alpha, beta, false, getOpponent(playerForThisNode), originalPlayer);

                     if (evalScore > bestScore) {
                         bestScore = evalScore;
                         bestMove = move; // This is the move that leads to the best score
                     }
                     alpha = Math.max(alpha, bestScore);
                     if (beta <= alpha) {
                         break; // Alpha cut-off
                     }
                 }
             } else { // Opponent is minimizing player (This branch is not needed for the *initial* call to findBestMoveMinimax,
                     // but it's used in the recursive calls *within* minimax).
                     // The initial call is always from the maximizing player's perspective.
                     // This part of the logic is handled within the recursive `minimax` function.
                     // This outer function `findBestMoveMinimax` is specifically for finding the *best move*
                     // for the initiating player (AI).
                     console.error("findBestMoveMinimax called for minimizing player?");
             }

             return { move: bestMove, score: bestScore };
         }


        function evaluateBoard(currentBoard, originalPlayer, depth = 0) {
             let score = 0;
             const opponentOfOriginalPlayer = getOpponent(originalPlayer);
             const WIN_SCORE = 10000; // Make win score very high
             const KING_VALUE = 5; // King is worth more than a regular piece
             const PIECE_VALUE = 1;
             const ADVANCEMENT_VALUE = 0.5; // Value for getting closer to the king row
             const MOBILITY_VALUE = 0.1; // Value for having more possible moves
             const CENTER_CONTROL_VALUE = 0.02; // Value for controlling center squares (optional)
             const DEFENSE_BONUS = 0.2; // Bonus for pieces on the back row (defensive position) (optional)

             let myPieces = 0, oppPieces = 0;
             let myKings = 0, oppKings = 0;
             let myTotalAdvancement = 0, oppTotalAdvancement = 0;
             let myPossibleMovesCount = 0, oppPossibleMovesCount = 0;

            // Calculate mobility only once for the current board state
             const myMoves = getAllPossibleMoves(originalPlayer, false, currentBoard);
             const oppMoves = getAllPossibleMoves(opponentOfOriginalPlayer, false, currentBoard);
             myPossibleMovesCount = myMoves.length;
             oppPossibleMovesCount = oppMoves.length;


             // Check win/loss condition *before* calculating other factors
             const myCanMove = myPossibleMovesCount > 0;
             const oppCanMove = oppPossibleMovesCount > 0;

             // Count pieces and calculate advancement/positional bonuses
             for (let r = 0; r < BOARD_SIZE; r++) {
                 for (let c = 0; c < BOARD_SIZE; c++) {
                     const piece = currentBoard[r][c];
                     if (piece) {
                         if (piece.player === originalPlayer) {
                             myPieces++;
                             if (piece.isKing) myKings++;
                             // Advancement: Distance from opponent's king row
                             myTotalAdvancement += (originalPlayer === PLAYER_WHITE ? r : (BOARD_SIZE - 1 - r));
                             // Optional: Defense bonus for back row pieces
                             if ((originalPlayer === PLAYER_WHITE && r === 0) || (originalPlayer === PLAYER_BLACK && r === BOARD_SIZE - 1)) {
                                 // score += DEFENSE_BONUS; // Add bonus directly to score or accumulate
                             }
                             // Optional: Center control
                             if (r >= 2 && r <= 5 && c >= 2 && c <= 5) { // Example center squares
                                 // score += CENTER_CONTROL_VALUE; // Add bonus directly
                             }

                         } else { // Opponent's piece
                             oppPieces++;
                             if (piece.isKing) oppKings++;
                             // Advancement: Distance from my king row
                             oppTotalAdvancement += (opponentOfOriginalPlayer === PLAYER_WHITE ? r : (BOARD_SIZE - 1 - r));
                             // Optional: Opponent defense bonus
                             if ((opponentOfOriginalPlayer === PLAYER_WHITE && r === 0) || (opponentOfOriginalPlayer === PLAYER_BLACK && r === BOARD_SIZE - 1)) {
                                 // score -= DEFENSE_BONUS; // Subtract penalty directly or accumulate
                             }
                              // Optional: Opponent Center control
                             if (r >= 2 && r <= 5 && c >= 2 && c <= 5) {
                                 // score -= CENTER_CONTROL_VALUE; // Subtract penalty
                             }
                         }
                     }
                 }
             }

             // Final Win/Loss Check based on piece count / mobility (highest priority)
             if (oppPieces === 0 || !oppCanMove) {
                 // Win: AI eliminated all opponent pieces or blocked them
                 // Add depth bonus: A win found at lower depth (closer to current state) is preferred
                 return WIN_SCORE + (depth * 100); // Higher depth value means earlier win in search=better
             }
             if (myPieces === 0 || !myCanMove) {
                 // Loss: Opponent eliminated all AI pieces or blocked AI
                 // Add depth penalty: A loss found at lower depth is worse
                 return -WIN_SCORE - (depth * 100); // Higher depth value means earlier loss in search=worse
             }

             // Piece Difference
             score += (myPieces - oppPieces) * PIECE_VALUE;
             // King Difference (kings are more valuable)
             score += (myKings - oppKings) * (KING_VALUE - PIECE_VALUE); // Add the *extra* value of kings

             // Advancement Difference
             score += (myTotalAdvancement - oppTotalAdvancement) * ADVANCEMENT_VALUE;

             // Mobility Difference
             score += (myPossibleMovesCount - oppPossibleMovesCount) * MOBILITY_VALUE;

             // Consider adding draw detection? (e.g., 50 move rule with no captures/kinging) - complex for simple AI

             return score;
         }


        function simulateMove(board, move) {
             const pieceData = board[move.origin.r]?.[move.origin.c];
             if (!pieceData) {
                  console.error("Simulating move for non-existent piece at", move.origin.r, move.origin.c);
                 return; // Should not happen in valid game state
             }

             const fromRow = move.origin.r;
             const fromCol = move.origin.c;
             const toRow = move.row;
             const toCol = move.col;

             // Move the piece in the state
             board[toRow][toCol] = pieceData;
             board[fromRow][fromCol] = null; // Clear the original square

             // Handle captured piece
             if (move.isJump && move.captured) {
                 const capR = move.captured.row;
                 const capC = move.captured.col;
                 if (isValidSquare(capR, capC)) {
                      // Don't need to track captured count in simulation, just remove piece
                     board[capR][capC] = null;
                 } else {
                     console.error("Simulating jump with invalid captured square:", capR, capC);
                 }
             }

             // Check for kinging *after* the move
             // Ensure the piece exists at the destination before checking/modifying isKing
             const pieceAtDestination = board[toRow]?.[toCol];
             if (pieceAtDestination && !pieceAtDestination.isKing) {
                 if ((pieceAtDestination.player === PLAYER_BLACK && toRow === 0) || (pieceAtDestination.player === PLAYER_WHITE && toRow === BOARD_SIZE - 1)) {
                     pieceAtDestination.isKing = true;
                 }
             }
         }

        function checkGameOverSimulated(board, playerToCheck) {
             let pieces = 0;
             let canMove = false;
             for(let r=0; r<BOARD_SIZE; r++){
                 for(let c=0; c<BOARD_SIZE; c++){
                     const piece = board[r][c];
                     if(piece?.player === playerToCheck){
                         pieces++;
                         // Check if this specific piece has any moves (regular or jump)
                         if (!canMove && calculateMovesForPieceInternal(r, c, false, board).length > 0){
                              canMove = true; // Player has at least one piece with a move
                         }
                     }
                 }
             }
             // Game over for playerToCheck if they have no pieces OR they have pieces but none can move
             return pieces === 0 || !canMove;
         }

        function addHoverEffects() {
             removeHoverEffects(); // Start fresh

             // Check if any overlay/panel is open that blocks interaction
             const isAnyOverlayOpen = isSettingsPanelVisible || boardSelectionScreen.classList.contains('visible') || pieceStyleSelectionScreen.classList.contains('visible') || confirmationModal.classList.contains('visible');
             const isInteractionBlocked = isGameOver || isAiThinking || isAnyOverlayOpen || (gameMode === 'ai' && currentPlayer === AI_PLAYER);

             if (isInteractionBlocked) {
                  // Ensure all dark squares and pieces have default cursor if blocked
                  boardElement.querySelectorAll('.square.dark-square').forEach(sq => sq.style.cursor = 'default');
                  boardElement.querySelectorAll('.piece').forEach(p => p.style.cursor = 'default');
                  return;
             }

             // Add hover effect to *interactive* pieces that can be selected
             boardElement.querySelectorAll(`.piece.interactive:not(.selected)`).forEach(piece => {
                  // Piece interactivity is already determined in renderBoard and class 'interactive' is added.
                  // Add the 'hoverable' class for the visual hover effect.
                 piece.classList.add('hoverable');
                 piece.style.cursor = 'grab'; // Indicate draggable
             });

             // Add pointer cursor to dark squares that are possible move targets *if* a piece is selected
             if (selectedPiece) {
                 const movesToHighlight = continuousJumpPossible
                    ? calculateMovesForPieceInternal(selectedPiece.row, selectedPiece.col, true, boardState)
                    : calculateMovesForPieceInternal(selectedPiece.row, selectedPiece.col, false, boardState); // Recalculate based on current state

                 movesToHighlight.forEach(move => {
                     const sq = getSquareElement(move.row, move.col);
                     if (sq) {
                          sq.style.cursor = 'pointer'; // Indicate clickable target
                     }
                 });
             } else {
                 // If no piece is selected, ensure dark squares without possible moves have default cursor
                  boardElement.querySelectorAll('.square.dark-square:not(.possible-move)').forEach(sq => {
                       // Double check if this square has a piece of the current player that *could* be selected
                       const r = parseInt(sq.dataset.row);
                       const c = parseInt(sq.dataset.col);
                       const piece = boardState[r]?.[c];
                       if (!piece || piece.player !== currentPlayer || calculateMovesForPieceInternal(r,c,false,boardState).length === 0) {
                           sq.style.cursor = 'default';
                       }
                  });
             }

              // Ensure the currently selected piece still has the grab cursor
             if (selectedPiece && selectedPiece.element && boardElement.contains(selectedPiece.element)) {
                  selectedPiece.element.style.cursor = 'grab';
             }
         }

        function removeHoverEffects() {
             document.querySelectorAll('.piece.hoverable').forEach(p => p.classList.remove('hoverable'));
             // Reset cursor on all dark squares and pieces to default or pointer based on default rules
             boardElement.querySelectorAll('.square.dark-square').forEach(sq => sq.style.cursor = 'default');
             boardElement.querySelectorAll('.piece').forEach(p => p.style.cursor = 'default');
             // renderBoard() will apply the correct cursors based on game state
             // requestRender(); // Calling renderBoard here might cause loops, rely on the next render cycle.
         }


         function selectPiece(row, col, pieceElement) {
             // Ensure pieceElement is valid before adding class
             const targetPieceEl = pieceElement || getSquareElement(row, col)?.querySelector('.piece');
             if (!targetPieceEl) {
                 console.error("Attempted to select non-existent piece element at", row, col);
                 deselectPiece(); // Ensure nothing is selected
                 return;
             }

             deselectPiece(); // Deselect any previously selected piece
             selectedPiece = { row, col, player: currentPlayer, element: targetPieceEl };
             targetPieceEl.classList.add('selected');
             requestRender(); // Rerender to show highlights for possible moves
             playSound('select');
         }


        function deselectPiece() {
             if (selectedPiece && selectedPiece.element) {
                 selectedPiece.element.classList.remove('selected');
             }
             selectedPiece = null;
             possibleMoves = []; // Clear possible moves list
             requestRender(); // Rerender to remove highlights
         }


        // --- Initialization on Load ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM Loaded. Initializing...");

            // --- Orientation Handling ---
            // Removed orientation locking and message logic (as requested)

            updateSoundButtonIcon(); updateTimerButtonIcon();
            settingsButton.style.display = 'none'; settingsPanel.classList.remove('visible');
            settingsOverlay.style.display = 'none';
            boardSelectionScreen.classList.remove('visible'); pieceStyleSelectionScreen.classList.remove('visible'); confirmationModal.classList.remove('visible');
            gameContainer.style.display = 'none'; gameOverScreen.classList.remove('visible');
            startScreen.classList.remove('hidden-completely');
            aiDifficultySelectorContainer.classList.remove('visible');
            isSettingsPanelVisible = false; isGameOver = true;
            loadBoardStyle(); loadPieceStyle();
            updateTurnIndicatorVisuals(); updateUndoButton(); updateHintButton(); updateCapturedCounters(); updateTimerDisplay();
            updateDifficultySelectorDisplay();
            console.log("Initialization Complete. Ready.");

             // Ensure the board is created and rendered even on the start screen load
             // This prevents errors if settings are accessed before a game starts.
             // However, creating the UI might not be necessary until game start.
             // Let's defer createBoardUI and renderBoard until initGame().
             // If settings are accessed before initGame(), boardElement is empty, which is fine.
        });

         // --- Drag and Drop (Keep existing logic, refined) ---
         let initialX;
         let initialY;
         let currentDraggingPiece = null;
         let currentDraggingSquare = null; // The square the piece started in
         let dragOffset = { x: 0, y: 0 };
         let dragPossibleMoves = [];
         let isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

         // Add touch-action: none only to the board element to allow scrolling elsewhere
         boardElement.style.touchAction = 'none';


         function startDrag(event) {
             // Prevent default touch behavior like scrolling *within the board*
             if (event.type === 'touchstart') {
                event.preventDefault();
             }

             // Check if interaction is allowed at all
             const isAnyOverlayOpen = isSettingsPanelVisible || boardSelectionScreen.classList.contains('visible') || pieceStyleSelectionScreen.classList.contains('visible') || confirmationModal.classList.contains('visible');
             const isInteractionBlocked = isGameOver || isAiThinking || isAnyOverlayOpen || (gameMode === 'ai' && currentPlayer === AI_PLAYER);
             if (isInteractionBlocked) {
                  // Do not start drag if blocked, allow default behavior outside board if touch-action permits
                 if (event.type === 'touchstart') {
                     // If we prevented default above, re-allow it here if drag isn't starting.
                     // This is tricky with touch-action: none on the board.
                     // The simplest is: touch-action: none prevents scroll/zoom on board.
                     // If drag isn't allowed, the touch does nothing on the piece/square.
                 }
                 return;
             }

             const pieceElement = event.target.closest('.piece');
             // Only start drag if an *interactive* piece is clicked/touched
             if (!pieceElement || !pieceElement.classList.contains('interactive')) {
                 return; // Do not start drag
             }

             currentDraggingPiece = pieceElement;
             currentDraggingSquare = currentDraggingPiece.closest('.square');

             if (!currentDraggingSquare) {
                  // Should not happen for pieces on the board
                  currentDraggingPiece = null;
                  return;
             }

             const row = parseInt(currentDraggingSquare.dataset.row);
             const col = parseInt(currentDraggingSquare.dataset.col);
             const pieceData = boardState[row][col];

             // Double check game state and piece ownership (redundant due to .interactive, but safe)
             if (!pieceData || pieceData.player !== currentPlayer || (continuousJumpPossible && selectedPiece && (selectedPiece.row !== row || selectedPiece.col !== col))) {
                  currentDraggingPiece = null; // Don't drag if it's not the correct piece/turn
                  return;
             }


             // --- Drag Start Logic ---
             // Simulate click logic: select the piece and calculate possible moves
             // Note: selectPiece will call deselectPiece and renderBoard, which updates highlights
             selectPiece(row, col, currentDraggingPiece);
             // Get the possible moves *after* selecting the piece, respecting continuousJumpPossible
             dragPossibleMoves = calculateMovesForPieceInternal(row, col, continuousJumpPossible, boardState);

             // If the piece cannot move at all (no valid targets), do not start dragging
             if (dragPossibleMoves.length === 0) {
                 deselectPiece(); // Deselect the piece if it has no moves
                 currentDraggingPiece = null;
                 currentDraggingSquare = null;
                 return;
             }


             currentDraggingPiece.classList.add('dragging');

             const rect = currentDraggingPiece.getBoundingClientRect();
             const clientX = event.type === 'touchstart' ? event.touches[0].clientX : event.clientX;
             const clientY = event.type === 'touchstart' ? event.touches[0].clientY : event.clientY;

             // Calculate the offset from the piece's top-left corner to the cursor
             dragOffset = { x: clientX - rect.left, y: clientY - rect.top };

             // Set piece to fixed position for dragging relative to viewport
             currentDraggingPiece.style.position = 'fixed';
             currentDraggingPiece.style.zIndex = 1000; // Ensure it's above other elements

             // Position the piece immediately under the cursor using the offset
             currentDraggingPiece.style.left = `${clientX - dragOffset.x}px`;
             currentDraggingPiece.style.top = `${clientY - dragOffset.y}px`;

             // The piece already has translate(-50%, -50%) for centering.
             // When fixed, this offset is relative to the viewport point (left, top).
             // To position correctly, we need to account for the original translate(-50%, -50%).
             // Let's adjust the style during drag to use direct pixel position without the translate(-50%, -50%).
             // Temporarily remove the centering transform during drag
             currentDraggingPiece.style.transform = 'none';
             currentDraggingPiece.dataset.dragOffsetX = dragOffset.x; // Store offset for moveDrag
             currentDraggingPiece.dataset.dragOffsetY = dragOffset.y;


             // Add listeners to the document body to track drag anywhere
             document.addEventListener(isTouchDevice ? 'touchmove' : 'mousemove', moveDrag);
             document.addEventListener(isTouchDevice ? 'touchend' : 'mouseup', endDrag);
         }

         function moveDrag(event) {
             if (!currentDraggingPiece) return;

             // Prevent default touch behavior (like scrolling) globally while dragging
             if (event.type === 'touchmove') {
                  event.preventDefault();
             }

             const clientX = event.type === 'touchmove' ? event.touches[0].clientX : event.clientX;
             const clientY = event.type === 'touchmove' ? event.touches[0].clientY : event.clientY;

             const offsetX = parseFloat(currentDraggingPiece.dataset.dragOffsetX);
             const offsetY = parseFloat(currentDraggingPiece.dataset.dragOffsetY);

             // Position the piece relative to the viewport, using the original offset
             currentDraggingPiece.style.left = `${clientX - offsetX}px`;
             currentDraggingPiece.style.top = `${clientY - offsetY}px`;


             // Highlight square under the piece if it's a possible move target
             const targetElement = document.elementFromPoint(clientX, clientY);
             const targetSquare = targetElement?.closest('.square.dark-square');

             // Clear previous drag-target highlights
             boardElement.querySelectorAll('.square.drag-target').forEach(sq => sq.classList.remove('drag-target'));

             if (targetSquare) {
                 const targetRow = parseInt(targetSquare.dataset.row);
                 const targetCol = parseInt(targetSquare.dataset.col);

                 // Check if the square under the cursor is a valid drop target (a possible move for the selected piece)
                 const isValidDropTarget = dragPossibleMoves.some(move => move.row === targetRow && move.col === targetCol);

                 if (isValidDropTarget) {
                     targetSquare.classList.add('drag-target'); // Add highlight
                 }
             }
         }

         function endDrag(event) {
             if (!currentDraggingPiece) return;

             // Prevent default touch behavior
              if (event.type === 'touchend') {
                event.preventDefault();
             }

             const clientX = event.type === 'touchend' ? event.changedTouches[0].clientX : event.clientX;
             const clientY = event.type === 'touchend' ? event.changedTouches[0].clientY : event.changedTouches[0].clientY;

             // Clean up drag styles and listeners
             currentDraggingPiece.classList.remove('dragging');
             currentDraggingPiece.style.position = 'absolute'; // Revert to absolute positioning
             currentDraggingPiece.style.zIndex = 10; // Revert z-index
             currentDraggingPiece.style.transform = 'translate(-50%, -50%)'; // Restore centering transform
             delete currentDraggingPiece.dataset.dragOffsetX; // Clean up data attributes
             delete currentDraggingPiece.dataset.dragOffsetY;

             boardElement.querySelectorAll('.square.drag-target').forEach(sq => sq.classList.remove('drag-target')); // Clean up highlights

             document.removeEventListener(isTouchDevice ? 'touchmove' : 'mousemove', moveDrag);
             document.removeEventListener(isTouchDevice ? 'touchend' : 'mouseup', endDrag);

             // Determine the target square where the piece was dropped
             const targetElement = document.elementFromPoint(clientX, clientY);
             const targetSquare = targetElement?.closest('.square.dark-square');

             let moveMade = false;
             let originalPieceRow = parseInt(currentDraggingSquare.dataset.row);
             let originalPieceCol = parseInt(currentDraggingSquare.dataset.col);


             if (targetSquare) {
                 const targetRow = parseInt(targetSquare.dataset.row);
                 const targetCol = parseInt(targetSquare.dataset.col);

                 // Find the corresponding move in the possible moves calculated at drag start
                 const validMove = dragPossibleMoves.find(move => move.row === targetRow && move.col === targetCol);

                 if (validMove) {
                     // --- Execute the valid move ---
                     // The piece element is currently visually positioned by fixed/top/left/transform(none).
                     // We need to:
                     // 1. Move the piece element to the target square in the DOM.
                     // 2. Reset its visual position/transform so it's centered in the new square.
                     // 3. Update the game state (boardState).
                     // 4. Handle post-move logic (captures, kinging, multi-jumps, turn end).

                     // Move element to target square in DOM
                     targetSquare.appendChild(currentDraggingPiece);

                     // The executeMoveLogic function updates the boardState and handles captures/kinging
                     saveCurrentStateToHistory(); // Save state BEFORE the move
                     executeMoveLogic(originalPieceRow, originalPieceCol, validMove);

                     // Update piece ID in DOM to reflect new position
                     currentDraggingPiece.dataset.pieceId = `${validMove.row}-${validMove.col}`;

                     // The piece element is now centered in the new square due to CSS (.piece absolute + translate)

                     // Handle post-move checks (multi-jumps, turn end)
                     handlePostMoveChecks(validMove);

                     moveMade = true;
                     // Sound is handled in animateAndMovePiece / handlePostMoveChecks (capture/move/king)
                 }
             }

             // If no valid move was made (dropped on invalid square or outside board)
             if (!moveMade) {
                 // Snap the piece back to its original square
                 const originalSquare = currentDraggingSquare;
                 if (originalSquare && boardElement.contains(originalSquare)) {
                     // Move element back to original square in DOM
                     originalSquare.appendChild(currentDraggingPiece);
                     // The piece will automatically be centered back in its original square due to CSS

                     // Deselect the piece only if it wasn't a continuous jump opportunity that was missed
                     // If continuous jump was required, the piece should stay selected to force the jump.
                     if (!continuousJumpPossible) {
                         deselectPiece(); // This will also trigger renderBoard
                     } else {
                          // If continuous jump was required and the drag was invalid,
                          // the piece stays selected. renderBoard() is called in handlePieceClick/selectPiece
                          // when the piece was initially selected for drag.
                          // We just need to ensure the board state and highlights are correct.
                           requestRender(); // Ensure highlights are correct after snapping back
                     }

                     playSound('undo'); // Play a sound indicating an invalid drop/snap back

                 } else {
                      // Edge case: original square no longer exists? Just deselect.
                     deselectPiece();
                 }
             }


             currentDraggingPiece = null;
             currentDraggingSquare = null;
             dragPossibleMoves = [];

             // Final deselect/render is handled by handlePostMoveChecks or the snap-back logic
         }

         // Add event listeners for drag start on the board (event delegation)
         boardElement.addEventListener(isTouchDevice ? 'touchstart' : 'mousedown', startDrag);


    </script>

</body>
</html>
